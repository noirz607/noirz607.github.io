<<<<<<< HEAD
{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-kira/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/color.styl","path":"css/color.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/constants.styl","path":"css/constants.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-code-copy.styl","path":"css/kira-code-copy.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-friends.styl","path":"css/kira-friends.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-image.styl","path":"css/kira-image.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/content.styl","path":"css/content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/media.styl","path":"css/media.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/post.styl","path":"css/post.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/sidebar.styl","path":"css/sidebar.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/right-column.styl","path":"css/right-column.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/js/kira-image.js","path":"js/kira-image.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/js/kira-code-copy.js","path":"js/kira-code-copy.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/lazysizes.js","path":"lib/lazysizes.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/smooth-scrolling.js","path":"lib/smooth-scrolling.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/css/APlayer.min.css","path":"deps/css/APlayer.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/js/Meting.min.js","path":"deps/js/Meting.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/js/APlayer.min.js","path":"deps/js/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/atom-one-dark.min.css","path":"lib/highlight/atom-one-dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.css","path":"lib/mdui/mdui.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.js","path":"lib/mdui/mdui.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/highlight.min.js","path":"lib/highlight/highlight.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Medium.woff2","path":"lib/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Bold.woff2","path":"lib/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Regular.woff2","path":"lib/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"source/images/background.png","path":"images/background.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/cover_Another_Page.jpg","path":"images/cover_Another_Page.jpg","modified":0,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/note_cover.jpg","path":"images/note_cover.jpg","modified":0,"renderable":0},{"_id":"source/images/oi_cover.jpg","path":"images/oi_cover.jpg","modified":0,"renderable":0},{"_id":"source/images/ri_chang.jpg","path":"images/ri_chang.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/archive.md","hash":"00d3773d9b4a900f930fab0daa16a60e505470b1","modified":1762595122484},{"_id":"source/note/index.md","hash":"5acb79eb1ebc329939a4f6e1a6d043f1e6424f9a","modified":1762595122500},{"_id":"source/_posts/Another_Page.md","hash":"f43eb6dbd5d500525bce7a1ae74c4dae1baa63d0","modified":1762595122477},{"_id":"source/_posts/c-languange-midterm.md","hash":"77f1820d30c6d6b839ce2a60cdcd1e4cd3cc5b7f","modified":1763279954085},{"_id":"source/_posts/digui.md","hash":"0451261a29898dc88ff834510ef70f7cac36ed41","modified":1763281322941},{"_id":"source/_posts/digui1.md","hash":"14c5168e680d3ea846afb107a9e2f33c484bf702","modified":1763281328354},{"_id":"source/_posts/note-example.md","hash":"685ce6df7296c5813d5e8e2466ba88fd7a8d40fc","modified":1762595122482},{"_id":"source/_posts/paixu1.md","hash":"67402979901eb545c068abf224af66fc1bac22ca","modified":1762595122483},{"_id":"source/_posts/oi-note-description.md","hash":"54de7a0d864e6574e09aaa20db7e2efdf6688ccc","modified":1762595122482},{"_id":"source/_posts/test.md","hash":"0424346b162534c4d4ddb25542fe4959e3c90f84","modified":1761918395799},{"_id":"source/_posts/tucao.md","hash":"0a4f8931579ec4539badd287380ecad15c209f47","modified":1762595122483},{"_id":"source/about/index.md","hash":"35fdf3afd5d1d95585b8af4ed10c294f08670a62","modified":1762595122484},{"_id":"source/images/logo.jpg","hash":"d588814657ae54a23639b80fbf0ab91b05e8b775","modified":1762595122497},{"_id":"source/images/avatar.jpg","hash":"1200d19dd2c6781c320658e4b5f120ea84eded02","modified":1762595122485},{"_id":"source/images/oi_cover.jpg","hash":"eb3edef6d9c2bf8de0c9fcf3f852a3213cacbcd1","modified":1763280162799},{"_id":"source/_posts/Another_Page/image1.jpg","hash":"61d9dfe8d775d04caf01fa01d4014dcee24251af","modified":1762595122480},{"_id":"source/images/note_cover.jpg","hash":"ded2453441d2e97bc2cd957f81b4fa91d471db3c","modified":1763279580700},{"_id":"source/images/ri_chang.jpg","hash":"c4a5ac1aae09ce542056f2fbfb96c5852e3adf5e","modified":1762595122499},{"_id":"source/images/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1762595122497},{"_id":"source/_posts/Another_Page/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1762595122479},{"_id":"node_modules/hexo-theme-kira/LICENSE","hash":"16401737d2489b2399c6bcb2274e8835bc21c2ec","modified":1761924651932},{"_id":"node_modules/hexo-theme-kira/readme.md","hash":"a32af4ed2ed53d223ad5456a5e0a45b46972306a","modified":1761924652176},{"_id":"node_modules/hexo-theme-kira/layout/friends.ejs","hash":"0702afdbfa01a4266a29f3e018928a3a4aedd16a","modified":1761924652112},{"_id":"node_modules/hexo-theme-kira/layout/archives.ejs","hash":"bc09ed31aea541e207edfa0dc1482f74ed6d8361","modified":1761924652096},{"_id":"node_modules/hexo-theme-kira/package.json","hash":"7366cfb765732b16fa06f243a6cce21b6aeb1749","modified":1761924652176},{"_id":"node_modules/hexo-theme-kira/layout/post.ejs","hash":"4ec75cf603d272ed094ea79c615cda56b861bdcb","modified":1761924652136},{"_id":"node_modules/hexo-theme-kira/layout/index.ejs","hash":"d7dd4eba4d8b4306f78e59b7f7b7142e5e9755f2","modified":1761924652127},{"_id":"node_modules/hexo-theme-kira/languages/en.yml","hash":"d3e7f13edbe8c6fcf1c18f679c8fa9f919941d5b","modified":1761924652203},{"_id":"node_modules/hexo-theme-kira/layout/layout.ejs","hash":"8b693f9d8f1579f29c3585b1f68edb0d9eea8945","modified":1761924652133},{"_id":"node_modules/hexo-theme-kira/languages/it.yml","hash":"708e1a520eebd468b9895fe5f80c79c1cdca0fc8","modified":1761924652204},{"_id":"node_modules/hexo-theme-kira/languages/ja.yml","hash":"2f848f022dd6eb70893dbf0d1f68440d487b285e","modified":1761924652205},{"_id":"node_modules/hexo-theme-kira/languages/zh-TW.yml","hash":"52c501d778ed22d242c0cd405db38c985dbccfce","modified":1761924652207},{"_id":"node_modules/hexo-theme-kira/languages/zh-HK.yml","hash":"52c501d778ed22d242c0cd405db38c985dbccfce","modified":1761924652206},{"_id":"node_modules/hexo-theme-kira/layout/_widget/archive.ejs","hash":"1b7927c453a4ba3bc91f57585d1c9a028f3a2634","modified":1761924652092},{"_id":"node_modules/hexo-theme-kira/layout/_widget/social.ejs","hash":"78ee34ba7813bc3cb9ac0155a251a7db5fc20668","modified":1761924652144},{"_id":"node_modules/hexo-theme-kira/layout/_widget/category.ejs","hash":"249ecb1c70bcbb5dd792deb7ca597ece06497cac","modified":1761924652100},{"_id":"node_modules/hexo-theme-kira/layout/_widget/tagcloud.ejs","hash":"ae70b1e05f4b9e0bdc4bc4946aab9a2f04b62441","modified":1761924652146},{"_id":"node_modules/hexo-theme-kira/languages/default.yml","hash":"975a90fd111336055181085e3c27e6f67d41f68b","modified":1761924652202},{"_id":"node_modules/hexo-theme-kira/layout/components/header.ejs","hash":"c1e28f64f4ea8cbccb77bcb7ebd78a7bbecf2f94","modified":1761924652125},{"_id":"node_modules/hexo-theme-kira/layout/components/friends.ejs","hash":"1833dafebc1997996b8c77d55683b1d97de2a71b","modified":1761924652108},{"_id":"node_modules/hexo-theme-kira/layout/components/right-column.ejs","hash":"6db93a9722a5288f96ab16dd54783e187909657f","modified":1761924652138},{"_id":"node_modules/hexo-theme-kira/layout/components/sidebar.ejs","hash":"f3a34ba45e03f231a0acc2ca81214cbb61c80d7e","modified":1761924652142},{"_id":"node_modules/hexo-theme-kira/layout/components/kira-image.ejs","hash":"3222ae7c8d79afc3cd5ed0f1e8ef1b51b3fdda36","modified":1761924652131},{"_id":"node_modules/hexo-theme-kira/source/css/archive.styl","hash":"014aeb1e8edee23ab191accde28b903094e0250a","modified":1761924652178},{"_id":"node_modules/hexo-theme-kira/source/css/color.styl","hash":"de24fe89ea6609bedb10d6883813900613bc666c","modified":1761924652180},{"_id":"node_modules/hexo-theme-kira/source/css/article.styl","hash":"5d71b0348e8777d44fcac4dd1b42691bb60ca0a0","modified":1761924652179},{"_id":"node_modules/hexo-theme-kira/languages/zh-CN.yml","hash":"975a90fd111336055181085e3c27e6f67d41f68b","modified":1761924652205},{"_id":"node_modules/hexo-theme-kira/source/css/constants.styl","hash":"9882f6fdf8b0a840b461fe68b5a5781ac5f9a135","modified":1761924652181},{"_id":"node_modules/hexo-theme-kira/source/css/kira-code-copy.styl","hash":"0ec2c5bee6b740d1c470b1552b0489ce2752a43b","modified":1761924652183},{"_id":"node_modules/hexo-theme-kira/source/css/kira-friends.styl","hash":"174acae9379c2521e9658ee7a9cca78121efdb56","modified":1761924652184},{"_id":"node_modules/hexo-theme-kira/source/css/kira-image.styl","hash":"6012db7df3e0491f2469025b8e39e3542a389e00","modified":1761924652185},{"_id":"node_modules/hexo-theme-kira/source/css/content.styl","hash":"f855d66a230c058d879afabe9440d6983228f75c","modified":1761924652182},{"_id":"node_modules/hexo-theme-kira/source/css/layout.styl","hash":"4638f0d7f257287e680ac67abd3241331a7f57c5","modified":1761924652187},{"_id":"node_modules/hexo-theme-kira/source/css/media.styl","hash":"24e882ac68cc8ae1bbcdd156192101c68859bdc7","modified":1761924652188},{"_id":"node_modules/hexo-theme-kira/source/css/post.styl","hash":"30165070270d51377ab8a5b2bd6ee03d81c2ab26","modified":1761924652189},{"_id":"node_modules/hexo-theme-kira/source/css/sidebar.styl","hash":"172f73ad5a78d7976a3b0e8f69672270520002ff","modified":1761924652191},{"_id":"node_modules/hexo-theme-kira/source/css/right-column.styl","hash":"a50707cf85e00790344d1822ca6aaf3482e06e90","modified":1761924652190},{"_id":"node_modules/hexo-theme-kira/source/js/kira-image.js","hash":"84aa358b87ca68af35b331fc1c807f68f8c22dd4","modified":1761924652163},{"_id":"node_modules/hexo-theme-kira/layout/components/copyright.ejs","hash":"7a6bf6be3cd1605c7974a33baf8b54a90a50b141","modified":1761924652104},{"_id":"node_modules/hexo-theme-kira/source/lib/lazysizes.js","hash":"3d7d083ddd43da4fbc5af70d888ad2f39d7c5f9b","modified":1761924652166},{"_id":"node_modules/hexo-theme-kira/source/lib/smooth-scrolling.js","hash":"13c907c5a0df08f4a94be5ee2ca544b5a5a247ad","modified":1761924652174},{"_id":"node_modules/hexo-theme-kira/source/js/kira-code-copy.js","hash":"768b978c8bef776a5ac32b3c86df498b881f882b","modified":1761924652162},{"_id":"node_modules/hexo-theme-kira/scripts/tag/kira-player.js","hash":"cfbae6ff10abc986ea05044c536b6870f3c2a0f5","modified":1761924652164},{"_id":"node_modules/hexo-theme-kira/scripts/tag/meting.js","hash":"9d9474ea97a789b3c1d7b1153c30475eca0967d9","modified":1761924652170},{"_id":"node_modules/hexo-theme-kira/scripts/tag/codepen.js","hash":"8b871ebc448984b97559f07313845c384080ed0f","modified":1761924652153},{"_id":"node_modules/hexo-theme-kira/scripts/tag/biliplayer.js","hash":"573c7bd45e38c96c5cad922e23d19e1abd70fb7b","modified":1761924652152},{"_id":"node_modules/hexo-theme-kira/scripts/utils/image_auto_lazyload.js","hash":"fef224ee29365821af9a0d4fe18f99665a65eb80","modified":1761924652159},{"_id":"node_modules/hexo-theme-kira/layout/components/comments/giscus.ejs","hash":"2df2a6b98e5060d0c2dd2ef9bb2f6a690a747e16","modified":1761924652116},{"_id":"node_modules/hexo-theme-kira/layout/components/comments/gitalk.ejs","hash":"6ea24c937c1b38598323cae3f42c2a5e12d8fff0","modified":1761924652121},{"_id":"node_modules/hexo-theme-kira/source/deps/js/Meting.min.js","hash":"c9a7d747dfa8fe4d3fc7ddb096b0506f55ff1fd4","modified":1761924652172},{"_id":"node_modules/hexo-theme-kira/source/deps/js/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1761924652151},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo_index.html","hash":"65b9325f267371c9e5a07a7a3a224c5766d07c18","modified":1761924652148},{"_id":"node_modules/hexo-theme-kira/source/deps/css/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1761924651991},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.css","hash":"84918de2a2e36d051ee51c3ea17f5d6e601714da","modified":1761924652062},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.js","hash":"72c1211ab8026e3f7419f05bf8860fac6e96fe65","modified":1761924652159},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.json","hash":"fccceb7956fd4f43c5ce1a18a100513ba353753c","modified":1761924652175},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1761924652047},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff","hash":"7938931f0d753453933c6c75ff1ff1d02b51c983","modified":1761924652193},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff2","hash":"47b0a99b271ef70b3663dab0d611e471db59a49b","modified":1761924652194},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.ttf","hash":"a066712350eb107bdfeb78130ec4ce58d3a29655","modified":1761924652191},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/atom-one-dark.min.css","hash":"56dddcd32332b54853ba9eadba3c883f95f00275","modified":1761924652026},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1761924652199},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1761924652196},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1761924652201},{"_id":"source/_posts/Another_Page/image2.jpg","hash":"cd470cd89bac0ec6ad5b1ae7bc0362493e454f62","modified":1762595122481},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.js","hash":"003a814293e06d95d569b7ba7bb4d2eb2a774caa","modified":1761924652169},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/highlight.min.js","hash":"9b0794e07fb0b700c73032b6ea596d88b2bbe196","modified":1761924652157},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.css","hash":"5b08b35be36d94907e2205c3ed221db03a1f7b69","modified":1761924652088},{"_id":"source/images/background.png","hash":"b6d89125771f420fcb606f9f3176fd425b854694","modified":1762595122493},{"_id":"public/note/index.html","hash":"bb5fca04c9d3fcd1acd5aace4281e12b00d00647","modified":1763281397023},{"_id":"public/about/index.html","hash":"a3b14ab8dd42215d88952adc0969c56379c67d94","modified":1763281397023},{"_id":"public/archive.html","hash":"72a7cb54d7e1712d5885595fa9564ba7618f2071","modified":1763281397023},{"_id":"public/2025/11/16/c-languange-midterm/index.html","hash":"98fbed79257fb531c030a4c69a2f49910072759c","modified":1763281397023},{"_id":"public/2025/11/06/digui1/index.html","hash":"da021fe87c365d86b0d58f801449e08f7879968c","modified":1763281397023},{"_id":"public/2025/11/05/digui/index.html","hash":"9d8cb10c1521da16492413d6f309d485292d2bf4","modified":1763281397023},{"_id":"public/2025/11/05/note-example/index.html","hash":"75f84582a25a0ad1d48fba1bc346291aa890b74b","modified":1763281397023},{"_id":"public/2025/11/05/paixu1/index.html","hash":"b08c8806218401a1399ea9456a7795284952b6d9","modified":1763281397023},{"_id":"public/2025/11/05/oi-note-description/index.html","hash":"c16ecb79828b51d979fc196dc1f5dff48ba44608","modified":1763281397023},{"_id":"public/2025/11/03/tucao/index.html","hash":"7d3a37039b1d4e6bd663ed035d6e2df3282675ef","modified":1763281397023},{"_id":"public/2025/11/02/Another_Page/index.html","hash":"efdfa773427e816a240958b17c96e38bdfc4c1e7","modified":1763281397023},{"_id":"public/2025/10/31/test/index.html","hash":"adec7c180ce3a791dcf50f9b7fd09649f857fa0f","modified":1763281397023},{"_id":"public/archives/index.html","hash":"b3828f6746277bf4661988ccc9c04fde7b0f69da","modified":1763281397023},{"_id":"public/archives/2025/index.html","hash":"643c2ad149681e32f599de1c2b1609dd1e9efc9e","modified":1763281397023},{"_id":"public/archives/2025/10/index.html","hash":"7fd443a3c556945fe0bd3a61c9fba8efb10fc7e0","modified":1763281397023},{"_id":"public/archives/2025/11/index.html","hash":"635cc88de91d5d3fa955df60d240f204c7132077","modified":1763281397023},{"_id":"public/tags/胡思乱想/index.html","hash":"b8ac6d404ad60d7c13f5f05788887050eabcfbce","modified":1763281397023},{"_id":"public/tags/吐槽/index.html","hash":"0531db1370d14d002edc16b3e2473c7b04b0938d","modified":1763281397023},{"_id":"public/categories/一些碎碎念/index.html","hash":"efc0f077d259f9942f7253c86caef61d4d0ed929","modified":1763281397023},{"_id":"public/categories/算法学习笔记/index.html","hash":"53e48d138cfb5a0f201e6da9940b1cb4dac2d943","modified":1763281397023},{"_id":"public/categories/大学学习笔记/index.html","hash":"44ded24adf5568339f9c8fae561657787a959a65","modified":1763281397023},{"_id":"public/categories/日常/index.html","hash":"e138b94cd42b2ef61a0d04a69c0774227cc5a3b0","modified":1763281397023},{"_id":"public/index.html","hash":"133e682847a2c5ffb64e4d3a3afae055ab7f7aa5","modified":1763281397023},{"_id":"public/lib/iconfont/iconfont.ttf","hash":"a066712350eb107bdfeb78130ec4ce58d3a29655","modified":1763281397023},{"_id":"public/lib/iconfont/iconfont.woff2","hash":"47b0a99b271ef70b3663dab0d611e471db59a49b","modified":1763281397023},{"_id":"public/lib/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1763281397023},{"_id":"public/lib/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1763281397023},{"_id":"public/lib/iconfont/iconfont.woff","hash":"7938931f0d753453933c6c75ff1ff1d02b51c983","modified":1763281397023},{"_id":"public/lib/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1763281397023},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1763281397023},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1763281397023},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1763281397023},{"_id":"public/images/avatar.jpg","hash":"1200d19dd2c6781c320658e4b5f120ea84eded02","modified":1763281397023},{"_id":"public/css/archive.css","hash":"f2e607d91144f695c7c37aba2ff3412ee650e2f6","modified":1763281397023},{"_id":"public/css/article.css","hash":"534dcfa3e3263a517c78af7129ed90664cb5a932","modified":1763281397023},{"_id":"public/css/kira-code-copy.css","hash":"e2e06b934d904d17afd80023cd219736d95d45dd","modified":1763281397023},{"_id":"public/css/color.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1763281397023},{"_id":"public/css/kira-image.css","hash":"e7f148597ad415ee431676cf694118f197e2bccc","modified":1763281397023},{"_id":"public/css/content.css","hash":"2b9f949c73dcf423afa7a4cf263b7dab13f8db06","modified":1763281397023},{"_id":"public/css/kira-friends.css","hash":"737dc0fd52d21322f9da44f8f439c14d24562641","modified":1763281397023},{"_id":"public/css/constants.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1763281397023},{"_id":"public/css/layout.css","hash":"7287fc37de97906622ba253e061a3ab5520d141f","modified":1763281397023},{"_id":"public/css/media.css","hash":"2add1ea023389a10ab5899749097adf68ddc27a5","modified":1763281397023},{"_id":"public/css/post.css","hash":"2c17a348b346072c24361c51e1b1519cef4a026d","modified":1763281397023},{"_id":"public/css/right-column.css","hash":"be70153defb41896afe1efcaa96455e38b820e4a","modified":1763281397023},{"_id":"public/css/sidebar.css","hash":"82078bacb367b75625c6a61dbf036068702323cc","modified":1763281397023},{"_id":"public/js/kira-code-copy.js","hash":"8229b6a7b22b313e99334d347463deaf17a92c94","modified":1763281397023},{"_id":"public/js/kira-image.js","hash":"833d671ac4f4bc9020914250f4708e27f7bd4fbe","modified":1763281397023},{"_id":"public/lib/lazysizes.js","hash":"460d0fc31226c9865b16d23b60200ddcd1c3feb4","modified":1763281397023},{"_id":"public/lib/smooth-scrolling.js","hash":"9eb8797a5d71849192d9e2ab6a7626c5c512be91","modified":1763281397023},{"_id":"public/deps/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1763281397023},{"_id":"public/deps/js/Meting.min.js","hash":"1b76611da71b63f7c0c1f04601a8ec02b0650667","modified":1763281397023},{"_id":"public/deps/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1763281397023},{"_id":"public/lib/iconfont/iconfont.css","hash":"cee8b34fa5a48b6cac84115af7e4f9f454aa9bba","modified":1763281397023},{"_id":"public/lib/iconfont/demo_index.html","hash":"b7b1a61ac0c224ee9f74a1b3e2caf2a0dfc0b486","modified":1763281397023},{"_id":"public/lib/iconfont/iconfont.json","hash":"22fc847df082b51e1fb4f5a0cd234f2949bc6cbc","modified":1763281397023},{"_id":"public/lib/iconfont/iconfont.js","hash":"72c1211ab8026e3f7419f05bf8860fac6e96fe65","modified":1763281397023},{"_id":"public/lib/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1763281397023},{"_id":"public/lib/mdui/mdui.min.js","hash":"52c385061981e1818540f8a58ac7318cfe51e50f","modified":1763281397023},{"_id":"public/lib/mdui/mdui.min.css","hash":"839d68be2a7fd54543f43335482047dd4becd43a","modified":1763281397023},{"_id":"public/lib/highlight/atom-one-dark.min.css","hash":"56dddcd32332b54853ba9eadba3c883f95f00275","modified":1763281397023},{"_id":"public/lib/highlight/highlight.min.js","hash":"f599d9b58453de85ab2ee2e68b2702a3d55c0830","modified":1763281397023},{"_id":"public/images/logo.jpg","hash":"d588814657ae54a23639b80fbf0ab91b05e8b775","modified":1763281397023},{"_id":"public/images/oi_cover.jpg","hash":"eb3edef6d9c2bf8de0c9fcf3f852a3213cacbcd1","modified":1763281397023},{"_id":"public/2025/11/02/Another_Page/image1.jpg","hash":"61d9dfe8d775d04caf01fa01d4014dcee24251af","modified":1763281397023},{"_id":"public/images/note_cover.jpg","hash":"ded2453441d2e97bc2cd957f81b4fa91d471db3c","modified":1763281397023},{"_id":"public/images/ri_chang.jpg","hash":"c4a5ac1aae09ce542056f2fbfb96c5852e3adf5e","modified":1763281397023},{"_id":"public/2025/11/02/Another_Page/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1763281397023},{"_id":"public/images/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1763281397023},{"_id":"public/2025/11/02/Another_Page/image2.jpg","hash":"cd470cd89bac0ec6ad5b1ae7bc0362493e454f62","modified":1763281397023},{"_id":"public/images/background.png","hash":"b6d89125771f420fcb606f9f3176fd425b854694","modified":1763281397023}],"Category":[{"name":"一些碎碎念","_id":"cuid9aOgD6sLL1Gh5isEHSNOG"},{"name":"算法学习笔记","_id":"cuidJOSPQk3YZbZxvZOH5NDKw"},{"name":"大学学习笔记","_id":"cuidDmF7ARvsiWJ993zazYXOX"},{"name":"日常","_id":"cuidntwAN0NmbESCr8aAXPPFo"}],"Data":[],"Page":[{"title":"笔记","layout":"category","category":"note","_content":"\n","source":"note/index.md","raw":"---\ntitle: 笔记\nlayout: category\ncategory: note\n---\n\n","date":"2025-11-08T09:45:22.500Z","updated":"2025-11-08T09:45:22.500Z","path":"note/index.html","comments":1,"_id":"cuidvNuEOPOM39u9iVlYKTqye","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"关于我自己","date":"2025-11-03T06:00:00.000Z","_content":"{% meting \"002NKWkV2LfpGY\" \"tencent\" \"song\"  \"mutex:false\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%}\n### 初次见面 👋🏻\n\n*   我是n0irzzz，可以叫我诺子或者n0。\n*   欢迎访问我的个人网站。\n*   是 ~~__世界顶级强校__~~ 中国普通大学的一名大一新生，正在学习软件工程~\n*   空闲时我会做什么：Random(\"看小说\", \"玩游戏\", \"看动漫\")\n*   有什么兴趣?   \n忠诚的铁佛寺 ~~已切割~~  jpop爱好者 纯正fps菜狗\n*   期待与你成为朋友 🤟🏻\n\n\n### 特别鸣谢 ⭐\n*   感谢[若则](https://chiyoyuki.uk/)向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  \n*   感谢[小小小朋友](https://onelittlechild.cn/),是他告诉我文字的力量，并认真阅读我的小学生作文。  \n*   感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  \n*   感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  \n*   特别感谢[gemini](https://gemini.google.com/) ~~伟大无需多言~~","source":"about/index.md","raw":"---\ntitle: 关于我自己\ndate: 2025-11-03 14:00:00\n---\n{% meting \"002NKWkV2LfpGY\" \"tencent\" \"song\"  \"mutex:false\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%}\n### 初次见面 👋🏻\n\n*   我是n0irzzz，可以叫我诺子或者n0。\n*   欢迎访问我的个人网站。\n*   是 ~~__世界顶级强校__~~ 中国普通大学的一名大一新生，正在学习软件工程~\n*   空闲时我会做什么：Random(\"看小说\", \"玩游戏\", \"看动漫\")\n*   有什么兴趣?   \n忠诚的铁佛寺 ~~已切割~~  jpop爱好者 纯正fps菜狗\n*   期待与你成为朋友 🤟🏻\n\n\n### 特别鸣谢 ⭐\n*   感谢[若则](https://chiyoyuki.uk/)向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  \n*   感谢[小小小朋友](https://onelittlechild.cn/),是他告诉我文字的力量，并认真阅读我的小学生作文。  \n*   感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  \n*   感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  \n*   特别感谢[gemini](https://gemini.google.com/) ~~伟大无需多言~~","updated":"2025-11-08T09:45:22.484Z","path":"about/index.html","comments":1,"layout":"page","_id":"cuidwvQCrCTG-ZRtMlWojQDlw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><meting-js server=\"tencent\" type=\"song\" id=\"002NKWkV2LfpGY\" mode=\"circulation\" autoplay=\"false\" mutex=\"false\" listmaxheight=\"340px\" preload=\"none\" theme=\"#ad7a86\">\n</meting-js>\n<h3><span id=\"%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2-%F0%9F%91%8B%F0%9F%8F%BB\">初次见面 👋🏻</span></h3><ul>\n<li>我是n0irzzz，可以叫我诺子或者n0。</li>\n<li>欢迎访问我的个人网站。</li>\n<li>是 <del><strong>世界顶级强校</strong></del> 中国普通大学的一名大一新生，正在学习软件工程~</li>\n<li>空闲时我会做什么：Random(“看小说”, “玩游戏”, “看动漫”)</li>\n<li>有什么兴趣?<br>忠诚的铁佛寺 <del>已切割</del>  jpop爱好者 纯正fps菜狗</li>\n<li>期待与你成为朋友 🤟🏻</li>\n</ul>\n<h3><span id=\"%E7%89%B9%E5%88%AB%E9%B8%A3%E8%B0%A2-%E2%AD%90\">特别鸣谢 ⭐</span></h3><ul>\n<li>感谢<a href=\"https://chiyoyuki.uk/\">若则</a>向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  </li>\n<li>感谢<a href=\"https://onelittlechild.cn/\">小小小朋友</a>,是他告诉我文字的力量，并认真阅读我的小学生作文。  </li>\n<li>感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  </li>\n<li>感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  </li>\n<li>特别感谢<a href=\"https://gemini.google.com/\">gemini</a> <del>伟大无需多言</del></li>\n</ul>\n</body></html>","excerpt":"","more":"<meting-js\n  server=\"tencent\"\n  type=\"song\"\n  id=\"002NKWkV2LfpGY\"\n  mode=\"circulation\"\n  autoplay=\"false\"\n  mutex=\"false\"\n  listmaxheight=\"340px\"\n  preload=\"none\"\n  theme=\"#ad7a86\">\n</meting-js>\n<h3 id=\"初次见面-👋🏻\"><a href=\"#初次见面-👋🏻\" class=\"headerlink\" title=\"初次见面 👋🏻\"></a>初次见面 👋🏻</h3><ul>\n<li>我是n0irzzz，可以叫我诺子或者n0。</li>\n<li>欢迎访问我的个人网站。</li>\n<li>是 <del><strong>世界顶级强校</strong></del> 中国普通大学的一名大一新生，正在学习软件工程~</li>\n<li>空闲时我会做什么：Random(“看小说”, “玩游戏”, “看动漫”)</li>\n<li>有什么兴趣?<br>忠诚的铁佛寺 <del>已切割</del>  jpop爱好者 纯正fps菜狗</li>\n<li>期待与你成为朋友 🤟🏻</li>\n</ul>\n<h3 id=\"特别鸣谢-⭐\"><a href=\"#特别鸣谢-⭐\" class=\"headerlink\" title=\"特别鸣谢 ⭐\"></a>特别鸣谢 ⭐</h3><ul>\n<li>感谢<a href=\"https://chiyoyuki.uk/\">若则</a>向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  </li>\n<li>感谢<a href=\"https://onelittlechild.cn/\">小小小朋友</a>,是他告诉我文字的力量，并认真阅读我的小学生作文。  </li>\n<li>感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  </li>\n<li>感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  </li>\n<li>特别感谢<a href=\"https://gemini.google.com/\">gemini</a> <del>伟大无需多言</del></li>\n</ul>\n"},{"title":"文章归档","layout":"archives","_content":"","source":"archive.md","raw":"---\ntitle: 文章归档\nlayout: archives\n---\n","date":"2025-11-08T09:45:22.484Z","updated":"2025-11-08T09:45:22.484Z","path":"archive.html","comments":1,"_id":"cuidKjqs_O6MBZea5daLrNazE","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""}],"Post":[{"title":"Another Page","date":"2025-11-02T14:29:29.000Z","cover":"/images/cover_Another_Page.jpg","_content":"# Another Page\n>但有时候我也在想：  \n要是我也能经历这样的青春的话；  \n要是我的面前有一个泪眼迷糊的女主角的话；  \n要是我也是轻小说的主角的话；  \n那时……\n我又会想什么呢？\n\n{% biliplayer BV1D64y187w8 %}\n\n真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  \n\n这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： \n\n***“要不把这个当作我博客的第一篇文章吧！”***  \n\n于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   \n\n如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” ~~搞得像你未来三年能干出什么有意义的事情一样XD~~  \n\n好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  \n  \n我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？\n\n{% asset_img image1.jpg %}  \n\n大概就是这么回应我的 ~~（没这么好看）~~  \n\n可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。\n\n前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。\n\n被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。\n\n可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。\n\n这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，\n\n多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。\n\n骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。\n\n{% asset_img image2.jpg %} \n\n我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。\n\n可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。\n\n>莫名其妙，这和我文章的主题有任何关系吗?  \n我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。\n\n可我终究不是一块枕木，一条铁轨。\n\n大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。\n\n我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？\n\n对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。\n\n“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。**“Another Page”** 我该往里面写点什么呢？\n\n或许留着空白，等我有了头绪再写也不迟吧。\n\n没有再伤感的理由了，明天已然到来。  \n纵使普普通通，也是要交数论作业的。","source":"_posts/Another_Page.md","raw":"---\ntitle: Another Page\ndate: 2025-11-02 22:29:29\ncategories:\n    - 一些碎碎念\ncover: /images/cover_Another_Page.jpg\ntag:\n    - 胡思乱想\n---\n# Another Page\n>但有时候我也在想：  \n要是我也能经历这样的青春的话；  \n要是我的面前有一个泪眼迷糊的女主角的话；  \n要是我也是轻小说的主角的话；  \n那时……\n我又会想什么呢？\n\n{% biliplayer BV1D64y187w8 %}\n\n真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  \n\n这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： \n\n***“要不把这个当作我博客的第一篇文章吧！”***  \n\n于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   \n\n如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” ~~搞得像你未来三年能干出什么有意义的事情一样XD~~  \n\n好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  \n  \n我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？\n\n{% asset_img image1.jpg %}  \n\n大概就是这么回应我的 ~~（没这么好看）~~  \n\n可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。\n\n前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。\n\n被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。\n\n可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。\n\n这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，\n\n多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。\n\n骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。\n\n{% asset_img image2.jpg %} \n\n我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。\n\n可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。\n\n>莫名其妙，这和我文章的主题有任何关系吗?  \n我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。\n\n可我终究不是一块枕木，一条铁轨。\n\n大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。\n\n我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？\n\n对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。\n\n“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。**“Another Page”** 我该往里面写点什么呢？\n\n或许留着空白，等我有了头绪再写也不迟吧。\n\n没有再伤感的理由了，明天已然到来。  \n纵使普普通通，也是要交数论作业的。","slug":"Another_Page","published":1,"updated":"2025-11-08T09:45:22.477Z","comments":1,"layout":"post","photos":[],"_id":"cuid4tYE5P1hd-w5o-EjLAFx9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"another-page\">Another Page</span></h1><blockquote>\n<p>但有时候我也在想：<br>要是我也能经历这样的青春的话；<br>要是我的面前有一个泪眼迷糊的女主角的话；<br>要是我也是轻小说的主角的话；<br>那时……<br>我又会想什么呢？</p>\n</blockquote>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1D64y187w8&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0\" style=\"width: 62em; height: 35em;\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>\n\n<p>真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  </p>\n<p>这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： </p>\n<p><em><strong>“要不把这个当作我博客的第一篇文章吧！”</strong></em>  </p>\n<p>于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   </p>\n<p>如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” <del>搞得像你未来三年能干出什么有意义的事情一样XD</del>  </p>\n<p>好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  </p>\n<p>我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？</p>\n<img src=\"/2025/11/02/Another_Page/image1.jpg\" class=\"\">  \n\n<p>大概就是这么回应我的 <del>（没这么好看）</del>  </p>\n<p>可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。</p>\n<p>前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。</p>\n<p>被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。</p>\n<p>可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。</p>\n<p>这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，</p>\n<p>多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。</p>\n<p>骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。</p>\n<img src=\"/2025/11/02/Another_Page/image2.jpg\" class=\"\"> \n\n<p>我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。</p>\n<p>可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。</p>\n<blockquote>\n<p>莫名其妙，这和我文章的主题有任何关系吗?<br>我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。</p>\n</blockquote>\n<p>可我终究不是一块枕木，一条铁轨。</p>\n<p>大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。</p>\n<p>我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？</p>\n<p>对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。</p>\n<p>“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。<strong>“Another Page”</strong> 我该往里面写点什么呢？</p>\n<p>或许留着空白，等我有了头绪再写也不迟吧。</p>\n<p>没有再伤感的理由了，明天已然到来。<br>纵使普普通通，也是要交数论作业的。</p>\n</body></html>","excerpt":"","more":"<h1 id=\"Another-Page\"><a href=\"#Another-Page\" class=\"headerlink\" title=\"Another Page\"></a>Another Page</h1><blockquote>\n<p>但有时候我也在想：<br>要是我也能经历这样的青春的话；<br>要是我的面前有一个泪眼迷糊的女主角的话；<br>要是我也是轻小说的主角的话；<br>那时……<br>我又会想什么呢？</p>\n</blockquote>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1D64y187w8&page=1&as_wide=1&high_quality=1&danmaku=0\"\nstyle=\"width: 62em; height: 35em;\"\nallowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>\n\n<p>真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  </p>\n<p>这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： </p>\n<p><em><strong>“要不把这个当作我博客的第一篇文章吧！”</strong></em>  </p>\n<p>于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   </p>\n<p>如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” <del>搞得像你未来三年能干出什么有意义的事情一样XD</del>  </p>\n<p>好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  </p>\n<p>我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？</p>\n<img src=\"/2025/11/02/Another_Page/image1.jpg\" class=\"\">  \n\n<p>大概就是这么回应我的 <del>（没这么好看）</del>  </p>\n<p>可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。</p>\n<p>前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。</p>\n<p>被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。</p>\n<p>可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。</p>\n<p>这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，</p>\n<p>多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。</p>\n<p>骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。</p>\n<img src=\"/2025/11/02/Another_Page/image2.jpg\" class=\"\"> \n\n<p>我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。</p>\n<p>可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。</p>\n<blockquote>\n<p>莫名其妙，这和我文章的主题有任何关系吗?<br>我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。</p>\n</blockquote>\n<p>可我终究不是一块枕木，一条铁轨。</p>\n<p>大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。</p>\n<p>我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？</p>\n<p>对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。</p>\n<p>“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。<strong>“Another Page”</strong> 我该往里面写点什么呢？</p>\n<p>或许留着空白，等我有了头绪再写也不迟吧。</p>\n<p>没有再伤感的理由了，明天已然到来。<br>纵使普普通通，也是要交数论作业的。</p>\n"},{"title":"note example","date":"2025-11-05T11:39:16.000Z","cover":"/images/oi_cover.jpg","_content":"整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。  \n我决定给自己提供一个笔记模板。\n\n---\n## 算法\n\n[介绍]\n\n## 题目\n### [题目名称](www.example.com)\n(遇到的问题)\n\n\n---\n这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。","source":"_posts/note-example.md","raw":"---\ntitle: note example\ndate: 2025-11-05 19:39:16\ntags: \ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。  \n我决定给自己提供一个笔记模板。\n\n---\n## 算法\n\n[介绍]\n\n## 题目\n### [题目名称](www.example.com)\n(遇到的问题)\n\n\n---\n这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。","slug":"note-example","published":1,"updated":"2025-11-08T09:45:22.482Z","comments":1,"layout":"post","photos":[],"_id":"cuidrSeEai2EWWXetJju_6ZrF","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。<br>我决定给自己提供一个笔记模板。</p>\n<hr>\n<h2><span id=\"%E7%AE%97%E6%B3%95\">算法</span></h2><p>[介绍]</p>\n<h2><span id=\"%E9%A2%98%E7%9B%AE\">题目</span></h2><h3><span id=\"%E9%A2%98%E7%9B%AE%E5%90%8D%E7%A7%B0\"></span></h3><p>(遇到的问题)</p>\n<hr>\n<p>这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。</p>\n</body></html>","excerpt":"","more":"<p>整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。<br>我决定给自己提供一个笔记模板。</p>\n<hr>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>[介绍]</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h3 id=\"题目名称\"><a href=\"#题目名称\" class=\"headerlink\" title=\"题目名称\"></a><a href=\"www.example.com\">题目名称</a></h3><p>(遇到的问题)</p>\n<hr>\n<p>这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。</p>\n"},{"title":"程序设计期中复习","date":"2025-11-16T07:49:51.000Z","cover":"/images/note_cover.jpg","_content":"我发现好久好久没写博客了。  \n懒狗是这样的。  \n先传一点笔记吧。  \n\n---\n\n### 📚 知识点大纲\n\n1.  **第1章：程序设计与问题解决概述**\n    * 1.1 程序与程序设计\n    * 1.2 问题解决的阶段\n    * 1.3 编程语言的层次\n    * 1.4 程序的编译与执行\n    * 1.5 基本控制结构\n    * 1.6 计算机基本组成\n2.  **第2章：C语言基础：类型、变量、常量与运算符**\n    * 2.1 标识符、变量与常量\n    * 2.2 数据类型\n    * 2.3 运算符与表达式\n3.  **第3章：控制结构**\n    * 3.1 选择结构\n    * 3.2 循环结构\n4.  **第4章：函数与程序结构**\n    * 4.1 函数基础\n    * 4.2 参数传递\n    * 4.3 作用域、生命周期与存储类型\n    * 4.4 递归\n    * 4.5 C预处理器\n5.  **第5章：数组**\n    * 5.1 一维数组\n    * 5.2 数组与函数\n    * 5.3 数组算法：排序与搜索\n    * 5.4 多维数组\n\n---\n\n### 📖 详细知识点\n\n## 第1章：程序设计与问题解决概述\n\n### 1.1 程序与程序设计\n* **程序 (Program):** 由计算机执行的一系列指令。\n* **程序设计 (Programming):** 为计算机规划一系列执行步骤的过程。\n\n### 1.2 问题解决的阶段\n1.  **问题解决阶段:**\n    * 需求分析与规范。\n    * **算法设计 (Algorithm):** 在有限的时间内逐步解决问题的过程。\n2.  **实现阶段:**\n    * **编码 (Coding):** 将算法翻译成编程语言。\n    * 调试与测试。\n3.  **维护阶段:**\n    * 使用、修正错误、改进功能。\n\n### 1.3 编程语言的层次\n* **机器语言 (Machine Language):**\n    * 由0和1组成的二进制编码指令。\n    * 计算机唯一可以直接理解和执行的语言。\n    * 不可移植，可读性差。\n* **汇编语言 (Assembly Language):**\n    * 使用助记符（如 `LOAD`, `ADD`）来表示机器指令。\n    * 需要汇编器(Assembler)进行翻译。\n* **高级语言 (High-level Language):**\n    * 语言类似自然语言，易于读、写和理解。\n    * 可移植性好。\n    * 示例：C, C++, Java, Python。\n\n### 1.4 程序的编译与执行\n* **编译器 (Compiler):**\n    * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。\n    * 编译型语言执行速度通常更快，源码是私有的。\n    * 缺点是不跨平台（C, C++）。\n* **解释器 (Interpreter):**\n    * 逐行解释并执行源代码。\n    * 解释型语言通常跨平台，易于调试。\n    * 缺点是执行速度较慢，源码是公开的（Python, PHP）。\n* **C语言的编译执行流程:**\n    1.  **源文件 (Source):** 程序员编写的 `.c` 文件（如 `myprog.c`）。\n    2.  **编译器 (Compiler):** 将源文件翻译成机器语言的 **目标文件 (Object)**（如 `myprog.o`）。\n    3.  **链接器 (Linker):** 将目标文件与库函数等其他代码组合起来，生成 **可执行文件 (Executable)**（如 `myprog.exe`）。\n\n### 1.5 基本控制结构\n程序由四种基本的控制结构组成：\n1.  **顺序结构 (Sequence):** 语句按顺序一条接一条地执行。\n2.  **选择结构 (Selection / Branch):** 根据特定条件执行不同的语句（如 `if`, `switch`）。\n3.  **循环结构 (Loop / Repetition):** 在满足特定条件时重复执行某些语句（如 `while`, `for`）。\n4.  **子程序 (Subprogram / Function):** 将程序分解为更小的单元（函数）。\n\n### 1.6 计算机基本组成\n* **硬件 (Hardware):**\n    * **中央处理单元 (CPU):**\n        * **算术逻辑单元 (ALU):** 执行算术运算和逻辑比较。\n        * **控制单元 (Control Unit):** 控制程序指令的执行顺序。\n    * **内存单元 (Memory Unit):**\n        * 有序的存储单元序列，每个单元有唯一地址。\n        * 用于存放数据和程序指令。\n    * **外围设备 (Peripherals):**\n        * 输入设备（如键盘、鼠标）。\n        * 输出设备（如显示器、打印机）。\n        * 辅助存储设备（如硬盘、CD-ROM）。\n* **软件 (Software):**\n    * **系统软件 (System Software):** 如操作系统（OS），用于管理计算机资源。\n    * **应用软件 (Application):** 用户执行特定任务的程序。\n\n## 第2章：C语言基础：类型、变量、常量与运算符\n\n### 2.1 标识符、变量与常量\n* **变量 (Variable):**\n    * 程序中用于存放数据的容器（存储区域）。\n    * 变量名是内存位置的符号表示。\n    * 声明变量时必须指定其名称和数据类型。\n* **标识符 (Identifier):** (即变量名、函数名等)\n    * **命名规则:**\n        1.  只能包含字母（大小写）、数字和下划线 `_`。\n        2.  必须以字母或下划线 `_` 开头（不能是数字）。\n        3.  长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。\n    * **命名注意事项:**\n        1.  应使用有意义的名称（如 `firstName` 而不是 `fn`）。\n        2.  **区分大小写** (如 `name` 和 `Name` 是不同的)。\n        3.  **不能** 使用C语言的 **关键字** (Reserved words) 作为标识符。\n* **常量 (Constant):**\n    * **字面值常量 (Literal value):** 直接写在代码中的值，如 `100`, `3.14`, `'A'`。\n    * **命名常量 (Named constant):**\n        1.  使用 `const` 修饰符：`const int VOTING_AGE = 18;`。\n        2.  使用 `#define` 预处理指令：`#define VOTING_AGE 18`。\n    * 命名常量的值在程序执行期间不能被更改。\n* **声明与赋值:**\n    * **声明 (Declaration):** 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。\n    * **赋值 (Assignment):** 使用赋值运算符 `=` 来给变量一个值。\n        * 赋值语句的左侧必须是变量，右侧是值或表达式。\n\n### 2.2 数据类型\n* **数据类型 (Data Type):**\n    * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。\n    * 每种数据类型需要不同大小的内存。\n    * C语言数据类型分为：简单类型、结构类型和地址类型。\n* **`sizeof` 运算符:**\n    * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。\n    * 示例：`sizeof(int)`, `sizeof(age)`。\n    * C语言保证的最小大小：`sizeof(char)` 为 1，`short` 至少16位，`long` 至少32位。\n* **整型 (Integral Types):**\n    * 用于表示整数，包括 `char`, `short`, `int`, `long`。\n    * **`char`:** 字符类型，用于表示单个字符。\n        * 字符在内存中以其 **ASCII** 码值（整数）存储。\n        * 字符常量用单引号 `' '` 括起来，如 `'B'`, `'4'`。\n        * **转义字符 (Escape character):** 特殊字符，如 `\\n` (换行), `\\t` (制表符), `\\\\` (反斜杠), `\\\"` (双引号)。\n    * **整型字面值:**\n        * 十进制 (Decimal): 正常书写，如 `16`, `498`。\n        * 八进制 (Octal): 以 `0` 开头，如 `022`。\n        * 十六进制 (Hexadecimal): 以 `0x` 或 `0X` 开头，如 `0xFF`。\n* **浮点型 (Floating Types):**\n    * 用于表示带小数点的实数，包括 `float`, `double`, `long double`。\n    * **科学计数法:** 使用 `E` 或 `e` 表示，如 `1.84E1` (即 1.84 x 10¹)。\n    * **默认类型:** 没有后缀的浮点常量（如 `94.6`）默认为 `double` 类型。\n    * **后缀:** `F` 或 `f` 表示 `float` (如 `94.6F`)；`L` 或 `l` 表示 `long double`。\n    * **精度:** 计算机不能精确表示所有浮点数。`double` 的精度高于或等于 `float`。\n* **布尔型 (`bool`):**\n    * C99标准引入，需要包含头文件 `<stdbool.h>`。\n    * 值只有 `true` (1) 或 `false` (0)。\n* **字符串型 (String):**\n    * 用双引号 `\" \"` 括起来的字符序列，如 `\"Hello\"`。\n    * **不是C的内置类型**，它本质上是一个 **字符数组 (char array)**。\n    * 以空字符 `\\0` 作为结尾标记。\n    * 字符串操作函数（如 `strlen`）定义在 `<string.h>` 头文件中。\n    * `\"a\"` (字符串) 与 `'a'` (字符) 是不同的。\n\n### 2.3 运算符与表达式\n* **表达式 (Expression):** 变量、常量和运算符的有效组合，可被求值以计算出一个值。\n* **算术运算符 (Arithmetic):**\n    * 一元：`+` (正), `-` (负)。\n    * 二元：`+`, `-`, `*`。\n    * **`/` (除法):**\n        * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。\n        * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。\n    * **`%` (模/取余):**\n        * 操作数 **只能是整数**。\n        * 结果是整数除法后的余数。\n        * 结果的符号由左操作数决定 (C语言中)。\n* **自增/自减运算符:**\n    * `++` (自增) 和 `--` (自减)。\n    * **前缀 (Prefix):** `++a`。先改变（加1或减1），再使用新值参与表达式运算。\n    * **后缀 (Postfix):** `a++`。先使用原值参与表达式运算，然后再改变（加1或减1）。\n* **赋值运算符 (Assignment):**\n    * `=` (赋值)。\n    * **复合赋值:** `+=`, `-=`, `*=`, `/=`。例如 `age += 3;` 等同于 `age = age + 3;`。\n* **关系运算符 (Relational):**\n    * `>`, `<`, `>=`, `<=`, `==` (等于), `!=` (不等于)。\n    * 结果为 `true` (非0) 或 `false` (0)。\n    * 注意：`=` (赋值) 和 `==` (等于) 是不同的。\n* **逻辑运算符 (Logical):**\n    * `!` (非), `&&` (与), `||` (或)。\n    * **短路求值 (Short-Circuit):**\n        * 对于 `&&`：如果左侧为 `false` (0)，则不再计算右侧。\n        * 对于 `||`：如果左侧为 `true` (非0)，则不再计算右侧。\n* **条件运算符 (Ternary):**\n    * C语言中唯一的三元运算符：`Expression1 ? Expression2 : Expression3`。\n    * 如果 `Expression1` 为 `true`，则整个表达式的值为 `Expression2`；否则为 `Expression3`。\n* **位运算符 (Bitwise):**\n    * 对操作数的二进制位进行操作。\n    * `&` (按位与), `|` (按位或), `^` (按位异或), `~` (按位非/取反)。\n    * `<<` (左移), `>>` (右移)。\n* **逗号运算符 (Comma):**\n    * `expression1, expression2`。\n    * 从左到右依次求值，整个表达式的值等于最后一个表达式 (`expression2`) 的值。\n    * 优先级是所有运算符中最低的。\n* **优先级 (Precedence) 与 结合性 (Associativity):**\n    * **优先级** 决定了哪个运算符先执行（如 `*` / `/` 优先于 `+` / `-`）。\n    * **结合性** 决定了同优先级运算符的执行顺序（如 `* / % + -` 都是左结合，从左到右）。\n    * 一元运算符、条件运算符、赋值运算符是 **右结合**（从右到左）。\n    * 可以使用 **圆括号 `()`** 来强制改变运算顺序。\n* **类型转换 (Type Conversion):**\n    * **隐式转换 (Coercion):** 编译器自动进行的类型转换。\n        * 发生在赋值时（如 `int i = 4.8;` i 变为 4）。\n        * 发生在混合类型表达式中。\n    * **类型提升 (Promotion):** 在表达式中，`char` 和 `short` 类型的值会自动提升为 `int`。\n    * **混合运算:** 较低类型会临时提升为较高类型（int -> long -> float -> double）。\n    * **显式转换 (Casting):** 程序员强制进行的类型转换。\n        * 语法：`(typename) expression`。\n        * 示例：`celsius = (5.0/9.0) * (fahr-32);`（对比 `5/9` 结果为0）。\n        * 浮点数转整数时，C99规定向0取整（截断小数）。\n\n## 第3章：控制结构\n\n### 3.1 选择结构\n* **`if` 语句 (单路选择):**\n    * 语法：`if ( Expression ) Statement`。\n    * 如果 `Expression` 为 `true` (非0)，则执行 `Statement`。\n* **`if-else` 语句 (双路选择):**\n    * 语法：`if ( Expression ) StatementA else StatementB`。\n    * 如果 `Expression` 为 `true`，执行 `StatementA`；否则执行 `StatementB`。\n* **`{}` 块的使用:**\n    * `if` 或 `else` 后面如果需要执行多条语句，必须使用花括号 `{}` 将它们括起来形成一个语句块。\n    * 如果省略 `{}`，`else` 会与最近的未配对的 `if` 结合（**悬垂else问题**）。\n* **`if-else if-else` 结构 (多路选择):**\n    * 用于实现多路分支。\n    * 按顺序测试每个 `Expression`，一旦找到为 `true` 的，就执行其后的 `Statement`，然后跳出整个结构。\n    * 如果所有 `if` 都不为 `true`，则执行最后的 `else` 块（如果存在）。\n* **`switch` 语句 (多路选择):**\n    * 语法：`switch ( IntegralExpression ) { ... }`。\n    * `IntegralExpression` 必须是整型（`char`, `int`, `long`, `enum`）。\n    * `case Constant:`：`Constant` 必须是常量表达式。\n    * **`break`:**\n        * 用于跳出 `switch` 语句。\n        * 如果省略 `break`，程序会 **穿透 (fall-through)** 并继续执行下一个 `case` 的语句。\n    * **`default`:**\n        * 可选。如果没有任何 `case` 匹配，则执行 `default` 块。\n* **测试:**\n    * 测试选择结构时，应确保每个分支至少被执行一次（**最小完全覆盖**）。\n\n### 3.2 循环结构\n* **循环 (Loop):** 一种重复执行某个语句块的控制结构。\n* **`while` 循环 (当型循环):**\n    * 语法：`while ( Expression ) { ...body... }`。\n    * **先测试 (Pre-test):** 在每次迭代 *之前* 检查 `Expression`。\n    * 如果 `Expression` 为 `false`，循环体可能一次也不执行。\n* **`do-while` 循环 (直到型循环):**\n    * 语法：`do { ...body... } while ( Expression );`。\n    * **后测试 (Post-test):** 在每次迭代 *之后* 检查 `Expression`。\n    * 循环体 **至少执行一次**。\n* **`for` 循环:**\n    * 语法：`for ( initialization ; test_expression ; update ) { ...body... }`。\n    * `initialization`：循环开始前执行一次（通常用于初始化循环变量）。\n    * `test_expression`：每次迭代前检查，若为 `false` 则退出循环。\n    * `update`：每次迭代 *之后* 执行（通常用于更新循环变量）。\n* **循环控制:**\n    * **`break`:** 立即 **跳出** 并终止其所在的最内层循环（或 `switch`）。\n    * **`continue`:** 立即 **跳过** 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 `for` 循环，会先执行 `update`）。\n    * **`goto` 和 `label`:**\n        * 提供从 `goto` 到同一函数内 `label` 的无条件跳转。\n        * 不推荐使用，但可用于跳出深度嵌套的结构。\n* **嵌套循环 (Nested Loop):**\n    * 一个循环体内包含另一个循环。\n    * `break` 或 `continue` 只影响最内层的循环。\n\n## 第4章：函数与程序结构\n\n### 4.1 函数基础\n* **函数 (Function):** 用于实现特定功能的一段程序代码。\n* **使用原因:** 避免代码重复、使程序结构化、提高可读性。\n* **函数声明 (Declaration / Prototype):**\n    * 告知编译器函数的返回类型、名称和参数类型。\n    * 语法：`type function_name(type arg1, type arg2, ...);`。\n    * 必须在使用函数前进行声明（通常放在 `main` 函数之前）。\n* **函数定义 (Definition):**\n    * 提供函数的具体实现（函数头 + 函数体）。\n    * **函数头 (Head):** `type function_name(type arg1, type arg2, ...)`。\n    * **函数体 (Body):** `{ ... your code ... }`。\n* **`return` 语句:**\n    * 用于从函数返回一个值。\n    * 函数最多只能返回 **1个** 值，该值的类型必须与声明的返回类型匹配。\n    * **`void` 函数:**\n        * 表示函数不返回值。\n        * 可以使用 `return;` 语句立即退出函数。\n* **函数调用 (Function Call):**\n    * 通过函数名和参数列表来执行函数。\n    * 程序控制权临时从调用函数转移到被调用函数。\n    * 被调用函数执行完毕后，控制权返回到调用点。\n\n### 4.2 参数传递\n* **形参 (Parameter / Formal Parameter):** 在函数 **定义** 或声明中指定的变量。\n* **实参 (Argument / Actual Parameter):** 在函数 **调用** 时传递给函数的具体值或变量。\n* **传递方式:**\n    1.  **值传递 (Pass by Value):**\n        * C语言的默认方式。\n        * 将实参的 **值复制** 一份传递给形参。\n        * 在函数内部修改形参 **不会** 影响到函数外部的实参。\n    2.  **地址/指针传递 (Pass by Address):**\n        * 将实参的 **地址** 传递给形参。\n        * 形参必须是 **指针类型** (如 `int *x`)。\n        * 实参必须是地址（如 `&a`）。\n        * 在函数内部通过指针修改形参所指向的内存，**会** 影响到函数外部的实参。\n    3.  **引用传递 (Pass by Reference):**\n        * 这是 C++ 的特性，**C语言不支持**。\n        * 形参是实参的别名（如 `int &x`）。\n\n### 4.3 作用域、生命周期与存储类型\n* **作用域 (Scope):** 标识符（变量或函数名）在程序中可以被合法使用的区域。\n    * **局部作用域 (Local Scope):** 标识符在块（`{}`内）或函数内部声明，其作用域从声明点到块或函数结束。\n    * **全局作用域 (Global Scope):** 标识符在所有函数之外声明，其作用域从声明点到文件结尾。\n    * **名称优先级:** 局部变量会“隐藏”同名的全局变量。\n* **生命周期 (Lifetime):** 程序执行期间，标识符实际拥有内存分配的时间。\n* **存储类型:**\n    * **自动变量 (Automatic):**\n        * 默认的局部变量存储类型（可省略 `auto` 关键字）。\n        * 存储在 **栈** 中。\n        * **生命周期:** 函数调用时创建，函数退出时销毁。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n    * **外部变量 (External):**\n        * 即全局变量，定义在所有函数之外。\n        * 使用 `extern` 关键字在其他文件中 **声明** （非定义），表示引用一个已在别处定义的全局变量。\n        * **生命周期:** 整个程序运行期间。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **静态变量 (Static):**\n        * 使用 `static` 关键字声明。\n        * **静态全局变量:** 作用域被限制在声明它的文件内部，其他文件不可访问。\n        * **静态局部变量:**\n            * 作用域仍是局部的（函数内）。\n            * **生命周期:** 整个程序运行期间。\n            * 只在 **第一次** 调用函数时初始化一次。\n            * 在函数多次调用之间 **保持其值**。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **寄存器变量 (Register):**\n        * 使用 `register` 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n\n### 4.4 递归\n* **递归 (Recursion):** 一个函数调用其自身的过程。\n* **递归的两个要素:**\n    1.  **基本情况 (Base Case):** 递归的停止条件，一个无需递归即可解决的简单情况。\n    2.  **递归步骤 (Recursive Step):** 将问题分解为更小的、同类的问题，并通过递归调用来解决。\n* **递归 vs. 迭代 (Iteration):**\n    * 任何递归都可以用迭代（循环）和栈来代替。\n    * 迭代（循环）在执行速度和空间占用上通常 **优于** 递归。\n\n### 4.5 C预处理器\n* 在编译之前对源代码进行处理的程序。\n* **文件包含 (`#include`):**\n    * `#include <filename>`: 在标准库目录或系统路径中查找文件。\n    * `#include \"filename\"`: 从源程序当前目录开始搜索（通常用于自定义头文件）。\n* **宏替换 (`#define`):**\n    * 定义一个宏（一个名称和一段替换文本）。\n    * 预处理器会在编译前进行 **原样文本替换**。\n    * **带参数的宏:** `define max(A,B) ((A) > (B) ? (A) : (B))`。\n    * **宏的陷阱:**\n        * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。\n        * 注意带副作用的参数，如 `max(i++, j++)`，会导致 `i` 或 `j` 被自增多次。\n* **条件包含 (`#if`...):**\n    * 允许根据预处理时的条件来选择性地编译某段代码。\n    * 指令包括：`#if`, `#elif`, `#else`, `#endif`。\n    * `#ifndef`: \"if not defined\"，常用于防止头文件被重复包含。\n\n## 第5章：数组\n\n### 5.1 一维数组\n* **数组 (Array):** 存储 **相同数据类型** 的元素的集合，这些元素在内存中 **连续存放**。\n* **数组声明:**\n    * 语法：`DataType ArrayName [ConstIntExpression];`。\n    * `ConstIntExpression` 必须是 **常量表达式**，指定数组的大小（元素个数）。\n    * 数组大小一旦固定，不可更改。\n* **数组元素访问:**\n    * 通过 **下标 (Index / Subscript)** 访问，下标从 **0** 开始。\n    * `temps[0]` 是第一个元素，`temps[4]` 是第五个元素（对于大小为5的数组）。\n* **数组名:**\n    * 数组名（如 `temps`）本身是一个 **指针**，其值是数组的 **基地址**（即第一个元素 `temps[0]` 的内存地址）。\n* **数组初始化:**\n    * 可以在声明时初始化：`int ages[5] = {40, 13, 20, 19, 36};`。\n    * 可以省略大小，编译器会自动计算：`int ages[] = {40, 13, 20};`。\n    * **部分初始化:** `int a[5] = { 2 };` 第一个元素为2，其余所有元素自动初始化为 0。\n* **数组的限制:**\n    * **无边界检查 (No Bound Checking):** C语言不检查数组下标是否越界。访问 `myList[-1]` 或 `myList[11]`（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。\n    * **无聚合操作 (No Aggregate Operations):** 不能将一个数组整体赋值给另一个数组（如 `x = y;` 是错误的）。\n    * 数组复制必须通过循环逐个元素进行。\n\n### 5.2 数组与函数\n* **数组作为函数参数:**\n    * 当数组作为参数传递时，传递的是数组的 **基地址**。\n    * 因此，函数参数传递总是 **地址传递**。\n    * 在函数内部对形参数组的修改 **会** 影响到主调函数中的实参数组。\n    * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。\n* **形参声明:**\n    * `float FindMax(float arr[], int n)`\n    * `float FindMax(float *arr, int n)` (等价)\n* **`const` 保护数组参数:**\n    * 如果不希望函数修改数组内容，应在形参声明中使用 `const` 关键字。\n    * 示例：`float FindMax(const float arr[], int n)`。\n\n### 5.3 数组算法：排序与搜索\n* **选择排序 (Selection Sort):**\n    * **算法思想:**\n        1.  从头（`passCount = 0`）开始。\n        2.  在 `data[passCount ... length-1]` 范围内找到 **最小** 元素的索引 `minIndx`。\n        3.  将 `data[minIndx]` 与 `data[passCount]` 交换。\n        4.  `passCount` 增加1，重复该过程，直到 `passCount` 达到 `length - 2`。\n* **线性搜索 (Linear / Sequential Search):**\n    * 适用于 **未排序** 的数组。\n    * 从头到尾（`i=0` 到 `n-1`）逐个检查元素，看是否等于目标值 `x`。\n    * 找到则返回索引 `i`，遍历完未找到则返回 `-1`。\n* **二分搜索 (Binary Search):**\n  C* **必须** 适用于 **已排序** 的数组。\n    * **算法思想:**\n        1.  设 `first = 0`, `last = arraySize - 1`。\n        2.  当 `last >= first` 时循环：\n        3.  计算中间索引 `mid = (first + last) / 2`。\n        4.  如果 `key == list[mid]`，则找到，返回 `mid`。\n        5.  如果 `key < list[mid]`，则目标在左半边，令 `last = mid - 1`。\n        6.  如果 `key > list[mid]`，则目标在右半边，令 `first = mid + 1`。\n        7.  循环结束仍未找到，返回 `-1`。\n\n### 5.4 多维数组\n* **二维数组 (Two-Dimensional Array):**\n    * 按行和列组织的同类型元素集合。\n    * **声明:** `DataType ArrayName [Rows] [Cols];`。\n    * **访问:** `stateHighs[2][7]` (访问第3行第8列的元素)。\n    * **内存存储:** 在内存中按 **行优先 (Row Order)** 连续存储（第一行所有元素，接着是第二行所有元素...）。\n* **多维数组作为函数参数:**\n    * 传递的仍然是基地址。\n    * **必须** 指定 **除第一维之外** 的所有维度的大小。\n    * 示例：`void FindAverages(const int stateHighs[][NUM_MONTHS], ...)`。\n* **`typedef` 与数组:**\n    * 可以使用 `typedef` 来定义数组类型，使函数原型更简洁明了。\n    * 示例：`typedef int SalesType[3][12][5];` `SalesType sales;`。\n","source":"_posts/c-languange-midterm.md","raw":"---\ntitle: 程序设计期中复习\ndate: 2025-11-16 15:49:51\ncategories : 大学学习笔记\ncover: /images/note_cover.jpg\n---\n我发现好久好久没写博客了。  \n懒狗是这样的。  \n先传一点笔记吧。  \n\n---\n\n### 📚 知识点大纲\n\n1.  **第1章：程序设计与问题解决概述**\n    * 1.1 程序与程序设计\n    * 1.2 问题解决的阶段\n    * 1.3 编程语言的层次\n    * 1.4 程序的编译与执行\n    * 1.5 基本控制结构\n    * 1.6 计算机基本组成\n2.  **第2章：C语言基础：类型、变量、常量与运算符**\n    * 2.1 标识符、变量与常量\n    * 2.2 数据类型\n    * 2.3 运算符与表达式\n3.  **第3章：控制结构**\n    * 3.1 选择结构\n    * 3.2 循环结构\n4.  **第4章：函数与程序结构**\n    * 4.1 函数基础\n    * 4.2 参数传递\n    * 4.3 作用域、生命周期与存储类型\n    * 4.4 递归\n    * 4.5 C预处理器\n5.  **第5章：数组**\n    * 5.1 一维数组\n    * 5.2 数组与函数\n    * 5.3 数组算法：排序与搜索\n    * 5.4 多维数组\n\n---\n\n### 📖 详细知识点\n\n## 第1章：程序设计与问题解决概述\n\n### 1.1 程序与程序设计\n* **程序 (Program):** 由计算机执行的一系列指令。\n* **程序设计 (Programming):** 为计算机规划一系列执行步骤的过程。\n\n### 1.2 问题解决的阶段\n1.  **问题解决阶段:**\n    * 需求分析与规范。\n    * **算法设计 (Algorithm):** 在有限的时间内逐步解决问题的过程。\n2.  **实现阶段:**\n    * **编码 (Coding):** 将算法翻译成编程语言。\n    * 调试与测试。\n3.  **维护阶段:**\n    * 使用、修正错误、改进功能。\n\n### 1.3 编程语言的层次\n* **机器语言 (Machine Language):**\n    * 由0和1组成的二进制编码指令。\n    * 计算机唯一可以直接理解和执行的语言。\n    * 不可移植，可读性差。\n* **汇编语言 (Assembly Language):**\n    * 使用助记符（如 `LOAD`, `ADD`）来表示机器指令。\n    * 需要汇编器(Assembler)进行翻译。\n* **高级语言 (High-level Language):**\n    * 语言类似自然语言，易于读、写和理解。\n    * 可移植性好。\n    * 示例：C, C++, Java, Python。\n\n### 1.4 程序的编译与执行\n* **编译器 (Compiler):**\n    * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。\n    * 编译型语言执行速度通常更快，源码是私有的。\n    * 缺点是不跨平台（C, C++）。\n* **解释器 (Interpreter):**\n    * 逐行解释并执行源代码。\n    * 解释型语言通常跨平台，易于调试。\n    * 缺点是执行速度较慢，源码是公开的（Python, PHP）。\n* **C语言的编译执行流程:**\n    1.  **源文件 (Source):** 程序员编写的 `.c` 文件（如 `myprog.c`）。\n    2.  **编译器 (Compiler):** 将源文件翻译成机器语言的 **目标文件 (Object)**（如 `myprog.o`）。\n    3.  **链接器 (Linker):** 将目标文件与库函数等其他代码组合起来，生成 **可执行文件 (Executable)**（如 `myprog.exe`）。\n\n### 1.5 基本控制结构\n程序由四种基本的控制结构组成：\n1.  **顺序结构 (Sequence):** 语句按顺序一条接一条地执行。\n2.  **选择结构 (Selection / Branch):** 根据特定条件执行不同的语句（如 `if`, `switch`）。\n3.  **循环结构 (Loop / Repetition):** 在满足特定条件时重复执行某些语句（如 `while`, `for`）。\n4.  **子程序 (Subprogram / Function):** 将程序分解为更小的单元（函数）。\n\n### 1.6 计算机基本组成\n* **硬件 (Hardware):**\n    * **中央处理单元 (CPU):**\n        * **算术逻辑单元 (ALU):** 执行算术运算和逻辑比较。\n        * **控制单元 (Control Unit):** 控制程序指令的执行顺序。\n    * **内存单元 (Memory Unit):**\n        * 有序的存储单元序列，每个单元有唯一地址。\n        * 用于存放数据和程序指令。\n    * **外围设备 (Peripherals):**\n        * 输入设备（如键盘、鼠标）。\n        * 输出设备（如显示器、打印机）。\n        * 辅助存储设备（如硬盘、CD-ROM）。\n* **软件 (Software):**\n    * **系统软件 (System Software):** 如操作系统（OS），用于管理计算机资源。\n    * **应用软件 (Application):** 用户执行特定任务的程序。\n\n## 第2章：C语言基础：类型、变量、常量与运算符\n\n### 2.1 标识符、变量与常量\n* **变量 (Variable):**\n    * 程序中用于存放数据的容器（存储区域）。\n    * 变量名是内存位置的符号表示。\n    * 声明变量时必须指定其名称和数据类型。\n* **标识符 (Identifier):** (即变量名、函数名等)\n    * **命名规则:**\n        1.  只能包含字母（大小写）、数字和下划线 `_`。\n        2.  必须以字母或下划线 `_` 开头（不能是数字）。\n        3.  长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。\n    * **命名注意事项:**\n        1.  应使用有意义的名称（如 `firstName` 而不是 `fn`）。\n        2.  **区分大小写** (如 `name` 和 `Name` 是不同的)。\n        3.  **不能** 使用C语言的 **关键字** (Reserved words) 作为标识符。\n* **常量 (Constant):**\n    * **字面值常量 (Literal value):** 直接写在代码中的值，如 `100`, `3.14`, `'A'`。\n    * **命名常量 (Named constant):**\n        1.  使用 `const` 修饰符：`const int VOTING_AGE = 18;`。\n        2.  使用 `#define` 预处理指令：`#define VOTING_AGE 18`。\n    * 命名常量的值在程序执行期间不能被更改。\n* **声明与赋值:**\n    * **声明 (Declaration):** 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。\n    * **赋值 (Assignment):** 使用赋值运算符 `=` 来给变量一个值。\n        * 赋值语句的左侧必须是变量，右侧是值或表达式。\n\n### 2.2 数据类型\n* **数据类型 (Data Type):**\n    * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。\n    * 每种数据类型需要不同大小的内存。\n    * C语言数据类型分为：简单类型、结构类型和地址类型。\n* **`sizeof` 运算符:**\n    * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。\n    * 示例：`sizeof(int)`, `sizeof(age)`。\n    * C语言保证的最小大小：`sizeof(char)` 为 1，`short` 至少16位，`long` 至少32位。\n* **整型 (Integral Types):**\n    * 用于表示整数，包括 `char`, `short`, `int`, `long`。\n    * **`char`:** 字符类型，用于表示单个字符。\n        * 字符在内存中以其 **ASCII** 码值（整数）存储。\n        * 字符常量用单引号 `' '` 括起来，如 `'B'`, `'4'`。\n        * **转义字符 (Escape character):** 特殊字符，如 `\\n` (换行), `\\t` (制表符), `\\\\` (反斜杠), `\\\"` (双引号)。\n    * **整型字面值:**\n        * 十进制 (Decimal): 正常书写，如 `16`, `498`。\n        * 八进制 (Octal): 以 `0` 开头，如 `022`。\n        * 十六进制 (Hexadecimal): 以 `0x` 或 `0X` 开头，如 `0xFF`。\n* **浮点型 (Floating Types):**\n    * 用于表示带小数点的实数，包括 `float`, `double`, `long double`。\n    * **科学计数法:** 使用 `E` 或 `e` 表示，如 `1.84E1` (即 1.84 x 10¹)。\n    * **默认类型:** 没有后缀的浮点常量（如 `94.6`）默认为 `double` 类型。\n    * **后缀:** `F` 或 `f` 表示 `float` (如 `94.6F`)；`L` 或 `l` 表示 `long double`。\n    * **精度:** 计算机不能精确表示所有浮点数。`double` 的精度高于或等于 `float`。\n* **布尔型 (`bool`):**\n    * C99标准引入，需要包含头文件 `<stdbool.h>`。\n    * 值只有 `true` (1) 或 `false` (0)。\n* **字符串型 (String):**\n    * 用双引号 `\" \"` 括起来的字符序列，如 `\"Hello\"`。\n    * **不是C的内置类型**，它本质上是一个 **字符数组 (char array)**。\n    * 以空字符 `\\0` 作为结尾标记。\n    * 字符串操作函数（如 `strlen`）定义在 `<string.h>` 头文件中。\n    * `\"a\"` (字符串) 与 `'a'` (字符) 是不同的。\n\n### 2.3 运算符与表达式\n* **表达式 (Expression):** 变量、常量和运算符的有效组合，可被求值以计算出一个值。\n* **算术运算符 (Arithmetic):**\n    * 一元：`+` (正), `-` (负)。\n    * 二元：`+`, `-`, `*`。\n    * **`/` (除法):**\n        * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。\n        * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。\n    * **`%` (模/取余):**\n        * 操作数 **只能是整数**。\n        * 结果是整数除法后的余数。\n        * 结果的符号由左操作数决定 (C语言中)。\n* **自增/自减运算符:**\n    * `++` (自增) 和 `--` (自减)。\n    * **前缀 (Prefix):** `++a`。先改变（加1或减1），再使用新值参与表达式运算。\n    * **后缀 (Postfix):** `a++`。先使用原值参与表达式运算，然后再改变（加1或减1）。\n* **赋值运算符 (Assignment):**\n    * `=` (赋值)。\n    * **复合赋值:** `+=`, `-=`, `*=`, `/=`。例如 `age += 3;` 等同于 `age = age + 3;`。\n* **关系运算符 (Relational):**\n    * `>`, `<`, `>=`, `<=`, `==` (等于), `!=` (不等于)。\n    * 结果为 `true` (非0) 或 `false` (0)。\n    * 注意：`=` (赋值) 和 `==` (等于) 是不同的。\n* **逻辑运算符 (Logical):**\n    * `!` (非), `&&` (与), `||` (或)。\n    * **短路求值 (Short-Circuit):**\n        * 对于 `&&`：如果左侧为 `false` (0)，则不再计算右侧。\n        * 对于 `||`：如果左侧为 `true` (非0)，则不再计算右侧。\n* **条件运算符 (Ternary):**\n    * C语言中唯一的三元运算符：`Expression1 ? Expression2 : Expression3`。\n    * 如果 `Expression1` 为 `true`，则整个表达式的值为 `Expression2`；否则为 `Expression3`。\n* **位运算符 (Bitwise):**\n    * 对操作数的二进制位进行操作。\n    * `&` (按位与), `|` (按位或), `^` (按位异或), `~` (按位非/取反)。\n    * `<<` (左移), `>>` (右移)。\n* **逗号运算符 (Comma):**\n    * `expression1, expression2`。\n    * 从左到右依次求值，整个表达式的值等于最后一个表达式 (`expression2`) 的值。\n    * 优先级是所有运算符中最低的。\n* **优先级 (Precedence) 与 结合性 (Associativity):**\n    * **优先级** 决定了哪个运算符先执行（如 `*` / `/` 优先于 `+` / `-`）。\n    * **结合性** 决定了同优先级运算符的执行顺序（如 `* / % + -` 都是左结合，从左到右）。\n    * 一元运算符、条件运算符、赋值运算符是 **右结合**（从右到左）。\n    * 可以使用 **圆括号 `()`** 来强制改变运算顺序。\n* **类型转换 (Type Conversion):**\n    * **隐式转换 (Coercion):** 编译器自动进行的类型转换。\n        * 发生在赋值时（如 `int i = 4.8;` i 变为 4）。\n        * 发生在混合类型表达式中。\n    * **类型提升 (Promotion):** 在表达式中，`char` 和 `short` 类型的值会自动提升为 `int`。\n    * **混合运算:** 较低类型会临时提升为较高类型（int -> long -> float -> double）。\n    * **显式转换 (Casting):** 程序员强制进行的类型转换。\n        * 语法：`(typename) expression`。\n        * 示例：`celsius = (5.0/9.0) * (fahr-32);`（对比 `5/9` 结果为0）。\n        * 浮点数转整数时，C99规定向0取整（截断小数）。\n\n## 第3章：控制结构\n\n### 3.1 选择结构\n* **`if` 语句 (单路选择):**\n    * 语法：`if ( Expression ) Statement`。\n    * 如果 `Expression` 为 `true` (非0)，则执行 `Statement`。\n* **`if-else` 语句 (双路选择):**\n    * 语法：`if ( Expression ) StatementA else StatementB`。\n    * 如果 `Expression` 为 `true`，执行 `StatementA`；否则执行 `StatementB`。\n* **`{}` 块的使用:**\n    * `if` 或 `else` 后面如果需要执行多条语句，必须使用花括号 `{}` 将它们括起来形成一个语句块。\n    * 如果省略 `{}`，`else` 会与最近的未配对的 `if` 结合（**悬垂else问题**）。\n* **`if-else if-else` 结构 (多路选择):**\n    * 用于实现多路分支。\n    * 按顺序测试每个 `Expression`，一旦找到为 `true` 的，就执行其后的 `Statement`，然后跳出整个结构。\n    * 如果所有 `if` 都不为 `true`，则执行最后的 `else` 块（如果存在）。\n* **`switch` 语句 (多路选择):**\n    * 语法：`switch ( IntegralExpression ) { ... }`。\n    * `IntegralExpression` 必须是整型（`char`, `int`, `long`, `enum`）。\n    * `case Constant:`：`Constant` 必须是常量表达式。\n    * **`break`:**\n        * 用于跳出 `switch` 语句。\n        * 如果省略 `break`，程序会 **穿透 (fall-through)** 并继续执行下一个 `case` 的语句。\n    * **`default`:**\n        * 可选。如果没有任何 `case` 匹配，则执行 `default` 块。\n* **测试:**\n    * 测试选择结构时，应确保每个分支至少被执行一次（**最小完全覆盖**）。\n\n### 3.2 循环结构\n* **循环 (Loop):** 一种重复执行某个语句块的控制结构。\n* **`while` 循环 (当型循环):**\n    * 语法：`while ( Expression ) { ...body... }`。\n    * **先测试 (Pre-test):** 在每次迭代 *之前* 检查 `Expression`。\n    * 如果 `Expression` 为 `false`，循环体可能一次也不执行。\n* **`do-while` 循环 (直到型循环):**\n    * 语法：`do { ...body... } while ( Expression );`。\n    * **后测试 (Post-test):** 在每次迭代 *之后* 检查 `Expression`。\n    * 循环体 **至少执行一次**。\n* **`for` 循环:**\n    * 语法：`for ( initialization ; test_expression ; update ) { ...body... }`。\n    * `initialization`：循环开始前执行一次（通常用于初始化循环变量）。\n    * `test_expression`：每次迭代前检查，若为 `false` 则退出循环。\n    * `update`：每次迭代 *之后* 执行（通常用于更新循环变量）。\n* **循环控制:**\n    * **`break`:** 立即 **跳出** 并终止其所在的最内层循环（或 `switch`）。\n    * **`continue`:** 立即 **跳过** 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 `for` 循环，会先执行 `update`）。\n    * **`goto` 和 `label`:**\n        * 提供从 `goto` 到同一函数内 `label` 的无条件跳转。\n        * 不推荐使用，但可用于跳出深度嵌套的结构。\n* **嵌套循环 (Nested Loop):**\n    * 一个循环体内包含另一个循环。\n    * `break` 或 `continue` 只影响最内层的循环。\n\n## 第4章：函数与程序结构\n\n### 4.1 函数基础\n* **函数 (Function):** 用于实现特定功能的一段程序代码。\n* **使用原因:** 避免代码重复、使程序结构化、提高可读性。\n* **函数声明 (Declaration / Prototype):**\n    * 告知编译器函数的返回类型、名称和参数类型。\n    * 语法：`type function_name(type arg1, type arg2, ...);`。\n    * 必须在使用函数前进行声明（通常放在 `main` 函数之前）。\n* **函数定义 (Definition):**\n    * 提供函数的具体实现（函数头 + 函数体）。\n    * **函数头 (Head):** `type function_name(type arg1, type arg2, ...)`。\n    * **函数体 (Body):** `{ ... your code ... }`。\n* **`return` 语句:**\n    * 用于从函数返回一个值。\n    * 函数最多只能返回 **1个** 值，该值的类型必须与声明的返回类型匹配。\n    * **`void` 函数:**\n        * 表示函数不返回值。\n        * 可以使用 `return;` 语句立即退出函数。\n* **函数调用 (Function Call):**\n    * 通过函数名和参数列表来执行函数。\n    * 程序控制权临时从调用函数转移到被调用函数。\n    * 被调用函数执行完毕后，控制权返回到调用点。\n\n### 4.2 参数传递\n* **形参 (Parameter / Formal Parameter):** 在函数 **定义** 或声明中指定的变量。\n* **实参 (Argument / Actual Parameter):** 在函数 **调用** 时传递给函数的具体值或变量。\n* **传递方式:**\n    1.  **值传递 (Pass by Value):**\n        * C语言的默认方式。\n        * 将实参的 **值复制** 一份传递给形参。\n        * 在函数内部修改形参 **不会** 影响到函数外部的实参。\n    2.  **地址/指针传递 (Pass by Address):**\n        * 将实参的 **地址** 传递给形参。\n        * 形参必须是 **指针类型** (如 `int *x`)。\n        * 实参必须是地址（如 `&a`）。\n        * 在函数内部通过指针修改形参所指向的内存，**会** 影响到函数外部的实参。\n    3.  **引用传递 (Pass by Reference):**\n        * 这是 C++ 的特性，**C语言不支持**。\n        * 形参是实参的别名（如 `int &x`）。\n\n### 4.3 作用域、生命周期与存储类型\n* **作用域 (Scope):** 标识符（变量或函数名）在程序中可以被合法使用的区域。\n    * **局部作用域 (Local Scope):** 标识符在块（`{}`内）或函数内部声明，其作用域从声明点到块或函数结束。\n    * **全局作用域 (Global Scope):** 标识符在所有函数之外声明，其作用域从声明点到文件结尾。\n    * **名称优先级:** 局部变量会“隐藏”同名的全局变量。\n* **生命周期 (Lifetime):** 程序执行期间，标识符实际拥有内存分配的时间。\n* **存储类型:**\n    * **自动变量 (Automatic):**\n        * 默认的局部变量存储类型（可省略 `auto` 关键字）。\n        * 存储在 **栈** 中。\n        * **生命周期:** 函数调用时创建，函数退出时销毁。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n    * **外部变量 (External):**\n        * 即全局变量，定义在所有函数之外。\n        * 使用 `extern` 关键字在其他文件中 **声明** （非定义），表示引用一个已在别处定义的全局变量。\n        * **生命周期:** 整个程序运行期间。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **静态变量 (Static):**\n        * 使用 `static` 关键字声明。\n        * **静态全局变量:** 作用域被限制在声明它的文件内部，其他文件不可访问。\n        * **静态局部变量:**\n            * 作用域仍是局部的（函数内）。\n            * **生命周期:** 整个程序运行期间。\n            * 只在 **第一次** 调用函数时初始化一次。\n            * 在函数多次调用之间 **保持其值**。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **寄存器变量 (Register):**\n        * 使用 `register` 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n\n### 4.4 递归\n* **递归 (Recursion):** 一个函数调用其自身的过程。\n* **递归的两个要素:**\n    1.  **基本情况 (Base Case):** 递归的停止条件，一个无需递归即可解决的简单情况。\n    2.  **递归步骤 (Recursive Step):** 将问题分解为更小的、同类的问题，并通过递归调用来解决。\n* **递归 vs. 迭代 (Iteration):**\n    * 任何递归都可以用迭代（循环）和栈来代替。\n    * 迭代（循环）在执行速度和空间占用上通常 **优于** 递归。\n\n### 4.5 C预处理器\n* 在编译之前对源代码进行处理的程序。\n* **文件包含 (`#include`):**\n    * `#include <filename>`: 在标准库目录或系统路径中查找文件。\n    * `#include \"filename\"`: 从源程序当前目录开始搜索（通常用于自定义头文件）。\n* **宏替换 (`#define`):**\n    * 定义一个宏（一个名称和一段替换文本）。\n    * 预处理器会在编译前进行 **原样文本替换**。\n    * **带参数的宏:** `define max(A,B) ((A) > (B) ? (A) : (B))`。\n    * **宏的陷阱:**\n        * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。\n        * 注意带副作用的参数，如 `max(i++, j++)`，会导致 `i` 或 `j` 被自增多次。\n* **条件包含 (`#if`...):**\n    * 允许根据预处理时的条件来选择性地编译某段代码。\n    * 指令包括：`#if`, `#elif`, `#else`, `#endif`。\n    * `#ifndef`: \"if not defined\"，常用于防止头文件被重复包含。\n\n## 第5章：数组\n\n### 5.1 一维数组\n* **数组 (Array):** 存储 **相同数据类型** 的元素的集合，这些元素在内存中 **连续存放**。\n* **数组声明:**\n    * 语法：`DataType ArrayName [ConstIntExpression];`。\n    * `ConstIntExpression` 必须是 **常量表达式**，指定数组的大小（元素个数）。\n    * 数组大小一旦固定，不可更改。\n* **数组元素访问:**\n    * 通过 **下标 (Index / Subscript)** 访问，下标从 **0** 开始。\n    * `temps[0]` 是第一个元素，`temps[4]` 是第五个元素（对于大小为5的数组）。\n* **数组名:**\n    * 数组名（如 `temps`）本身是一个 **指针**，其值是数组的 **基地址**（即第一个元素 `temps[0]` 的内存地址）。\n* **数组初始化:**\n    * 可以在声明时初始化：`int ages[5] = {40, 13, 20, 19, 36};`。\n    * 可以省略大小，编译器会自动计算：`int ages[] = {40, 13, 20};`。\n    * **部分初始化:** `int a[5] = { 2 };` 第一个元素为2，其余所有元素自动初始化为 0。\n* **数组的限制:**\n    * **无边界检查 (No Bound Checking):** C语言不检查数组下标是否越界。访问 `myList[-1]` 或 `myList[11]`（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。\n    * **无聚合操作 (No Aggregate Operations):** 不能将一个数组整体赋值给另一个数组（如 `x = y;` 是错误的）。\n    * 数组复制必须通过循环逐个元素进行。\n\n### 5.2 数组与函数\n* **数组作为函数参数:**\n    * 当数组作为参数传递时，传递的是数组的 **基地址**。\n    * 因此，函数参数传递总是 **地址传递**。\n    * 在函数内部对形参数组的修改 **会** 影响到主调函数中的实参数组。\n    * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。\n* **形参声明:**\n    * `float FindMax(float arr[], int n)`\n    * `float FindMax(float *arr, int n)` (等价)\n* **`const` 保护数组参数:**\n    * 如果不希望函数修改数组内容，应在形参声明中使用 `const` 关键字。\n    * 示例：`float FindMax(const float arr[], int n)`。\n\n### 5.3 数组算法：排序与搜索\n* **选择排序 (Selection Sort):**\n    * **算法思想:**\n        1.  从头（`passCount = 0`）开始。\n        2.  在 `data[passCount ... length-1]` 范围内找到 **最小** 元素的索引 `minIndx`。\n        3.  将 `data[minIndx]` 与 `data[passCount]` 交换。\n        4.  `passCount` 增加1，重复该过程，直到 `passCount` 达到 `length - 2`。\n* **线性搜索 (Linear / Sequential Search):**\n    * 适用于 **未排序** 的数组。\n    * 从头到尾（`i=0` 到 `n-1`）逐个检查元素，看是否等于目标值 `x`。\n    * 找到则返回索引 `i`，遍历完未找到则返回 `-1`。\n* **二分搜索 (Binary Search):**\n  C* **必须** 适用于 **已排序** 的数组。\n    * **算法思想:**\n        1.  设 `first = 0`, `last = arraySize - 1`。\n        2.  当 `last >= first` 时循环：\n        3.  计算中间索引 `mid = (first + last) / 2`。\n        4.  如果 `key == list[mid]`，则找到，返回 `mid`。\n        5.  如果 `key < list[mid]`，则目标在左半边，令 `last = mid - 1`。\n        6.  如果 `key > list[mid]`，则目标在右半边，令 `first = mid + 1`。\n        7.  循环结束仍未找到，返回 `-1`。\n\n### 5.4 多维数组\n* **二维数组 (Two-Dimensional Array):**\n    * 按行和列组织的同类型元素集合。\n    * **声明:** `DataType ArrayName [Rows] [Cols];`。\n    * **访问:** `stateHighs[2][7]` (访问第3行第8列的元素)。\n    * **内存存储:** 在内存中按 **行优先 (Row Order)** 连续存储（第一行所有元素，接着是第二行所有元素...）。\n* **多维数组作为函数参数:**\n    * 传递的仍然是基地址。\n    * **必须** 指定 **除第一维之外** 的所有维度的大小。\n    * 示例：`void FindAverages(const int stateHighs[][NUM_MONTHS], ...)`。\n* **`typedef` 与数组:**\n    * 可以使用 `typedef` 来定义数组类型，使函数原型更简洁明了。\n    * 示例：`typedef int SalesType[3][12][5];` `SalesType sales;`。\n","slug":"c-languange-midterm","published":1,"updated":"2025-11-16T07:59:14.085Z","comments":1,"layout":"post","photos":[],"_id":"cuiddnvVZx2OfPViH-V85wQJV","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>我发现好久好久没写博客了。<br>懒狗是这样的。<br>先传一点笔记吧。  </p>\n<hr>\n<h3><span id=\"%F0%9F%93%9A-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2\">📚 知识点大纲</span></h3><ol>\n<li><strong>第1章：程序设计与问题解决概述</strong><ul>\n<li>1.1 程序与程序设计</li>\n<li>1.2 问题解决的阶段</li>\n<li>1.3 编程语言的层次</li>\n<li>1.4 程序的编译与执行</li>\n<li>1.5 基本控制结构</li>\n<li>1.6 计算机基本组成</li>\n</ul>\n</li>\n<li><strong>第2章：C语言基础：类型、变量、常量与运算符</strong><ul>\n<li>2.1 标识符、变量与常量</li>\n<li>2.2 数据类型</li>\n<li>2.3 运算符与表达式</li>\n</ul>\n</li>\n<li><strong>第3章：控制结构</strong><ul>\n<li>3.1 选择结构</li>\n<li>3.2 循环结构</li>\n</ul>\n</li>\n<li><strong>第4章：函数与程序结构</strong><ul>\n<li>4.1 函数基础</li>\n<li>4.2 参数传递</li>\n<li>4.3 作用域、生命周期与存储类型</li>\n<li>4.4 递归</li>\n<li>4.5 C预处理器</li>\n</ul>\n</li>\n<li><strong>第5章：数组</strong><ul>\n<li>5.1 一维数组</li>\n<li>5.2 数组与函数</li>\n<li>5.3 数组算法：排序与搜索</li>\n<li>5.4 多维数组</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><span id=\"%F0%9F%93%96-%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86%E7%82%B9\">📖 详细知识点</span></h3><h2><span id=\"%E7%AC%AC1%E7%AB%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%A6%82%E8%BF%B0\">第1章：程序设计与问题解决概述</span></h2><h3><span id=\"11-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\">1.1 程序与程序设计</span></h3><ul>\n<li><strong>程序 (Program):</strong> 由计算机执行的一系列指令。</li>\n<li><strong>程序设计 (Programming):</strong> 为计算机规划一系列执行步骤的过程。</li>\n</ul>\n<h3><span id=\"12-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%9A%84%E9%98%B6%E6%AE%B5\">1.2 问题解决的阶段</span></h3><ol>\n<li>&nbsp;<strong>问题解决阶段:</strong><br>&nbsp; &nbsp; * 需求分析与规范。<br>&nbsp; &nbsp; * <strong>算法设计 (Algorithm):</strong> 在有限的时间内逐步解决问题的过程。</li>\n<li>&nbsp;<strong>实现阶段:</strong><br>&nbsp; &nbsp; * <strong>编码 (Coding):</strong> 将算法翻译成编程语言。<br>&nbsp; &nbsp; * 调试与测试。</li>\n<li>&nbsp;<strong>维护阶段:</strong><br>&nbsp; &nbsp; * 使用、修正错误、改进功能。</li>\n</ol>\n<h3><span id=\"13-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B1%82%E6%AC%A1\">1.3 编程语言的层次</span></h3><ul>\n<li><strong>机器语言 (Machine Language):</strong><br>&nbsp; &nbsp; * 由0和1组成的二进制编码指令。<br>&nbsp; &nbsp; * 计算机唯一可以直接理解和执行的语言。<br>&nbsp; &nbsp; * 不可移植，可读性差。</li>\n<li><strong>汇编语言 (Assembly Language):</strong><br>&nbsp; &nbsp; * 使用助记符（如 <code>LOAD</code>, <code>ADD</code>）来表示机器指令。<br>&nbsp; &nbsp; * 需要汇编器(Assembler)进行翻译。</li>\n<li><strong>高级语言 (High-level Language):</strong><br>&nbsp; &nbsp; * 语言类似自然语言，易于读、写和理解。<br>&nbsp; &nbsp; * 可移植性好。<br>&nbsp; &nbsp; * 示例：C, C++, Java, Python。</li>\n</ul>\n<h3><span id=\"14-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C\">1.4 程序的编译与执行</span></h3><ul>\n<li><strong>编译器 (Compiler):</strong><br>&nbsp; &nbsp; * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。<br>&nbsp; &nbsp; * 编译型语言执行速度通常更快，源码是私有的。<br>&nbsp; &nbsp; * 缺点是不跨平台（C, C++）。</li>\n<li><strong>解释器 (Interpreter):</strong><br>&nbsp; &nbsp; * 逐行解释并执行源代码。<br>&nbsp; &nbsp; * 解释型语言通常跨平台，易于调试。<br>&nbsp; &nbsp; * 缺点是执行速度较慢，源码是公开的（Python, PHP）。</li>\n<li><strong>C语言的编译执行流程:</strong><br>&nbsp; &nbsp; 1. &nbsp;<strong>源文件 (Source):</strong> 程序员编写的 <code>.c</code> 文件（如 <code>myprog.c</code>）。<br>&nbsp; &nbsp; 2. &nbsp;<strong>编译器 (Compiler):</strong> 将源文件翻译成机器语言的 <strong>目标文件 (Object)</strong>（如 <code>myprog.o</code>）。<br>&nbsp; &nbsp; 3. &nbsp;<strong>链接器 (Linker):</strong> 将目标文件与库函数等其他代码组合起来，生成 <strong>可执行文件 (Executable)</strong>（如 <code>myprog.exe</code>）。</li>\n</ul>\n<h3><span id=\"15-%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\">1.5 基本控制结构</span></h3><p>程序由四种基本的控制结构组成：</p>\n<ol>\n<li>&nbsp;<strong>顺序结构 (Sequence):</strong> 语句按顺序一条接一条地执行。</li>\n<li>&nbsp;<strong>选择结构 (Selection / Branch):</strong> 根据特定条件执行不同的语句（如 <code>if</code>, <code>switch</code>）。</li>\n<li>&nbsp;<strong>循环结构 (Loop / Repetition):</strong> 在满足特定条件时重复执行某些语句（如 <code>while</code>, <code>for</code>）。</li>\n<li>&nbsp;<strong>子程序 (Subprogram / Function):</strong> 将程序分解为更小的单元（函数）。</li>\n</ol>\n<h3><span id=\"16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90\">1.6 计算机基本组成</span></h3><ul>\n<li><strong>硬件 (Hardware):</strong><br>&nbsp; &nbsp; * <strong>中央处理单元 (CPU):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>算术逻辑单元 (ALU):</strong> 执行算术运算和逻辑比较。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>控制单元 (Control Unit):</strong> 控制程序指令的执行顺序。<br>&nbsp; &nbsp; * <strong>内存单元 (Memory Unit):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 有序的存储单元序列，每个单元有唯一地址。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 用于存放数据和程序指令。<br>&nbsp; &nbsp; * <strong>外围设备 (Peripherals):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 输入设备（如键盘、鼠标）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 输出设备（如显示器、打印机）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 辅助存储设备（如硬盘、CD-ROM）。</li>\n<li><strong>软件 (Software):</strong><br>&nbsp; &nbsp; * <strong>系统软件 (System Software):</strong> 如操作系统（OS），用于管理计算机资源。<br>&nbsp; &nbsp; * <strong>应用软件 (Application):</strong> 用户执行特定任务的程序。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC2%E7%AB%A0c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6\">第2章：C语言基础：类型、变量、常量与运算符</span></h2><h3><span id=\"21-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F\">2.1 标识符、变量与常量</span></h3><ul>\n<li><strong>变量 (Variable):</strong><br>&nbsp; &nbsp; * 程序中用于存放数据的容器（存储区域）。<br>&nbsp; &nbsp; * 变量名是内存位置的符号表示。<br>&nbsp; &nbsp; * 声明变量时必须指定其名称和数据类型。</li>\n<li><strong>标识符 (Identifier):</strong> (即变量名、函数名等)<br>&nbsp; &nbsp; * <strong>命名规则:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;只能包含字母（大小写）、数字和下划线 <code>_</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;必须以字母或下划线 <code>_</code> 开头（不能是数字）。<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。<br>&nbsp; &nbsp; * <strong>命名注意事项:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;应使用有意义的名称（如 <code>firstName</code> 而不是 <code>fn</code>）。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;<strong>区分大小写</strong> (如 <code>name</code> 和 <code>Name</code> 是不同的)。<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;<strong>不能</strong> 使用C语言的 <strong>关键字</strong> (Reserved words) 作为标识符。</li>\n<li><strong>常量 (Constant):</strong><br>&nbsp; &nbsp; * <strong>字面值常量 (Literal value):</strong> 直接写在代码中的值，如 <code>100</code>, <code>3.14</code>, <code>'A'</code>。<br>&nbsp; &nbsp; * <strong>命名常量 (Named constant):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;使用 <code>const</code> 修饰符：<code>const int VOTING_AGE = 18;</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;使用 <code>#define</code> 预处理指令：<code>#define VOTING_AGE 18</code>。<br>&nbsp; &nbsp; * 命名常量的值在程序执行期间不能被更改。</li>\n<li><strong>声明与赋值:</strong><br>&nbsp; &nbsp; * <strong>声明 (Declaration):</strong> 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。<br>&nbsp; &nbsp; * <strong>赋值 (Assignment):</strong> 使用赋值运算符 <code>=</code> 来给变量一个值。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 赋值语句的左侧必须是变量，右侧是值或表达式。</li>\n</ul>\n<h3><span id=\"22-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">2.2 数据类型</span></h3><ul>\n<li><strong>数据类型 (Data Type):</strong><br>&nbsp; &nbsp; * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。<br>&nbsp; &nbsp; * 每种数据类型需要不同大小的内存。<br>&nbsp; &nbsp; * C语言数据类型分为：简单类型、结构类型和地址类型。</li>\n<li><strong><code>sizeof</code> 运算符:</strong><br>&nbsp; &nbsp; * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。<br>&nbsp; &nbsp; * 示例：<code>sizeof(int)</code>, <code>sizeof(age)</code>。<br>&nbsp; &nbsp; * C语言保证的最小大小：<code>sizeof(char)</code> 为 1，<code>short</code> 至少16位，<code>long</code> 至少32位。</li>\n<li><strong>整型 (Integral Types):</strong><br>&nbsp; &nbsp; * 用于表示整数，包括 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>。<br>&nbsp; &nbsp; * <strong><code>char</code>:</strong> 字符类型，用于表示单个字符。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 字符在内存中以其 <strong>ASCII</strong> 码值（整数）存储。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 字符常量用单引号 <code>' '</code> 括起来，如 <code>'B'</code>, <code>'4'</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>转义字符 (Escape character):</strong> 特殊字符，如 <code>\\n</code> (换行), <code>\\t</code> (制表符), <code>\\\\</code> (反斜杠), <code>\\\"</code> (双引号)。<br>&nbsp; &nbsp; * <strong>整型字面值:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 十进制 (Decimal): 正常书写，如 <code>16</code>, <code>498</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 八进制 (Octal): 以 <code>0</code> 开头，如 <code>022</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 十六进制 (Hexadecimal): 以 <code>0x</code> 或 <code>0X</code> 开头，如 <code>0xFF</code>。</li>\n<li><strong>浮点型 (Floating Types):</strong><br>&nbsp; &nbsp; * 用于表示带小数点的实数，包括 <code>float</code>, <code>double</code>, <code>long double</code>。<br>&nbsp; &nbsp; * <strong>科学计数法:</strong> 使用 <code>E</code> 或 <code>e</code> 表示，如 <code>1.84E1</code> (即 1.84 x 10¹)。<br>&nbsp; &nbsp; * <strong>默认类型:</strong> 没有后缀的浮点常量（如 <code>94.6</code>）默认为 <code>double</code> 类型。<br>&nbsp; &nbsp; * <strong>后缀:</strong> <code>F</code> 或 <code>f</code> 表示 <code>float</code> (如 <code>94.6F</code>)；<code>L</code> 或 <code>l</code> 表示 <code>long double</code>。<br>&nbsp; &nbsp; * <strong>精度:</strong> 计算机不能精确表示所有浮点数。<code>double</code> 的精度高于或等于 <code>float</code>。</li>\n<li><strong>布尔型 (<code>bool</code>):</strong><br>&nbsp; &nbsp; * C99标准引入，需要包含头文件 <code>&lt;stdbool.h&gt;</code>。<br>&nbsp; &nbsp; * 值只有 <code>true</code> (1) 或 <code>false</code> (0)。</li>\n<li><strong>字符串型 (String):</strong><br>&nbsp; &nbsp; * 用双引号 <code>\" \"</code> 括起来的字符序列，如 <code>\"Hello\"</code>。<br>&nbsp; &nbsp; * <strong>不是C的内置类型</strong>，它本质上是一个 <strong>字符数组 (char array)</strong>。<br>&nbsp; &nbsp; * 以空字符 <code>\\0</code> 作为结尾标记。<br>&nbsp; &nbsp; * 字符串操作函数（如 <code>strlen</code>）定义在 <code>&lt;string.h&gt;</code> 头文件中。<br>&nbsp; &nbsp; * <code>\"a\"</code> (字符串) 与 <code>'a'</code> (字符) 是不同的。</li>\n</ul>\n<h3><span id=\"23-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\">2.3 运算符与表达式</span></h3><ul>\n<li><strong>表达式 (Expression):</strong> 变量、常量和运算符的有效组合，可被求值以计算出一个值。</li>\n<li><strong>算术运算符 (Arithmetic):</strong><br>&nbsp; &nbsp; * 一元：<code>+</code> (正), <code>-</code> (负)。<br>&nbsp; &nbsp; * 二元：<code>+</code>, <code>-</code>, <code>*</code>。<br>&nbsp; &nbsp; * <strong><code>/</code> (除法):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。<br>&nbsp; &nbsp; * <strong><code>%</code> (模/取余):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 操作数 <strong>只能是整数</strong>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 结果是整数除法后的余数。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 结果的符号由左操作数决定 (C语言中)。</li>\n<li><strong>自增/自减运算符:</strong><br>&nbsp; &nbsp; * <code>++</code> (自增) 和 <code>--</code> (自减)。<br>&nbsp; &nbsp; * <strong>前缀 (Prefix):</strong> <code>++a</code>。先改变（加1或减1），再使用新值参与表达式运算。<br>&nbsp; &nbsp; * <strong>后缀 (Postfix):</strong> <code>a++</code>。先使用原值参与表达式运算，然后再改变（加1或减1）。</li>\n<li><strong>赋值运算符 (Assignment):</strong><br>&nbsp; &nbsp; * <code>=</code> (赋值)。<br>&nbsp; &nbsp; * <strong>复合赋值:</strong> <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>。例如 <code>age += 3;</code> 等同于 <code>age = age + 3;</code>。</li>\n<li><strong>关系运算符 (Relational):</strong><br>&nbsp; &nbsp; * <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code> (等于), <code>!=</code> (不等于)。<br>&nbsp; &nbsp; * 结果为 <code>true</code> (非0) 或 <code>false</code> (0)。<br>&nbsp; &nbsp; * 注意：<code>=</code> (赋值) 和 <code>==</code> (等于) 是不同的。</li>\n<li><strong>逻辑运算符 (Logical):</strong><br>&nbsp; &nbsp; * <code>!</code> (非), <code>&amp;&amp;</code> (与), <code>||</code> (或)。<br>&nbsp; &nbsp; * <strong>短路求值 (Short-Circuit):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 对于 <code>&amp;&amp;</code>：如果左侧为 <code>false</code> (0)，则不再计算右侧。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 对于 <code>||</code>：如果左侧为 <code>true</code> (非0)，则不再计算右侧。</li>\n<li><strong>条件运算符 (Ternary):</strong><br>&nbsp; &nbsp; * C语言中唯一的三元运算符：<code>Expression1 ? Expression2 : Expression3</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression1</code> 为 <code>true</code>，则整个表达式的值为 <code>Expression2</code>；否则为 <code>Expression3</code>。</li>\n<li><strong>位运算符 (Bitwise):</strong><br>&nbsp; &nbsp; * 对操作数的二进制位进行操作。<br>&nbsp; &nbsp; * <code>&amp;</code> (按位与), <code>|</code> (按位或), <code>^</code> (按位异或), <code>~</code> (按位非/取反)。<br>&nbsp; &nbsp; * <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)。</li>\n<li><strong>逗号运算符 (Comma):</strong><br>&nbsp; &nbsp; * <code>expression1, expression2</code>。<br>&nbsp; &nbsp; * 从左到右依次求值，整个表达式的值等于最后一个表达式 (<code>expression2</code>) 的值。<br>&nbsp; &nbsp; * 优先级是所有运算符中最低的。</li>\n<li><strong>优先级 (Precedence) 与 结合性 (Associativity):</strong><br>&nbsp; &nbsp; * <strong>优先级</strong> 决定了哪个运算符先执行（如 <code>*</code> / <code>/</code> 优先于 <code>+</code> / <code>-</code>）。<br>&nbsp; &nbsp; * <strong>结合性</strong> 决定了同优先级运算符的执行顺序（如 <code>* / % + -</code> 都是左结合，从左到右）。<br>&nbsp; &nbsp; * 一元运算符、条件运算符、赋值运算符是 <strong>右结合</strong>（从右到左）。<br>&nbsp; &nbsp; * 可以使用 <strong>圆括号 <code>()</code></strong> 来强制改变运算顺序。</li>\n<li><strong>类型转换 (Type Conversion):</strong><br>&nbsp; &nbsp; * <strong>隐式转换 (Coercion):</strong> 编译器自动进行的类型转换。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 发生在赋值时（如 <code>int i = 4.8;</code> i 变为 4）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 发生在混合类型表达式中。<br>&nbsp; &nbsp; * <strong>类型提升 (Promotion):</strong> 在表达式中，<code>char</code> 和 <code>short</code> 类型的值会自动提升为 <code>int</code>。<br>&nbsp; &nbsp; * <strong>混合运算:</strong> 较低类型会临时提升为较高类型（int -&gt; long -&gt; float -&gt; double）。<br>&nbsp; &nbsp; * <strong>显式转换 (Casting):</strong> 程序员强制进行的类型转换。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 语法：<code>(typename) expression</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 示例：<code>celsius = (5.0/9.0) * (fahr-32);</code>（对比 <code>5/9</code> 结果为0）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 浮点数转整数时，C99规定向0取整（截断小数）。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC3%E7%AB%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\">第3章：控制结构</span></h2><h3><span id=\"31-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84\">3.1 选择结构</span></h3><ul>\n<li><strong><code>if</code> 语句 (单路选择):</strong><br>&nbsp; &nbsp; * 语法：<code>if ( Expression ) Statement</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression</code> 为 <code>true</code> (非0)，则执行 <code>Statement</code>。</li>\n<li><strong><code>if-else</code> 语句 (双路选择):</strong><br>&nbsp; &nbsp; * 语法：<code>if ( Expression ) StatementA else StatementB</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression</code> 为 <code>true</code>，执行 <code>StatementA</code>；否则执行 <code>StatementB</code>。</li>\n<li><strong><code>{}</code> 块的使用:</strong><br>&nbsp; &nbsp; * <code>if</code> 或 <code>else</code> 后面如果需要执行多条语句，必须使用花括号 <code>{}</code> 将它们括起来形成一个语句块。<br>&nbsp; &nbsp; * 如果省略 <code>{}</code>，<code>else</code> 会与最近的未配对的 <code>if</code> 结合（<strong>悬垂else问题</strong>）。</li>\n<li><strong><code>if-else if-else</code> 结构 (多路选择):</strong><br>&nbsp; &nbsp; * 用于实现多路分支。<br>&nbsp; &nbsp; * 按顺序测试每个 <code>Expression</code>，一旦找到为 <code>true</code> 的，就执行其后的 <code>Statement</code>，然后跳出整个结构。<br>&nbsp; &nbsp; * 如果所有 <code>if</code> 都不为 <code>true</code>，则执行最后的 <code>else</code> 块（如果存在）。</li>\n<li><strong><code>switch</code> 语句 (多路选择):</strong><br>&nbsp; &nbsp; * 语法：<code>switch ( IntegralExpression ) { ... }</code>。<br>&nbsp; &nbsp; * <code>IntegralExpression</code> 必须是整型（<code>char</code>, <code>int</code>, <code>long</code>, <code>enum</code>）。<br>&nbsp; &nbsp; * <code>case Constant:</code>：<code>Constant</code> 必须是常量表达式。<br>&nbsp; &nbsp; * <strong><code>break</code>:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 用于跳出 <code>switch</code> 语句。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 如果省略 <code>break</code>，程序会 <strong>穿透 (fall-through)</strong> 并继续执行下一个 <code>case</code> 的语句。<br>&nbsp; &nbsp; * <strong><code>default</code>:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 可选。如果没有任何 <code>case</code> 匹配，则执行 <code>default</code> 块。</li>\n<li><strong>测试:</strong><br>&nbsp; &nbsp; * 测试选择结构时，应确保每个分支至少被执行一次（<strong>最小完全覆盖</strong>）。</li>\n</ul>\n<h3><span id=\"32-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84\">3.2 循环结构</span></h3><ul>\n<li><strong>循环 (Loop):</strong> 一种重复执行某个语句块的控制结构。</li>\n<li><strong><code>while</code> 循环 (当型循环):</strong><br>&nbsp; &nbsp; * 语法：<code>while ( Expression ) { ...body... }</code>。<br>&nbsp; &nbsp; * <strong>先测试 (Pre-test):</strong> 在每次迭代 <em>之前</em> 检查 <code>Expression</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression</code> 为 <code>false</code>，循环体可能一次也不执行。</li>\n<li><strong><code>do-while</code> 循环 (直到型循环):</strong><br>&nbsp; &nbsp; * 语法：<code>do { ...body... } while ( Expression );</code>。<br>&nbsp; &nbsp; * <strong>后测试 (Post-test):</strong> 在每次迭代 <em>之后</em> 检查 <code>Expression</code>。<br>&nbsp; &nbsp; * 循环体 <strong>至少执行一次</strong>。</li>\n<li><strong><code>for</code> 循环:</strong><br>&nbsp; &nbsp; * 语法：<code>for ( initialization ; test_expression ; update ) { ...body... }</code>。<br>&nbsp; &nbsp; * <code>initialization</code>：循环开始前执行一次（通常用于初始化循环变量）。<br>&nbsp; &nbsp; * <code>test_expression</code>：每次迭代前检查，若为 <code>false</code> 则退出循环。<br>&nbsp; &nbsp; * <code>update</code>：每次迭代 <em>之后</em> 执行（通常用于更新循环变量）。</li>\n<li><strong>循环控制:</strong><br>&nbsp; &nbsp; * <strong><code>break</code>:</strong> 立即 <strong>跳出</strong> 并终止其所在的最内层循环（或 <code>switch</code>）。<br>&nbsp; &nbsp; * <strong><code>continue</code>:</strong> 立即 <strong>跳过</strong> 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 <code>for</code> 循环，会先执行 <code>update</code>）。<br>&nbsp; &nbsp; * <strong><code>goto</code> 和 <code>label</code>:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 提供从 <code>goto</code> 到同一函数内 <code>label</code> 的无条件跳转。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 不推荐使用，但可用于跳出深度嵌套的结构。</li>\n<li><strong>嵌套循环 (Nested Loop):</strong><br>&nbsp; &nbsp; * 一个循环体内包含另一个循环。<br>&nbsp; &nbsp; * <code>break</code> 或 <code>continue</code> 只影响最内层的循环。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC4%E7%AB%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84\">第4章：函数与程序结构</span></h2><h3><span id=\"41-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80\">4.1 函数基础</span></h3><ul>\n<li><strong>函数 (Function):</strong> 用于实现特定功能的一段程序代码。</li>\n<li><strong>使用原因:</strong> 避免代码重复、使程序结构化、提高可读性。</li>\n<li><strong>函数声明 (Declaration / Prototype):</strong><br>&nbsp; &nbsp; * 告知编译器函数的返回类型、名称和参数类型。<br>&nbsp; &nbsp; * 语法：<code>type function_name(type arg1, type arg2, ...);</code>。<br>&nbsp; &nbsp; * 必须在使用函数前进行声明（通常放在 <code>main</code> 函数之前）。</li>\n<li><strong>函数定义 (Definition):</strong><br>&nbsp; &nbsp; * 提供函数的具体实现（函数头 + 函数体）。<br>&nbsp; &nbsp; * <strong>函数头 (Head):</strong> <code>type function_name(type arg1, type arg2, ...)</code>。<br>&nbsp; &nbsp; * <strong>函数体 (Body):</strong> <code>{ ... your code ... }</code>。</li>\n<li><strong><code>return</code> 语句:</strong><br>&nbsp; &nbsp; * 用于从函数返回一个值。<br>&nbsp; &nbsp; * 函数最多只能返回 <strong>1个</strong> 值，该值的类型必须与声明的返回类型匹配。<br>&nbsp; &nbsp; * <strong><code>void</code> 函数:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 表示函数不返回值。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 可以使用 <code>return;</code> 语句立即退出函数。</li>\n<li><strong>函数调用 (Function Call):</strong><br>&nbsp; &nbsp; * 通过函数名和参数列表来执行函数。<br>&nbsp; &nbsp; * 程序控制权临时从调用函数转移到被调用函数。<br>&nbsp; &nbsp; * 被调用函数执行完毕后，控制权返回到调用点。</li>\n</ul>\n<h3><span id=\"42-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\">4.2 参数传递</span></h3><ul>\n<li><strong>形参 (Parameter / Formal Parameter):</strong> 在函数 <strong>定义</strong> 或声明中指定的变量。</li>\n<li><strong>实参 (Argument / Actual Parameter):</strong> 在函数 <strong>调用</strong> 时传递给函数的具体值或变量。</li>\n<li><strong>传递方式:</strong><br>&nbsp; &nbsp; 1. &nbsp;<strong>值传递 (Pass by Value):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * C语言的默认方式。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 将实参的 <strong>值复制</strong> 一份传递给形参。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 在函数内部修改形参 <strong>不会</strong> 影响到函数外部的实参。<br>&nbsp; &nbsp; 2. &nbsp;<strong>地址/指针传递 (Pass by Address):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 将实参的 <strong>地址</strong> 传递给形参。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 形参必须是 <strong>指针类型</strong> (如 <code>int *x</code>)。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 实参必须是地址（如 <code>&amp;a</code>）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 在函数内部通过指针修改形参所指向的内存，<strong>会</strong> 影响到函数外部的实参。<br>&nbsp; &nbsp; 3. &nbsp;<strong>引用传递 (Pass by Reference):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 这是 C++ 的特性，<strong>C语言不支持</strong>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 形参是实参的别名（如 <code>int &amp;x</code>）。</li>\n</ul>\n<h3><span id=\"43-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B\">4.3 作用域、生命周期与存储类型</span></h3><ul>\n<li><strong>作用域 (Scope):</strong> 标识符（变量或函数名）在程序中可以被合法使用的区域。<br>&nbsp; &nbsp; * <strong>局部作用域 (Local Scope):</strong> 标识符在块（<code>{}</code>内）或函数内部声明，其作用域从声明点到块或函数结束。<br>&nbsp; &nbsp; * <strong>全局作用域 (Global Scope):</strong> 标识符在所有函数之外声明，其作用域从声明点到文件结尾。<br>&nbsp; &nbsp; * <strong>名称优先级:</strong> 局部变量会“隐藏”同名的全局变量。</li>\n<li><strong>生命周期 (Lifetime):</strong> 程序执行期间，标识符实际拥有内存分配的时间。</li>\n<li><strong>存储类型:</strong><br>&nbsp; &nbsp; * <strong>自动变量 (Automatic):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 默认的局部变量存储类型（可省略 <code>auto</code> 关键字）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 存储在 <strong>栈</strong> 中。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>生命周期:</strong> 函数调用时创建，函数退出时销毁。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。<br>&nbsp; &nbsp; * <strong>外部变量 (External):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 即全局变量，定义在所有函数之外。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 使用 <code>extern</code> 关键字在其他文件中 <strong>声明</strong> （非定义），表示引用一个已在别处定义的全局变量。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>生命周期:</strong> 整个程序运行期间。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>&nbsp; &nbsp; * <strong>静态变量 (Static):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 使用 <code>static</code> 关键字声明。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>静态全局变量:</strong> 作用域被限制在声明它的文件内部，其他文件不可访问。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>静态局部变量:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 作用域仍是局部的（函数内）。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * <strong>生命周期:</strong> 整个程序运行期间。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 只在 <strong>第一次</strong> 调用函数时初始化一次。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 在函数多次调用之间 <strong>保持其值</strong>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>&nbsp; &nbsp; * <strong>寄存器变量 (Register):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 使用 <code>register</code> 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。</li>\n</ul>\n<h3><span id=\"44-%E9%80%92%E5%BD%92\">4.4 递归</span></h3><ul>\n<li><strong>递归 (Recursion):</strong> 一个函数调用其自身的过程。</li>\n<li><strong>递归的两个要素:</strong><br>&nbsp; &nbsp; 1. &nbsp;<strong>基本情况 (Base Case):</strong> 递归的停止条件，一个无需递归即可解决的简单情况。<br>&nbsp; &nbsp; 2. &nbsp;<strong>递归步骤 (Recursive Step):</strong> 将问题分解为更小的、同类的问题，并通过递归调用来解决。</li>\n<li><strong>递归 vs. 迭代 (Iteration):</strong><br>&nbsp; &nbsp; * 任何递归都可以用迭代（循环）和栈来代替。<br>&nbsp; &nbsp; * 迭代（循环）在执行速度和空间占用上通常 <strong>优于</strong> 递归。</li>\n</ul>\n<h3><span id=\"45-c%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\">4.5 C预处理器</span></h3><ul>\n<li>在编译之前对源代码进行处理的程序。</li>\n<li><strong>文件包含 (<code>#include</code>):</strong><br>&nbsp; &nbsp; * <code>#include &lt;filename&gt;</code>: 在标准库目录或系统路径中查找文件。<br>&nbsp; &nbsp; * <code>#include \"filename\"</code>: 从源程序当前目录开始搜索（通常用于自定义头文件）。</li>\n<li><strong>宏替换 (<code>#define</code>):</strong><br>&nbsp; &nbsp; * 定义一个宏（一个名称和一段替换文本）。<br>&nbsp; &nbsp; * 预处理器会在编译前进行 <strong>原样文本替换</strong>。<br>&nbsp; &nbsp; * <strong>带参数的宏:</strong> <code>define max(A,B) ((A) &gt; (B) ? (A) : (B))</code>。<br>&nbsp; &nbsp; * <strong>宏的陷阱:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 注意带副作用的参数，如 <code>max(i++, j++)</code>，会导致 <code>i</code> 或 <code>j</code> 被自增多次。</li>\n<li><strong>条件包含 (<code>#if</code>…):</strong><br>&nbsp; &nbsp; * 允许根据预处理时的条件来选择性地编译某段代码。<br>&nbsp; &nbsp; * 指令包括：<code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>。<br>&nbsp; &nbsp; * <code>#ifndef</code>: “if not defined”，常用于防止头文件被重复包含。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC5%E7%AB%A0%E6%95%B0%E7%BB%84\">第5章：数组</span></h2><h3><span id=\"51-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84\">5.1 一维数组</span></h3><ul>\n<li><strong>数组 (Array):</strong> 存储 <strong>相同数据类型</strong> 的元素的集合，这些元素在内存中 <strong>连续存放</strong>。</li>\n<li><strong>数组声明:</strong><br>&nbsp; &nbsp; * 语法：<code>DataType ArrayName [ConstIntExpression];</code>。<br>&nbsp; &nbsp; * <code>ConstIntExpression</code> 必须是 <strong>常量表达式</strong>，指定数组的大小（元素个数）。<br>&nbsp; &nbsp; * 数组大小一旦固定，不可更改。</li>\n<li><strong>数组元素访问:</strong><br>&nbsp; &nbsp; * 通过 <strong>下标 (Index / Subscript)</strong> 访问，下标从 <strong>0</strong> 开始。<br>&nbsp; &nbsp; * <code>temps[0]</code> 是第一个元素，<code>temps[4]</code> 是第五个元素（对于大小为5的数组）。</li>\n<li><strong>数组名:</strong><br>&nbsp; &nbsp; * 数组名（如 <code>temps</code>）本身是一个 <strong>指针</strong>，其值是数组的 <strong>基地址</strong>（即第一个元素 <code>temps[0]</code> 的内存地址）。</li>\n<li><strong>数组初始化:</strong><br>&nbsp; &nbsp; * 可以在声明时初始化：<code>int ages[5] = {40, 13, 20, 19, 36};</code>。<br>&nbsp; &nbsp; * 可以省略大小，编译器会自动计算：<code>int ages[] = {40, 13, 20};</code>。<br>&nbsp; &nbsp; * <strong>部分初始化:</strong> <code>int a[5] = { 2 };</code> 第一个元素为2，其余所有元素自动初始化为 0。</li>\n<li><strong>数组的限制:</strong><br>&nbsp; &nbsp; * <strong>无边界检查 (No Bound Checking):</strong> C语言不检查数组下标是否越界。访问 <code>myList[-1]</code> 或 <code>myList[11]</code>（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。<br>&nbsp; &nbsp; * <strong>无聚合操作 (No Aggregate Operations):</strong> 不能将一个数组整体赋值给另一个数组（如 <code>x = y;</code> 是错误的）。<br>&nbsp; &nbsp; * 数组复制必须通过循环逐个元素进行。</li>\n</ul>\n<h3><span id=\"52-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0\">5.2 数组与函数</span></h3><ul>\n<li><strong>数组作为函数参数:</strong><br>&nbsp; &nbsp; * 当数组作为参数传递时，传递的是数组的 <strong>基地址</strong>。<br>&nbsp; &nbsp; * 因此，函数参数传递总是 <strong>地址传递</strong>。<br>&nbsp; &nbsp; * 在函数内部对形参数组的修改 <strong>会</strong> 影响到主调函数中的实参数组。<br>&nbsp; &nbsp; * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。</li>\n<li><strong>形参声明:</strong><br>&nbsp; &nbsp; * <code>float FindMax(float arr[], int n)</code><br>&nbsp; &nbsp; * <code>float FindMax(float *arr, int n)</code> (等价)</li>\n<li><strong><code>const</code> 保护数组参数:</strong><br>&nbsp; &nbsp; * 如果不希望函数修改数组内容，应在形参声明中使用 <code>const</code> 关键字。<br>&nbsp; &nbsp; * 示例：<code>float FindMax(const float arr[], int n)</code>。</li>\n</ul>\n<h3><span id=\"53-%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2\">5.3 数组算法：排序与搜索</span></h3><ul>\n<li><strong>选择排序 (Selection Sort):</strong><br>&nbsp; &nbsp; * <strong>算法思想:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;从头（<code>passCount = 0</code>）开始。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;在 <code>data[passCount ... length-1]</code> 范围内找到 <strong>最小</strong> 元素的索引 <code>minIndx</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;将 <code>data[minIndx]</code> 与 <code>data[passCount]</code> 交换。<br>&nbsp; &nbsp; &nbsp; &nbsp; 4. &nbsp;<code>passCount</code> 增加1，重复该过程，直到 <code>passCount</code> 达到 <code>length - 2</code>。</li>\n<li><strong>线性搜索 (Linear / Sequential Search):</strong><br>&nbsp; &nbsp; * 适用于 <strong>未排序</strong> 的数组。<br>&nbsp; &nbsp; * 从头到尾（<code>i=0</code> 到 <code>n-1</code>）逐个检查元素，看是否等于目标值 <code>x</code>。<br>&nbsp; &nbsp; * 找到则返回索引 <code>i</code>，遍历完未找到则返回 <code>-1</code>。</li>\n<li><strong>二分搜索 (Binary Search):</strong><br>&nbsp; C* <strong>必须</strong> 适用于 <strong>已排序</strong> 的数组。<br>&nbsp; &nbsp; * <strong>算法思想:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;设 <code>first = 0</code>, <code>last = arraySize - 1</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;当 <code>last &gt;= first</code> 时循环：<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;计算中间索引 <code>mid = (first + last) / 2</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 4. &nbsp;如果 <code>key == list[mid]</code>，则找到，返回 <code>mid</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 5. &nbsp;如果 <code>key &lt; list[mid]</code>，则目标在左半边，令 <code>last = mid - 1</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 6. &nbsp;如果 <code>key &gt; list[mid]</code>，则目标在右半边，令 <code>first = mid + 1</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 7. &nbsp;循环结束仍未找到，返回 <code>-1</code>。</li>\n</ul>\n<h3><span id=\"54-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">5.4 多维数组</span></h3><ul>\n<li><strong>二维数组 (Two-Dimensional Array):</strong><br>&nbsp; &nbsp; * 按行和列组织的同类型元素集合。<br>&nbsp; &nbsp; * <strong>声明:</strong> <code>DataType ArrayName [Rows] [Cols];</code>。<br>&nbsp; &nbsp; * <strong>访问:</strong> <code>stateHighs[2][7]</code> (访问第3行第8列的元素)。<br>&nbsp; &nbsp; * <strong>内存存储:</strong> 在内存中按 <strong>行优先 (Row Order)</strong> 连续存储（第一行所有元素，接着是第二行所有元素…）。</li>\n<li><strong>多维数组作为函数参数:</strong><br>&nbsp; &nbsp; * 传递的仍然是基地址。<br>&nbsp; &nbsp; * <strong>必须</strong> 指定 <strong>除第一维之外</strong> 的所有维度的大小。<br>&nbsp; &nbsp; * 示例：<code>void FindAverages(const int stateHighs[][NUM_MONTHS], ...)</code>。</li>\n<li><strong><code>typedef</code> 与数组:</strong><br>&nbsp; &nbsp; * 可以使用 <code>typedef</code> 来定义数组类型，使函数原型更简洁明了。<br>&nbsp; &nbsp; * 示例：<code>typedef int SalesType[3][12][5];</code> <code>SalesType sales;</code>。</li>\n</ul>\n</body></html>","excerpt":"","more":"<p>我发现好久好久没写博客了。<br>懒狗是这样的。<br>先传一点笔记吧。  </p>\n<hr>\n<h3 id=\"📚-知识点大纲\"><a href=\"#📚-知识点大纲\" class=\"headerlink\" title=\"📚 知识点大纲\"></a>📚 知识点大纲</h3><ol>\n<li><strong>第1章：程序设计与问题解决概述</strong><ul>\n<li>1.1 程序与程序设计</li>\n<li>1.2 问题解决的阶段</li>\n<li>1.3 编程语言的层次</li>\n<li>1.4 程序的编译与执行</li>\n<li>1.5 基本控制结构</li>\n<li>1.6 计算机基本组成</li>\n</ul>\n</li>\n<li><strong>第2章：C语言基础：类型、变量、常量与运算符</strong><ul>\n<li>2.1 标识符、变量与常量</li>\n<li>2.2 数据类型</li>\n<li>2.3 运算符与表达式</li>\n</ul>\n</li>\n<li><strong>第3章：控制结构</strong><ul>\n<li>3.1 选择结构</li>\n<li>3.2 循环结构</li>\n</ul>\n</li>\n<li><strong>第4章：函数与程序结构</strong><ul>\n<li>4.1 函数基础</li>\n<li>4.2 参数传递</li>\n<li>4.3 作用域、生命周期与存储类型</li>\n<li>4.4 递归</li>\n<li>4.5 C预处理器</li>\n</ul>\n</li>\n<li><strong>第5章：数组</strong><ul>\n<li>5.1 一维数组</li>\n<li>5.2 数组与函数</li>\n<li>5.3 数组算法：排序与搜索</li>\n<li>5.4 多维数组</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"📖-详细知识点\"><a href=\"#📖-详细知识点\" class=\"headerlink\" title=\"📖 详细知识点\"></a>📖 详细知识点</h3><h2 id=\"第1章：程序设计与问题解决概述\"><a href=\"#第1章：程序设计与问题解决概述\" class=\"headerlink\" title=\"第1章：程序设计与问题解决概述\"></a>第1章：程序设计与问题解决概述</h2><h3 id=\"1-1-程序与程序设计\"><a href=\"#1-1-程序与程序设计\" class=\"headerlink\" title=\"1.1 程序与程序设计\"></a>1.1 程序与程序设计</h3><ul>\n<li><strong>程序 (Program):</strong> 由计算机执行的一系列指令。</li>\n<li><strong>程序设计 (Programming):</strong> 为计算机规划一系列执行步骤的过程。</li>\n</ul>\n<h3 id=\"1-2-问题解决的阶段\"><a href=\"#1-2-问题解决的阶段\" class=\"headerlink\" title=\"1.2 问题解决的阶段\"></a>1.2 问题解决的阶段</h3><ol>\n<li> <strong>问题解决阶段:</strong><br>    * 需求分析与规范。<br>    * <strong>算法设计 (Algorithm):</strong> 在有限的时间内逐步解决问题的过程。</li>\n<li> <strong>实现阶段:</strong><br>    * <strong>编码 (Coding):</strong> 将算法翻译成编程语言。<br>    * 调试与测试。</li>\n<li> <strong>维护阶段:</strong><br>    * 使用、修正错误、改进功能。</li>\n</ol>\n<h3 id=\"1-3-编程语言的层次\"><a href=\"#1-3-编程语言的层次\" class=\"headerlink\" title=\"1.3 编程语言的层次\"></a>1.3 编程语言的层次</h3><ul>\n<li><strong>机器语言 (Machine Language):</strong><br>    * 由0和1组成的二进制编码指令。<br>    * 计算机唯一可以直接理解和执行的语言。<br>    * 不可移植，可读性差。</li>\n<li><strong>汇编语言 (Assembly Language):</strong><br>    * 使用助记符（如 <code>LOAD</code>, <code>ADD</code>）来表示机器指令。<br>    * 需要汇编器(Assembler)进行翻译。</li>\n<li><strong>高级语言 (High-level Language):</strong><br>    * 语言类似自然语言，易于读、写和理解。<br>    * 可移植性好。<br>    * 示例：C, C++, Java, Python。</li>\n</ul>\n<h3 id=\"1-4-程序的编译与执行\"><a href=\"#1-4-程序的编译与执行\" class=\"headerlink\" title=\"1.4 程序的编译与执行\"></a>1.4 程序的编译与执行</h3><ul>\n<li><strong>编译器 (Compiler):</strong><br>    * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。<br>    * 编译型语言执行速度通常更快，源码是私有的。<br>    * 缺点是不跨平台（C, C++）。</li>\n<li><strong>解释器 (Interpreter):</strong><br>    * 逐行解释并执行源代码。<br>    * 解释型语言通常跨平台，易于调试。<br>    * 缺点是执行速度较慢，源码是公开的（Python, PHP）。</li>\n<li><strong>C语言的编译执行流程:</strong><br>    1.  <strong>源文件 (Source):</strong> 程序员编写的 <code>.c</code> 文件（如 <code>myprog.c</code>）。<br>    2.  <strong>编译器 (Compiler):</strong> 将源文件翻译成机器语言的 <strong>目标文件 (Object)</strong>（如 <code>myprog.o</code>）。<br>    3.  <strong>链接器 (Linker):</strong> 将目标文件与库函数等其他代码组合起来，生成 <strong>可执行文件 (Executable)</strong>（如 <code>myprog.exe</code>）。</li>\n</ul>\n<h3 id=\"1-5-基本控制结构\"><a href=\"#1-5-基本控制结构\" class=\"headerlink\" title=\"1.5 基本控制结构\"></a>1.5 基本控制结构</h3><p>程序由四种基本的控制结构组成：</p>\n<ol>\n<li> <strong>顺序结构 (Sequence):</strong> 语句按顺序一条接一条地执行。</li>\n<li> <strong>选择结构 (Selection &#x2F; Branch):</strong> 根据特定条件执行不同的语句（如 <code>if</code>, <code>switch</code>）。</li>\n<li> <strong>循环结构 (Loop &#x2F; Repetition):</strong> 在满足特定条件时重复执行某些语句（如 <code>while</code>, <code>for</code>）。</li>\n<li> <strong>子程序 (Subprogram &#x2F; Function):</strong> 将程序分解为更小的单元（函数）。</li>\n</ol>\n<h3 id=\"1-6-计算机基本组成\"><a href=\"#1-6-计算机基本组成\" class=\"headerlink\" title=\"1.6 计算机基本组成\"></a>1.6 计算机基本组成</h3><ul>\n<li><strong>硬件 (Hardware):</strong><br>    * <strong>中央处理单元 (CPU):</strong><br>        * <strong>算术逻辑单元 (ALU):</strong> 执行算术运算和逻辑比较。<br>        * <strong>控制单元 (Control Unit):</strong> 控制程序指令的执行顺序。<br>    * <strong>内存单元 (Memory Unit):</strong><br>        * 有序的存储单元序列，每个单元有唯一地址。<br>        * 用于存放数据和程序指令。<br>    * <strong>外围设备 (Peripherals):</strong><br>        * 输入设备（如键盘、鼠标）。<br>        * 输出设备（如显示器、打印机）。<br>        * 辅助存储设备（如硬盘、CD-ROM）。</li>\n<li><strong>软件 (Software):</strong><br>    * <strong>系统软件 (System Software):</strong> 如操作系统（OS），用于管理计算机资源。<br>    * <strong>应用软件 (Application):</strong> 用户执行特定任务的程序。</li>\n</ul>\n<h2 id=\"第2章：C语言基础：类型、变量、常量与运算符\"><a href=\"#第2章：C语言基础：类型、变量、常量与运算符\" class=\"headerlink\" title=\"第2章：C语言基础：类型、变量、常量与运算符\"></a>第2章：C语言基础：类型、变量、常量与运算符</h2><h3 id=\"2-1-标识符、变量与常量\"><a href=\"#2-1-标识符、变量与常量\" class=\"headerlink\" title=\"2.1 标识符、变量与常量\"></a>2.1 标识符、变量与常量</h3><ul>\n<li><strong>变量 (Variable):</strong><br>    * 程序中用于存放数据的容器（存储区域）。<br>    * 变量名是内存位置的符号表示。<br>    * 声明变量时必须指定其名称和数据类型。</li>\n<li><strong>标识符 (Identifier):</strong> (即变量名、函数名等)<br>    * <strong>命名规则:</strong><br>        1.  只能包含字母（大小写）、数字和下划线 <code>_</code>。<br>        2.  必须以字母或下划线 <code>_</code> 开头（不能是数字）。<br>        3.  长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。<br>    * <strong>命名注意事项:</strong><br>        1.  应使用有意义的名称（如 <code>firstName</code> 而不是 <code>fn</code>）。<br>        2.  <strong>区分大小写</strong> (如 <code>name</code> 和 <code>Name</code> 是不同的)。<br>        3.  <strong>不能</strong> 使用C语言的 <strong>关键字</strong> (Reserved words) 作为标识符。</li>\n<li><strong>常量 (Constant):</strong><br>    * <strong>字面值常量 (Literal value):</strong> 直接写在代码中的值，如 <code>100</code>, <code>3.14</code>, <code>&#39;A&#39;</code>。<br>    * <strong>命名常量 (Named constant):</strong><br>        1.  使用 <code>const</code> 修饰符：<code>const int VOTING_AGE = 18;</code>。<br>        2.  使用 <code>#define</code> 预处理指令：<code>#define VOTING_AGE 18</code>。<br>    * 命名常量的值在程序执行期间不能被更改。</li>\n<li><strong>声明与赋值:</strong><br>    * <strong>声明 (Declaration):</strong> 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。<br>    * <strong>赋值 (Assignment):</strong> 使用赋值运算符 <code>=</code> 来给变量一个值。<br>        * 赋值语句的左侧必须是变量，右侧是值或表达式。</li>\n</ul>\n<h3 id=\"2-2-数据类型\"><a href=\"#2-2-数据类型\" class=\"headerlink\" title=\"2.2 数据类型\"></a>2.2 数据类型</h3><ul>\n<li><strong>数据类型 (Data Type):</strong><br>    * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。<br>    * 每种数据类型需要不同大小的内存。<br>    * C语言数据类型分为：简单类型、结构类型和地址类型。</li>\n<li><strong><code>sizeof</code> 运算符:</strong><br>    * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。<br>    * 示例：<code>sizeof(int)</code>, <code>sizeof(age)</code>。<br>    * C语言保证的最小大小：<code>sizeof(char)</code> 为 1，<code>short</code> 至少16位，<code>long</code> 至少32位。</li>\n<li><strong>整型 (Integral Types):</strong><br>    * 用于表示整数，包括 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>。<br>    * <strong><code>char</code>:</strong> 字符类型，用于表示单个字符。<br>        * 字符在内存中以其 <strong>ASCII</strong> 码值（整数）存储。<br>        * 字符常量用单引号 <code>&#39; &#39;</code> 括起来，如 <code>&#39;B&#39;</code>, <code>&#39;4&#39;</code>。<br>        * <strong>转义字符 (Escape character):</strong> 特殊字符，如 <code>\\n</code> (换行), <code>\\t</code> (制表符), <code>\\\\</code> (反斜杠), <code>\\&quot;</code> (双引号)。<br>    * <strong>整型字面值:</strong><br>        * 十进制 (Decimal): 正常书写，如 <code>16</code>, <code>498</code>。<br>        * 八进制 (Octal): 以 <code>0</code> 开头，如 <code>022</code>。<br>        * 十六进制 (Hexadecimal): 以 <code>0x</code> 或 <code>0X</code> 开头，如 <code>0xFF</code>。</li>\n<li><strong>浮点型 (Floating Types):</strong><br>    * 用于表示带小数点的实数，包括 <code>float</code>, <code>double</code>, <code>long double</code>。<br>    * <strong>科学计数法:</strong> 使用 <code>E</code> 或 <code>e</code> 表示，如 <code>1.84E1</code> (即 1.84 x 10¹)。<br>    * <strong>默认类型:</strong> 没有后缀的浮点常量（如 <code>94.6</code>）默认为 <code>double</code> 类型。<br>    * <strong>后缀:</strong> <code>F</code> 或 <code>f</code> 表示 <code>float</code> (如 <code>94.6F</code>)；<code>L</code> 或 <code>l</code> 表示 <code>long double</code>。<br>    * <strong>精度:</strong> 计算机不能精确表示所有浮点数。<code>double</code> 的精度高于或等于 <code>float</code>。</li>\n<li><strong>布尔型 (<code>bool</code>):</strong><br>    * C99标准引入，需要包含头文件 <code>&lt;stdbool.h&gt;</code>。<br>    * 值只有 <code>true</code> (1) 或 <code>false</code> (0)。</li>\n<li><strong>字符串型 (String):</strong><br>    * 用双引号 <code>&quot; &quot;</code> 括起来的字符序列，如 <code>&quot;Hello&quot;</code>。<br>    * <strong>不是C的内置类型</strong>，它本质上是一个 <strong>字符数组 (char array)</strong>。<br>    * 以空字符 <code>\\0</code> 作为结尾标记。<br>    * 字符串操作函数（如 <code>strlen</code>）定义在 <code>&lt;string.h&gt;</code> 头文件中。<br>    * <code>&quot;a&quot;</code> (字符串) 与 <code>&#39;a&#39;</code> (字符) 是不同的。</li>\n</ul>\n<h3 id=\"2-3-运算符与表达式\"><a href=\"#2-3-运算符与表达式\" class=\"headerlink\" title=\"2.3 运算符与表达式\"></a>2.3 运算符与表达式</h3><ul>\n<li><strong>表达式 (Expression):</strong> 变量、常量和运算符的有效组合，可被求值以计算出一个值。</li>\n<li><strong>算术运算符 (Arithmetic):</strong><br>    * 一元：<code>+</code> (正), <code>-</code> (负)。<br>    * 二元：<code>+</code>, <code>-</code>, <code>*</code>。<br>    * <strong><code>/</code> (除法):</strong><br>        * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。<br>        * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。<br>    * <strong><code>%</code> (模&#x2F;取余):</strong><br>        * 操作数 <strong>只能是整数</strong>。<br>        * 结果是整数除法后的余数。<br>        * 结果的符号由左操作数决定 (C语言中)。</li>\n<li><strong>自增&#x2F;自减运算符:</strong><br>    * <code>++</code> (自增) 和 <code>--</code> (自减)。<br>    * <strong>前缀 (Prefix):</strong> <code>++a</code>。先改变（加1或减1），再使用新值参与表达式运算。<br>    * <strong>后缀 (Postfix):</strong> <code>a++</code>。先使用原值参与表达式运算，然后再改变（加1或减1）。</li>\n<li><strong>赋值运算符 (Assignment):</strong><br>    * <code>=</code> (赋值)。<br>    * <strong>复合赋值:</strong> <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>。例如 <code>age += 3;</code> 等同于 <code>age = age + 3;</code>。</li>\n<li><strong>关系运算符 (Relational):</strong><br>    * <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code> (等于), <code>!=</code> (不等于)。<br>    * 结果为 <code>true</code> (非0) 或 <code>false</code> (0)。<br>    * 注意：<code>=</code> (赋值) 和 <code>==</code> (等于) 是不同的。</li>\n<li><strong>逻辑运算符 (Logical):</strong><br>    * <code>!</code> (非), <code>&amp;&amp;</code> (与), <code>||</code> (或)。<br>    * <strong>短路求值 (Short-Circuit):</strong><br>        * 对于 <code>&amp;&amp;</code>：如果左侧为 <code>false</code> (0)，则不再计算右侧。<br>        * 对于 <code>||</code>：如果左侧为 <code>true</code> (非0)，则不再计算右侧。</li>\n<li><strong>条件运算符 (Ternary):</strong><br>    * C语言中唯一的三元运算符：<code>Expression1 ? Expression2 : Expression3</code>。<br>    * 如果 <code>Expression1</code> 为 <code>true</code>，则整个表达式的值为 <code>Expression2</code>；否则为 <code>Expression3</code>。</li>\n<li><strong>位运算符 (Bitwise):</strong><br>    * 对操作数的二进制位进行操作。<br>    * <code>&amp;</code> (按位与), <code>|</code> (按位或), <code>^</code> (按位异或), <code>~</code> (按位非&#x2F;取反)。<br>    * <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)。</li>\n<li><strong>逗号运算符 (Comma):</strong><br>    * <code>expression1, expression2</code>。<br>    * 从左到右依次求值，整个表达式的值等于最后一个表达式 (<code>expression2</code>) 的值。<br>    * 优先级是所有运算符中最低的。</li>\n<li><strong>优先级 (Precedence) 与 结合性 (Associativity):</strong><br>    * <strong>优先级</strong> 决定了哪个运算符先执行（如 <code>*</code> &#x2F; <code>/</code> 优先于 <code>+</code> &#x2F; <code>-</code>）。<br>    * <strong>结合性</strong> 决定了同优先级运算符的执行顺序（如 <code>* / % + -</code> 都是左结合，从左到右）。<br>    * 一元运算符、条件运算符、赋值运算符是 <strong>右结合</strong>（从右到左）。<br>    * 可以使用 <strong>圆括号 <code>()</code></strong> 来强制改变运算顺序。</li>\n<li><strong>类型转换 (Type Conversion):</strong><br>    * <strong>隐式转换 (Coercion):</strong> 编译器自动进行的类型转换。<br>        * 发生在赋值时（如 <code>int i = 4.8;</code> i 变为 4）。<br>        * 发生在混合类型表达式中。<br>    * <strong>类型提升 (Promotion):</strong> 在表达式中，<code>char</code> 和 <code>short</code> 类型的值会自动提升为 <code>int</code>。<br>    * <strong>混合运算:</strong> 较低类型会临时提升为较高类型（int -&gt; long -&gt; float -&gt; double）。<br>    * <strong>显式转换 (Casting):</strong> 程序员强制进行的类型转换。<br>        * 语法：<code>(typename) expression</code>。<br>        * 示例：<code>celsius = (5.0/9.0) * (fahr-32);</code>（对比 <code>5/9</code> 结果为0）。<br>        * 浮点数转整数时，C99规定向0取整（截断小数）。</li>\n</ul>\n<h2 id=\"第3章：控制结构\"><a href=\"#第3章：控制结构\" class=\"headerlink\" title=\"第3章：控制结构\"></a>第3章：控制结构</h2><h3 id=\"3-1-选择结构\"><a href=\"#3-1-选择结构\" class=\"headerlink\" title=\"3.1 选择结构\"></a>3.1 选择结构</h3><ul>\n<li><strong><code>if</code> 语句 (单路选择):</strong><br>    * 语法：<code>if ( Expression ) Statement</code>。<br>    * 如果 <code>Expression</code> 为 <code>true</code> (非0)，则执行 <code>Statement</code>。</li>\n<li><strong><code>if-else</code> 语句 (双路选择):</strong><br>    * 语法：<code>if ( Expression ) StatementA else StatementB</code>。<br>    * 如果 <code>Expression</code> 为 <code>true</code>，执行 <code>StatementA</code>；否则执行 <code>StatementB</code>。</li>\n<li><strong><code>{}</code> 块的使用:</strong><br>    * <code>if</code> 或 <code>else</code> 后面如果需要执行多条语句，必须使用花括号 <code>{}</code> 将它们括起来形成一个语句块。<br>    * 如果省略 <code>{}</code>，<code>else</code> 会与最近的未配对的 <code>if</code> 结合（<strong>悬垂else问题</strong>）。</li>\n<li><strong><code>if-else if-else</code> 结构 (多路选择):</strong><br>    * 用于实现多路分支。<br>    * 按顺序测试每个 <code>Expression</code>，一旦找到为 <code>true</code> 的，就执行其后的 <code>Statement</code>，然后跳出整个结构。<br>    * 如果所有 <code>if</code> 都不为 <code>true</code>，则执行最后的 <code>else</code> 块（如果存在）。</li>\n<li><strong><code>switch</code> 语句 (多路选择):</strong><br>    * 语法：<code>switch ( IntegralExpression ) { ... }</code>。<br>    * <code>IntegralExpression</code> 必须是整型（<code>char</code>, <code>int</code>, <code>long</code>, <code>enum</code>）。<br>    * <code>case Constant:</code>：<code>Constant</code> 必须是常量表达式。<br>    * <strong><code>break</code>:</strong><br>        * 用于跳出 <code>switch</code> 语句。<br>        * 如果省略 <code>break</code>，程序会 <strong>穿透 (fall-through)</strong> 并继续执行下一个 <code>case</code> 的语句。<br>    * <strong><code>default</code>:</strong><br>        * 可选。如果没有任何 <code>case</code> 匹配，则执行 <code>default</code> 块。</li>\n<li><strong>测试:</strong><br>    * 测试选择结构时，应确保每个分支至少被执行一次（<strong>最小完全覆盖</strong>）。</li>\n</ul>\n<h3 id=\"3-2-循环结构\"><a href=\"#3-2-循环结构\" class=\"headerlink\" title=\"3.2 循环结构\"></a>3.2 循环结构</h3><ul>\n<li><strong>循环 (Loop):</strong> 一种重复执行某个语句块的控制结构。</li>\n<li><strong><code>while</code> 循环 (当型循环):</strong><br>    * 语法：<code>while ( Expression ) { ...body... }</code>。<br>    * <strong>先测试 (Pre-test):</strong> 在每次迭代 <em>之前</em> 检查 <code>Expression</code>。<br>    * 如果 <code>Expression</code> 为 <code>false</code>，循环体可能一次也不执行。</li>\n<li><strong><code>do-while</code> 循环 (直到型循环):</strong><br>    * 语法：<code>do { ...body... } while ( Expression );</code>。<br>    * <strong>后测试 (Post-test):</strong> 在每次迭代 <em>之后</em> 检查 <code>Expression</code>。<br>    * 循环体 <strong>至少执行一次</strong>。</li>\n<li><strong><code>for</code> 循环:</strong><br>    * 语法：<code>for ( initialization ; test_expression ; update ) { ...body... }</code>。<br>    * <code>initialization</code>：循环开始前执行一次（通常用于初始化循环变量）。<br>    * <code>test_expression</code>：每次迭代前检查，若为 <code>false</code> 则退出循环。<br>    * <code>update</code>：每次迭代 <em>之后</em> 执行（通常用于更新循环变量）。</li>\n<li><strong>循环控制:</strong><br>    * <strong><code>break</code>:</strong> 立即 <strong>跳出</strong> 并终止其所在的最内层循环（或 <code>switch</code>）。<br>    * <strong><code>continue</code>:</strong> 立即 <strong>跳过</strong> 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 <code>for</code> 循环，会先执行 <code>update</code>）。<br>    * <strong><code>goto</code> 和 <code>label</code>:</strong><br>        * 提供从 <code>goto</code> 到同一函数内 <code>label</code> 的无条件跳转。<br>        * 不推荐使用，但可用于跳出深度嵌套的结构。</li>\n<li><strong>嵌套循环 (Nested Loop):</strong><br>    * 一个循环体内包含另一个循环。<br>    * <code>break</code> 或 <code>continue</code> 只影响最内层的循环。</li>\n</ul>\n<h2 id=\"第4章：函数与程序结构\"><a href=\"#第4章：函数与程序结构\" class=\"headerlink\" title=\"第4章：函数与程序结构\"></a>第4章：函数与程序结构</h2><h3 id=\"4-1-函数基础\"><a href=\"#4-1-函数基础\" class=\"headerlink\" title=\"4.1 函数基础\"></a>4.1 函数基础</h3><ul>\n<li><strong>函数 (Function):</strong> 用于实现特定功能的一段程序代码。</li>\n<li><strong>使用原因:</strong> 避免代码重复、使程序结构化、提高可读性。</li>\n<li><strong>函数声明 (Declaration &#x2F; Prototype):</strong><br>    * 告知编译器函数的返回类型、名称和参数类型。<br>    * 语法：<code>type function_name(type arg1, type arg2, ...);</code>。<br>    * 必须在使用函数前进行声明（通常放在 <code>main</code> 函数之前）。</li>\n<li><strong>函数定义 (Definition):</strong><br>    * 提供函数的具体实现（函数头 + 函数体）。<br>    * <strong>函数头 (Head):</strong> <code>type function_name(type arg1, type arg2, ...)</code>。<br>    * <strong>函数体 (Body):</strong> <code>{ ... your code ... }</code>。</li>\n<li><strong><code>return</code> 语句:</strong><br>    * 用于从函数返回一个值。<br>    * 函数最多只能返回 <strong>1个</strong> 值，该值的类型必须与声明的返回类型匹配。<br>    * <strong><code>void</code> 函数:</strong><br>        * 表示函数不返回值。<br>        * 可以使用 <code>return;</code> 语句立即退出函数。</li>\n<li><strong>函数调用 (Function Call):</strong><br>    * 通过函数名和参数列表来执行函数。<br>    * 程序控制权临时从调用函数转移到被调用函数。<br>    * 被调用函数执行完毕后，控制权返回到调用点。</li>\n</ul>\n<h3 id=\"4-2-参数传递\"><a href=\"#4-2-参数传递\" class=\"headerlink\" title=\"4.2 参数传递\"></a>4.2 参数传递</h3><ul>\n<li><strong>形参 (Parameter &#x2F; Formal Parameter):</strong> 在函数 <strong>定义</strong> 或声明中指定的变量。</li>\n<li><strong>实参 (Argument &#x2F; Actual Parameter):</strong> 在函数 <strong>调用</strong> 时传递给函数的具体值或变量。</li>\n<li><strong>传递方式:</strong><br>    1.  <strong>值传递 (Pass by Value):</strong><br>        * C语言的默认方式。<br>        * 将实参的 <strong>值复制</strong> 一份传递给形参。<br>        * 在函数内部修改形参 <strong>不会</strong> 影响到函数外部的实参。<br>    2.  <strong>地址&#x2F;指针传递 (Pass by Address):</strong><br>        * 将实参的 <strong>地址</strong> 传递给形参。<br>        * 形参必须是 <strong>指针类型</strong> (如 <code>int *x</code>)。<br>        * 实参必须是地址（如 <code>&amp;a</code>）。<br>        * 在函数内部通过指针修改形参所指向的内存，<strong>会</strong> 影响到函数外部的实参。<br>    3.  <strong>引用传递 (Pass by Reference):</strong><br>        * 这是 C++ 的特性，<strong>C语言不支持</strong>。<br>        * 形参是实参的别名（如 <code>int &amp;x</code>）。</li>\n</ul>\n<h3 id=\"4-3-作用域、生命周期与存储类型\"><a href=\"#4-3-作用域、生命周期与存储类型\" class=\"headerlink\" title=\"4.3 作用域、生命周期与存储类型\"></a>4.3 作用域、生命周期与存储类型</h3><ul>\n<li><strong>作用域 (Scope):</strong> 标识符（变量或函数名）在程序中可以被合法使用的区域。<br>    * <strong>局部作用域 (Local Scope):</strong> 标识符在块（<code>{}</code>内）或函数内部声明，其作用域从声明点到块或函数结束。<br>    * <strong>全局作用域 (Global Scope):</strong> 标识符在所有函数之外声明，其作用域从声明点到文件结尾。<br>    * <strong>名称优先级:</strong> 局部变量会“隐藏”同名的全局变量。</li>\n<li><strong>生命周期 (Lifetime):</strong> 程序执行期间，标识符实际拥有内存分配的时间。</li>\n<li><strong>存储类型:</strong><br>    * <strong>自动变量 (Automatic):</strong><br>        * 默认的局部变量存储类型（可省略 <code>auto</code> 关键字）。<br>        * 存储在 <strong>栈</strong> 中。<br>        * <strong>生命周期:</strong> 函数调用时创建，函数退出时销毁。<br>        * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。<br>    * <strong>外部变量 (External):</strong><br>        * 即全局变量，定义在所有函数之外。<br>        * 使用 <code>extern</code> 关键字在其他文件中 <strong>声明</strong> （非定义），表示引用一个已在别处定义的全局变量。<br>        * <strong>生命周期:</strong> 整个程序运行期间。<br>        * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>    * <strong>静态变量 (Static):</strong><br>        * 使用 <code>static</code> 关键字声明。<br>        * <strong>静态全局变量:</strong> 作用域被限制在声明它的文件内部，其他文件不可访问。<br>        * <strong>静态局部变量:</strong><br>            * 作用域仍是局部的（函数内）。<br>            * <strong>生命周期:</strong> 整个程序运行期间。<br>            * 只在 <strong>第一次</strong> 调用函数时初始化一次。<br>            * 在函数多次调用之间 <strong>保持其值</strong>。<br>        * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>    * <strong>寄存器变量 (Register):</strong><br>        * 使用 <code>register</code> 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。<br>        * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。</li>\n</ul>\n<h3 id=\"4-4-递归\"><a href=\"#4-4-递归\" class=\"headerlink\" title=\"4.4 递归\"></a>4.4 递归</h3><ul>\n<li><strong>递归 (Recursion):</strong> 一个函数调用其自身的过程。</li>\n<li><strong>递归的两个要素:</strong><br>    1.  <strong>基本情况 (Base Case):</strong> 递归的停止条件，一个无需递归即可解决的简单情况。<br>    2.  <strong>递归步骤 (Recursive Step):</strong> 将问题分解为更小的、同类的问题，并通过递归调用来解决。</li>\n<li><strong>递归 vs. 迭代 (Iteration):</strong><br>    * 任何递归都可以用迭代（循环）和栈来代替。<br>    * 迭代（循环）在执行速度和空间占用上通常 <strong>优于</strong> 递归。</li>\n</ul>\n<h3 id=\"4-5-C预处理器\"><a href=\"#4-5-C预处理器\" class=\"headerlink\" title=\"4.5 C预处理器\"></a>4.5 C预处理器</h3><ul>\n<li>在编译之前对源代码进行处理的程序。</li>\n<li><strong>文件包含 (<code>#include</code>):</strong><br>    * <code>#include &lt;filename&gt;</code>: 在标准库目录或系统路径中查找文件。<br>    * <code>#include &quot;filename&quot;</code>: 从源程序当前目录开始搜索（通常用于自定义头文件）。</li>\n<li><strong>宏替换 (<code>#define</code>):</strong><br>    * 定义一个宏（一个名称和一段替换文本）。<br>    * 预处理器会在编译前进行 <strong>原样文本替换</strong>。<br>    * <strong>带参数的宏:</strong> <code>define max(A,B) ((A) &gt; (B) ? (A) : (B))</code>。<br>    * <strong>宏的陷阱:</strong><br>        * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。<br>        * 注意带副作用的参数，如 <code>max(i++, j++)</code>，会导致 <code>i</code> 或 <code>j</code> 被自增多次。</li>\n<li><strong>条件包含 (<code>#if</code>…):</strong><br>    * 允许根据预处理时的条件来选择性地编译某段代码。<br>    * 指令包括：<code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>。<br>    * <code>#ifndef</code>: “if not defined”，常用于防止头文件被重复包含。</li>\n</ul>\n<h2 id=\"第5章：数组\"><a href=\"#第5章：数组\" class=\"headerlink\" title=\"第5章：数组\"></a>第5章：数组</h2><h3 id=\"5-1-一维数组\"><a href=\"#5-1-一维数组\" class=\"headerlink\" title=\"5.1 一维数组\"></a>5.1 一维数组</h3><ul>\n<li><strong>数组 (Array):</strong> 存储 <strong>相同数据类型</strong> 的元素的集合，这些元素在内存中 <strong>连续存放</strong>。</li>\n<li><strong>数组声明:</strong><br>    * 语法：<code>DataType ArrayName [ConstIntExpression];</code>。<br>    * <code>ConstIntExpression</code> 必须是 <strong>常量表达式</strong>，指定数组的大小（元素个数）。<br>    * 数组大小一旦固定，不可更改。</li>\n<li><strong>数组元素访问:</strong><br>    * 通过 <strong>下标 (Index &#x2F; Subscript)</strong> 访问，下标从 <strong>0</strong> 开始。<br>    * <code>temps[0]</code> 是第一个元素，<code>temps[4]</code> 是第五个元素（对于大小为5的数组）。</li>\n<li><strong>数组名:</strong><br>    * 数组名（如 <code>temps</code>）本身是一个 <strong>指针</strong>，其值是数组的 <strong>基地址</strong>（即第一个元素 <code>temps[0]</code> 的内存地址）。</li>\n<li><strong>数组初始化:</strong><br>    * 可以在声明时初始化：<code>int ages[5] = {40, 13, 20, 19, 36};</code>。<br>    * 可以省略大小，编译器会自动计算：<code>int ages[] = {40, 13, 20};</code>。<br>    * <strong>部分初始化:</strong> <code>int a[5] = { 2 };</code> 第一个元素为2，其余所有元素自动初始化为 0。</li>\n<li><strong>数组的限制:</strong><br>    * <strong>无边界检查 (No Bound Checking):</strong> C语言不检查数组下标是否越界。访问 <code>myList[-1]</code> 或 <code>myList[11]</code>（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。<br>    * <strong>无聚合操作 (No Aggregate Operations):</strong> 不能将一个数组整体赋值给另一个数组（如 <code>x = y;</code> 是错误的）。<br>    * 数组复制必须通过循环逐个元素进行。</li>\n</ul>\n<h3 id=\"5-2-数组与函数\"><a href=\"#5-2-数组与函数\" class=\"headerlink\" title=\"5.2 数组与函数\"></a>5.2 数组与函数</h3><ul>\n<li><strong>数组作为函数参数:</strong><br>    * 当数组作为参数传递时，传递的是数组的 <strong>基地址</strong>。<br>    * 因此，函数参数传递总是 <strong>地址传递</strong>。<br>    * 在函数内部对形参数组的修改 <strong>会</strong> 影响到主调函数中的实参数组。<br>    * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。</li>\n<li><strong>形参声明:</strong><br>    * <code>float FindMax(float arr[], int n)</code><br>    * <code>float FindMax(float *arr, int n)</code> (等价)</li>\n<li><strong><code>const</code> 保护数组参数:</strong><br>    * 如果不希望函数修改数组内容，应在形参声明中使用 <code>const</code> 关键字。<br>    * 示例：<code>float FindMax(const float arr[], int n)</code>。</li>\n</ul>\n<h3 id=\"5-3-数组算法：排序与搜索\"><a href=\"#5-3-数组算法：排序与搜索\" class=\"headerlink\" title=\"5.3 数组算法：排序与搜索\"></a>5.3 数组算法：排序与搜索</h3><ul>\n<li><strong>选择排序 (Selection Sort):</strong><br>    * <strong>算法思想:</strong><br>        1.  从头（<code>passCount = 0</code>）开始。<br>        2.  在 <code>data[passCount ... length-1]</code> 范围内找到 <strong>最小</strong> 元素的索引 <code>minIndx</code>。<br>        3.  将 <code>data[minIndx]</code> 与 <code>data[passCount]</code> 交换。<br>        4.  <code>passCount</code> 增加1，重复该过程，直到 <code>passCount</code> 达到 <code>length - 2</code>。</li>\n<li><strong>线性搜索 (Linear &#x2F; Sequential Search):</strong><br>    * 适用于 <strong>未排序</strong> 的数组。<br>    * 从头到尾（<code>i=0</code> 到 <code>n-1</code>）逐个检查元素，看是否等于目标值 <code>x</code>。<br>    * 找到则返回索引 <code>i</code>，遍历完未找到则返回 <code>-1</code>。</li>\n<li><strong>二分搜索 (Binary Search):</strong><br>  C* <strong>必须</strong> 适用于 <strong>已排序</strong> 的数组。<br>    * <strong>算法思想:</strong><br>        1.  设 <code>first = 0</code>, <code>last = arraySize - 1</code>。<br>        2.  当 <code>last &gt;= first</code> 时循环：<br>        3.  计算中间索引 <code>mid = (first + last) / 2</code>。<br>        4.  如果 <code>key == list[mid]</code>，则找到，返回 <code>mid</code>。<br>        5.  如果 <code>key &lt; list[mid]</code>，则目标在左半边，令 <code>last = mid - 1</code>。<br>        6.  如果 <code>key &gt; list[mid]</code>，则目标在右半边，令 <code>first = mid + 1</code>。<br>        7.  循环结束仍未找到，返回 <code>-1</code>。</li>\n</ul>\n<h3 id=\"5-4-多维数组\"><a href=\"#5-4-多维数组\" class=\"headerlink\" title=\"5.4 多维数组\"></a>5.4 多维数组</h3><ul>\n<li><strong>二维数组 (Two-Dimensional Array):</strong><br>    * 按行和列组织的同类型元素集合。<br>    * <strong>声明:</strong> <code>DataType ArrayName [Rows] [Cols];</code>。<br>    * <strong>访问:</strong> <code>stateHighs[2][7]</code> (访问第3行第8列的元素)。<br>    * <strong>内存存储:</strong> 在内存中按 <strong>行优先 (Row Order)</strong> 连续存储（第一行所有元素，接着是第二行所有元素…）。</li>\n<li><strong>多维数组作为函数参数:</strong><br>    * 传递的仍然是基地址。<br>    * <strong>必须</strong> 指定 <strong>除第一维之外</strong> 的所有维度的大小。<br>    * 示例：<code>void FindAverages(const int stateHighs[][NUM_MONTHS], ...)</code>。</li>\n<li><strong><code>typedef</code> 与数组:</strong><br>    * 可以使用 <code>typedef</code> 来定义数组类型，使函数原型更简洁明了。<br>    * 示例：<code>typedef int SalesType[3][12][5];</code> <code>SalesType sales;</code>。</li>\n</ul>\n"},{"title":"递推和递归","date":"2025-11-05T11:56:56.000Z","cover":"/images/oi_cover.jpg","_content":"## [P1044 [NOIP 2003 普及组] 栈](https://www.luogu.com.cn/problem/P1044)  \n我想使用dfs算法，但是很明显如果数据量过大会超时。  \n\n应该是一个简单的dp问题，但是要想下怎么规划出来。  \n\n假设我们用一个函数 dp(x,y) 表示：\nx：当前还未入栈的数字个数。\ny：当前栈中的数字个数。\n这个时候的方案可能性；\n\n那么`dp[x][y]`=`dp[x-1][y+1]`+`dp[x][y-1]`\n\n由于是反推，那么实际上操作前的可能性就是操作后两种的可能数之和。\n边界条件：`x=0`,`y=0`。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint dp[20][20],n;\nint main ()\n{\n    cin >>n;\n    for (int i=0;i<=n;i++)\n    {\n        for (int j=0;j<=n;j++)\n        {\n            if (i==0) dp[i][j]=1;\n            else if (j==0) dp[i][j]=dp[i-1][j+1];\n            else dp[i][j]=dp[i-1][j+1]+dp[i][j-1];\n        }\n    }\n    cout << dp[n][0];\n}\n```\n代码实现如上，一定要注意***怎么递归***，***边界条件***，***初始化***。\n>可能dp的重点就是这些？完全不用管中间的过程，只要在乎关系，初始化，然后遍历就好了。\n\n## [P1028 [NOIP 2001 普及组] 数的计算](https://www.luogu.com.cn/problem/P1028)\n\n这题比较简单 直接函数递归，\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint steps(int n)\n{\n    int k=n/2;\n    int sum=1;\n    for (int i=1;i<=k;i++) sum += steps(i);\n    return sum;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    cout << steps(n);\n}\n```\n然后tle了。。  \n看眼题解，  \n哦，要把计算过的东西记录下来，减少重复运算。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint sol[1010];\nint steps(int n)\n{\n    int k=n/2;\n    int sum=1;\n    if (sol[n]!=-1) return sol[n];\n    for (int i=1;i<=k;i++) sum += steps(i);\n    sol [n]=sum;\n    return sum;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    memset (sol , -1 ,sizeof(sol));\n    cout << steps(n);\n}\n```\n改完了。\n\n## [P1928 外星密码](https://www.luogu.com.cn/problem/P1928)\n啊这个我是真没搞明白，ac代码如下：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring expand()\n{\n    string result=\"\";\n    char c;\n    int d;\n    string U=\"\";\n    while (cin >> c)\n    {\n        if (c=='[')\n        {\n            cin >> d;\n            U = expand();\n        \n        while (d--) result += U;\n        }\n        else if(c==']') return result;\n        else result += c; \n    }\n    return result;\n}\n\nint main()\n{\n    cout << expand();\n    return 0;\n}\n```\ngemini的解释如下：\n这是一个非常棒的问题！写递归函数时感到困惑是每个程序员的必经之路。你的“外星密码”代码其实已经非常接近递归的精髓了。\n\n当你写一个新的递归函数时，你应该像写一个清单一样，**严格检查**以下四点。如果你能清晰地回答这四个问题，你的递归函数99%就是对的。\n\n---\n\n### 1. 🛑 停止条件 (Base Case)\n\n这是**最重要**的一点。递归必须有出口，否则它会无限调用自己，直到程序崩溃 (称为“栈溢出”，Stack Overflow)。\n\n* **你要问自己：** “这个问题的**最简单**情况是什么？” “什么时候我不需要再调用自己，而是可以直接返回一个答案？”\n* **在你的代码中：**\n    * **显式停止条件：** `if (c == ']')`。当“工人”读到 `]` 时，它的子任务完成了，它必须立刻 `return result;`。\n    * **隐式停止条件：** `while (cin >> c)` 循环结束 (读到文件末尾)。这是你之前 RE (Runtime Error) 的地方。\n\n* **检查清单：**\n    * [ ] 我的函数是否至少有一个 `if` 或 `else if` 来处理“最简单情况”？\n    * [ ] 这个“最简单情况”**是否正确地 `return` 了一个值**？（这就是你修复的 bug！）\n    * [ ] 是否所有可能的“停止”情况都被覆盖了？\n\n### 2. 📉 缩小问题 (Recursive Step)\n\n递归的精髓是把一个“大问题”分解成一个“小一点的、同类问题”。你必须确保**每一次**调用自己时，你给它的问题都比当前的问题“更小”或“更简单”。\n\n* **你要问自己：** “我这次调用自己时，传递的参数是否离‘停止条件’更近了一步？”\n* **在你的代码中：**\n    * 你的“问题”是“处理 `cin` 输入流”。\n    * 当你调用 `U = expand();` 时，这个新的“工人”处理的是**输入流的下一个部分**。\n    * 当它 `return` 时 (在 `]` 处)，它已经消耗掉了括号里的所有字符。对于“上级工人”来说，输入流这个“问题”确实被“缩小”了（它跳过了一整段 `[...D...]`）。\n\n* **检查清单：**\n    * [ ] 递归调用 (`expand()`) 是不是在处理一个*不同*的、*更小*的子问题？\n    * [ ] 这个“缩小”的步骤最终能否**保证**会碰到“停止条件”？（会的，因为输入流总会结束，或者总会碰到 `]`）。\n\n### 3. 🤝 “信任的跳跃” (The Leap of Faith)\n\n这是最难掌握的**思维方式**。你必须强迫自己**不要**去“人肉”跟踪每一层调用。你的人脑不是电脑，你会很快被绕晕。\n\n* **你要告诉自己：** “我**假设**我正在写的这个 `expand()` 函数已经能用了。我不需要知道*它内部*是怎么做到的。”\n* **你要问自己：** “**如果** `expand()` * magically* (神奇地) 帮我解压了 `[...]` 括号里的内容 (返回了 `U`)，我**当前这层**还需要做什么？”\n* **在你的代码中：**\n    * 你的代码完美地体现了这一点。\n    * 你*没有*去想 `expand()` 是怎么处理 `[2CB]` 的。\n    * 你只是说：`U = expand();` // 相信它能返回 \"CBCB\"\n    * 然后你做了“当前层”该做的事：`while (d--) result += U;` // 把 \"CBCB\" 重复 `d` 次。\n\n* **检查清单：**\n    * [ ] 我是否“相信”了我的递归调用能返回正确的结果？\n    * [ ] 我是否正确地使用了这个返回结果，来构造我*当前层*的答案？\n\n### 4. 📦 变量与返回 (State and Return)\n\n这是你遇到 RE 的根源。你必须清楚地知道，每一层“工人”有哪些信息，以及它最终要交回什么。\n\n* **你要问自己：** “我的函数需要返回什么类型的值 ( `string`, `int`, `void`... )？” “在函数的所有可能路径结束时 (包括 `if`, `else`, 和循环结束)，我是否都 `return` 了一个正确类型的值？”\n* **在你的代码中：**\n    * 你的函数声明了 `string expand()`。\n    * 你在 `c == ']'` 时 `return result;` (正确)。\n    * 你**忘记**了在 `while` 循环自然结束时 `return result;` (导致 RE)。\n* **你还要问自己：** “每一层递归调用，它自己的‘局部变量’是否正确？”\n* **在你的代码中：**\n    * `result`, `c`, `d`, `U` 都是局部变量。\n    * 这意味着每个“工人”都有**自己的一套** `result`, `d` 和 `U`。\n    * “工人A”的 `d=2` 和“工人B”的 `d=2` (在 `[2[2CB]]` 例子中) 是**完全独立**的，互不干扰。这非常重要，而你的代码也做对了。\n\n* **检查清单：**\n    * [ ] 我的函数声明了 `string` 返回值，那么**所有**可能的代码出口（`if`, `else`, 循环结束...）是否都 `return` 了一个 `string`？\n    * [ ] 我是应该用“局部变量”（每个工人自己有份），还是“全局变量”（所有工人共享）？(提示：99% 的情况你都应该用局部变量，就像你做的那样)。\n\n---\n\n### 总结：递归的“三问”\n\n下次你写递归时，就问这三个问题：\n\n1.  **“停”：** 我的停止条件是什么？它写对了吗？\n2.  **“小”：** 我调用自己时，问题规模缩小了吗？\n3.  **“信”：** 我相信了那个“小”的调用会返回正确答案吗？我用这个答案做了什么？\n\n(第四点“返回”是 C++ 语法要求，但也是“停止”的一部分。)\n\n你写的代码其实非常漂亮，你只是在“停止条件”的语法实现上漏掉了一个情况。你的递归逻辑思维是完全正确的！\n\n希望这个清单对你有帮助！你还想试试用递归解决另一个经典问题吗？。\n\n---\n我自己再阅读研究一下，递归的本质我是真的没有理解，虽然代码都能看懂，但是自己写写不出来。\n\n## [P2437 蜜蜂路线](https://www.luogu.com.cn/problem/P2437)\n\n简单递推，记得他妈的高精度\n\n```cpp\n//已修改\n#include <bits/stdc++.h>\nusing namespace std;\nstring add(string a, string b)\n{\n    int len = max(a.size(), b.size()), jw = 0;\n    string c = \"\";\n    while (a.size() < len) a = '0' + a;\n    while (b.size() < len) b = '0' + b;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        int t1 = a[i] - '0', t2 = b[i] - '0';\n        int t = t1 + t2 + jw;\n        jw = t / 10;\n        t %= 10;\n        char ch = t + '0';\n        c = ch + c;\n    }\n    if (jw != 0) return '1' + c;\n    return c;\n}\nint main()\n{\n    int n,m;\n    cin >>m>>n;\n    if(m==n)\n    {\n        cout <<1;\n        return 0;\n    }\n    int num=n-m+1;\n    vector <string> a(num);\n    a[0]='1';\n    a[1]='1';\n    for (int i=2;i<num;i++) a[i]=add(a[i-1],a[i-2]);\n    cout << a[num -1];\n}\n```\n~~不是 他妈的为什么错了？~~\n让我看下代码。。  \nvector初始化了什么东西？居然还能通过编译？  \n还有逻辑错误天，`m=n`的时候要做一下修正 ~~（真的有这个测试点吗）~~  \n修改完了  \n我草全部wa  \n我是傻逼，==写成=了。\n\n## [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)\n又想dfs了，但是肯定tle。\n应该是dp吧，找一下递推的关系式。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint m,n;\nint main()\n{\n    cin>>n>>m;\n    int f[n][10010];\n    int a[n];\n    memset(f, 0, sizeof(f));\n    for (int i=0;i<n;i++)  \n    {\n        cin >> a[i];\n    }\n    f[0][0]=1;\n    f[0][a[0]]=1;\n    for (int i=1;i<n;i++)\n    {\n        for (int j=0;j<=m;j++)\n        {\n            f[i][j] = f[i-1][j];\n            if (j>=a[i]) f[i][j]+=f[i-1][j-a[i]];\n        }\n    }\n    cout << f[n-1][m];\n}\n```\n有点魂不守舍了，写了一堆低级错误\n\n---\n\n","source":"_posts/digui.md","raw":"---\ntitle: 递推和递归\ndate: 2025-11-05 19:56:56\ntags:\ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n## [P1044 [NOIP 2003 普及组] 栈](https://www.luogu.com.cn/problem/P1044)  \n我想使用dfs算法，但是很明显如果数据量过大会超时。  \n\n应该是一个简单的dp问题，但是要想下怎么规划出来。  \n\n假设我们用一个函数 dp(x,y) 表示：\nx：当前还未入栈的数字个数。\ny：当前栈中的数字个数。\n这个时候的方案可能性；\n\n那么`dp[x][y]`=`dp[x-1][y+1]`+`dp[x][y-1]`\n\n由于是反推，那么实际上操作前的可能性就是操作后两种的可能数之和。\n边界条件：`x=0`,`y=0`。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint dp[20][20],n;\nint main ()\n{\n    cin >>n;\n    for (int i=0;i<=n;i++)\n    {\n        for (int j=0;j<=n;j++)\n        {\n            if (i==0) dp[i][j]=1;\n            else if (j==0) dp[i][j]=dp[i-1][j+1];\n            else dp[i][j]=dp[i-1][j+1]+dp[i][j-1];\n        }\n    }\n    cout << dp[n][0];\n}\n```\n代码实现如上，一定要注意***怎么递归***，***边界条件***，***初始化***。\n>可能dp的重点就是这些？完全不用管中间的过程，只要在乎关系，初始化，然后遍历就好了。\n\n## [P1028 [NOIP 2001 普及组] 数的计算](https://www.luogu.com.cn/problem/P1028)\n\n这题比较简单 直接函数递归，\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint steps(int n)\n{\n    int k=n/2;\n    int sum=1;\n    for (int i=1;i<=k;i++) sum += steps(i);\n    return sum;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    cout << steps(n);\n}\n```\n然后tle了。。  \n看眼题解，  \n哦，要把计算过的东西记录下来，减少重复运算。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint sol[1010];\nint steps(int n)\n{\n    int k=n/2;\n    int sum=1;\n    if (sol[n]!=-1) return sol[n];\n    for (int i=1;i<=k;i++) sum += steps(i);\n    sol [n]=sum;\n    return sum;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    memset (sol , -1 ,sizeof(sol));\n    cout << steps(n);\n}\n```\n改完了。\n\n## [P1928 外星密码](https://www.luogu.com.cn/problem/P1928)\n啊这个我是真没搞明白，ac代码如下：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring expand()\n{\n    string result=\"\";\n    char c;\n    int d;\n    string U=\"\";\n    while (cin >> c)\n    {\n        if (c=='[')\n        {\n            cin >> d;\n            U = expand();\n        \n        while (d--) result += U;\n        }\n        else if(c==']') return result;\n        else result += c; \n    }\n    return result;\n}\n\nint main()\n{\n    cout << expand();\n    return 0;\n}\n```\ngemini的解释如下：\n这是一个非常棒的问题！写递归函数时感到困惑是每个程序员的必经之路。你的“外星密码”代码其实已经非常接近递归的精髓了。\n\n当你写一个新的递归函数时，你应该像写一个清单一样，**严格检查**以下四点。如果你能清晰地回答这四个问题，你的递归函数99%就是对的。\n\n---\n\n### 1. 🛑 停止条件 (Base Case)\n\n这是**最重要**的一点。递归必须有出口，否则它会无限调用自己，直到程序崩溃 (称为“栈溢出”，Stack Overflow)。\n\n* **你要问自己：** “这个问题的**最简单**情况是什么？” “什么时候我不需要再调用自己，而是可以直接返回一个答案？”\n* **在你的代码中：**\n    * **显式停止条件：** `if (c == ']')`。当“工人”读到 `]` 时，它的子任务完成了，它必须立刻 `return result;`。\n    * **隐式停止条件：** `while (cin >> c)` 循环结束 (读到文件末尾)。这是你之前 RE (Runtime Error) 的地方。\n\n* **检查清单：**\n    * [ ] 我的函数是否至少有一个 `if` 或 `else if` 来处理“最简单情况”？\n    * [ ] 这个“最简单情况”**是否正确地 `return` 了一个值**？（这就是你修复的 bug！）\n    * [ ] 是否所有可能的“停止”情况都被覆盖了？\n\n### 2. 📉 缩小问题 (Recursive Step)\n\n递归的精髓是把一个“大问题”分解成一个“小一点的、同类问题”。你必须确保**每一次**调用自己时，你给它的问题都比当前的问题“更小”或“更简单”。\n\n* **你要问自己：** “我这次调用自己时，传递的参数是否离‘停止条件’更近了一步？”\n* **在你的代码中：**\n    * 你的“问题”是“处理 `cin` 输入流”。\n    * 当你调用 `U = expand();` 时，这个新的“工人”处理的是**输入流的下一个部分**。\n    * 当它 `return` 时 (在 `]` 处)，它已经消耗掉了括号里的所有字符。对于“上级工人”来说，输入流这个“问题”确实被“缩小”了（它跳过了一整段 `[...D...]`）。\n\n* **检查清单：**\n    * [ ] 递归调用 (`expand()`) 是不是在处理一个*不同*的、*更小*的子问题？\n    * [ ] 这个“缩小”的步骤最终能否**保证**会碰到“停止条件”？（会的，因为输入流总会结束，或者总会碰到 `]`）。\n\n### 3. 🤝 “信任的跳跃” (The Leap of Faith)\n\n这是最难掌握的**思维方式**。你必须强迫自己**不要**去“人肉”跟踪每一层调用。你的人脑不是电脑，你会很快被绕晕。\n\n* **你要告诉自己：** “我**假设**我正在写的这个 `expand()` 函数已经能用了。我不需要知道*它内部*是怎么做到的。”\n* **你要问自己：** “**如果** `expand()` * magically* (神奇地) 帮我解压了 `[...]` 括号里的内容 (返回了 `U`)，我**当前这层**还需要做什么？”\n* **在你的代码中：**\n    * 你的代码完美地体现了这一点。\n    * 你*没有*去想 `expand()` 是怎么处理 `[2CB]` 的。\n    * 你只是说：`U = expand();` // 相信它能返回 \"CBCB\"\n    * 然后你做了“当前层”该做的事：`while (d--) result += U;` // 把 \"CBCB\" 重复 `d` 次。\n\n* **检查清单：**\n    * [ ] 我是否“相信”了我的递归调用能返回正确的结果？\n    * [ ] 我是否正确地使用了这个返回结果，来构造我*当前层*的答案？\n\n### 4. 📦 变量与返回 (State and Return)\n\n这是你遇到 RE 的根源。你必须清楚地知道，每一层“工人”有哪些信息，以及它最终要交回什么。\n\n* **你要问自己：** “我的函数需要返回什么类型的值 ( `string`, `int`, `void`... )？” “在函数的所有可能路径结束时 (包括 `if`, `else`, 和循环结束)，我是否都 `return` 了一个正确类型的值？”\n* **在你的代码中：**\n    * 你的函数声明了 `string expand()`。\n    * 你在 `c == ']'` 时 `return result;` (正确)。\n    * 你**忘记**了在 `while` 循环自然结束时 `return result;` (导致 RE)。\n* **你还要问自己：** “每一层递归调用，它自己的‘局部变量’是否正确？”\n* **在你的代码中：**\n    * `result`, `c`, `d`, `U` 都是局部变量。\n    * 这意味着每个“工人”都有**自己的一套** `result`, `d` 和 `U`。\n    * “工人A”的 `d=2` 和“工人B”的 `d=2` (在 `[2[2CB]]` 例子中) 是**完全独立**的，互不干扰。这非常重要，而你的代码也做对了。\n\n* **检查清单：**\n    * [ ] 我的函数声明了 `string` 返回值，那么**所有**可能的代码出口（`if`, `else`, 循环结束...）是否都 `return` 了一个 `string`？\n    * [ ] 我是应该用“局部变量”（每个工人自己有份），还是“全局变量”（所有工人共享）？(提示：99% 的情况你都应该用局部变量，就像你做的那样)。\n\n---\n\n### 总结：递归的“三问”\n\n下次你写递归时，就问这三个问题：\n\n1.  **“停”：** 我的停止条件是什么？它写对了吗？\n2.  **“小”：** 我调用自己时，问题规模缩小了吗？\n3.  **“信”：** 我相信了那个“小”的调用会返回正确答案吗？我用这个答案做了什么？\n\n(第四点“返回”是 C++ 语法要求，但也是“停止”的一部分。)\n\n你写的代码其实非常漂亮，你只是在“停止条件”的语法实现上漏掉了一个情况。你的递归逻辑思维是完全正确的！\n\n希望这个清单对你有帮助！你还想试试用递归解决另一个经典问题吗？。\n\n---\n我自己再阅读研究一下，递归的本质我是真的没有理解，虽然代码都能看懂，但是自己写写不出来。\n\n## [P2437 蜜蜂路线](https://www.luogu.com.cn/problem/P2437)\n\n简单递推，记得他妈的高精度\n\n```cpp\n//已修改\n#include <bits/stdc++.h>\nusing namespace std;\nstring add(string a, string b)\n{\n    int len = max(a.size(), b.size()), jw = 0;\n    string c = \"\";\n    while (a.size() < len) a = '0' + a;\n    while (b.size() < len) b = '0' + b;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        int t1 = a[i] - '0', t2 = b[i] - '0';\n        int t = t1 + t2 + jw;\n        jw = t / 10;\n        t %= 10;\n        char ch = t + '0';\n        c = ch + c;\n    }\n    if (jw != 0) return '1' + c;\n    return c;\n}\nint main()\n{\n    int n,m;\n    cin >>m>>n;\n    if(m==n)\n    {\n        cout <<1;\n        return 0;\n    }\n    int num=n-m+1;\n    vector <string> a(num);\n    a[0]='1';\n    a[1]='1';\n    for (int i=2;i<num;i++) a[i]=add(a[i-1],a[i-2]);\n    cout << a[num -1];\n}\n```\n~~不是 他妈的为什么错了？~~\n让我看下代码。。  \nvector初始化了什么东西？居然还能通过编译？  \n还有逻辑错误天，`m=n`的时候要做一下修正 ~~（真的有这个测试点吗）~~  \n修改完了  \n我草全部wa  \n我是傻逼，==写成=了。\n\n## [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)\n又想dfs了，但是肯定tle。\n应该是dp吧，找一下递推的关系式。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint m,n;\nint main()\n{\n    cin>>n>>m;\n    int f[n][10010];\n    int a[n];\n    memset(f, 0, sizeof(f));\n    for (int i=0;i<n;i++)  \n    {\n        cin >> a[i];\n    }\n    f[0][0]=1;\n    f[0][a[0]]=1;\n    for (int i=1;i<n;i++)\n    {\n        for (int j=0;j<=m;j++)\n        {\n            f[i][j] = f[i-1][j];\n            if (j>=a[i]) f[i][j]+=f[i-1][j-a[i]];\n        }\n    }\n    cout << f[n-1][m];\n}\n```\n有点魂不守舍了，写了一堆低级错误\n\n---\n\n","slug":"digui","published":1,"updated":"2025-11-16T08:22:02.941Z","comments":1,"layout":"post","photos":[],"_id":"cuidk9tQx0WzoLet_B9x6C8Wf","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"p1044-noip-2003-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%A0%88\"></span></h2><p>我想使用dfs算法，但是很明显如果数据量过大会超时。  </p>\n<p>应该是一个简单的dp问题，但是要想下怎么规划出来。  </p>\n<p>假设我们用一个函数 dp(x,y) 表示：<br>x：当前还未入栈的数字个数。<br>y：当前栈中的数字个数。<br>这个时候的方案可能性；</p>\n<p>那么<code>dp[x][y]</code>=<code>dp[x-1][y+1]</code>+<code>dp[x][y-1]</code></p>\n<p>由于是反推，那么实际上操作前的可能性就是操作后两种的可能数之和。<br>边界条件：<code>x=0</code>,<code>y=0</code>。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">int</span> dp[<span class=\"hljs-number\">20</span>][<span class=\"hljs-number\">20</span>],n;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    cin &gt;&gt;n;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)<br>    {<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;=n;j++)<br>        {<br>            <span class=\"hljs-keyword\">if</span> (i==<span class=\"hljs-number\">0</span>) dp[i][j]=<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (j==<span class=\"hljs-number\">0</span>) dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">+1</span>];<br>            <span class=\"hljs-keyword\">else</span> dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">+1</span>]+dp[i][j<span class=\"hljs-number\">-1</span>];<br>        }<br>    }<br>    cout &lt;&lt; dp[n][<span class=\"hljs-number\">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>代码实现如上，一定要注意<em><strong>怎么递归</strong></em>，<em><strong>边界条件</strong></em>，<em><strong>初始化</strong></em>。</p>\n<blockquote>\n<p>可能dp的重点就是这些？完全不用管中间的过程，只要在乎关系，初始化，然后遍历就好了。</p>\n</blockquote>\n<h2><span id=\"p1028-noip-2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97\"></span></h2><p>这题比较简单 直接函数递归，</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">steps</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> k=n/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=k;i++) sum += <span class=\"hljs-built_in\">steps</span>(i);<br>    <span class=\"hljs-keyword\">return</span> sum;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class=\"hljs-built_in\">steps</span>(n);<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>然后tle了。。<br>看眼题解，<br>哦，要把计算过的东西记录下来，减少重复运算。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">int</span> sol[<span class=\"hljs-number\">1010</span>];<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">steps</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> k=n/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (sol[n]!=<span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span> sol[n];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=k;i++) sum += <span class=\"hljs-built_in\">steps</span>(i);<br>    sol [n]=sum;<br>    <span class=\"hljs-keyword\">return</span> sum;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class=\"hljs-built_in\">memset</span> (sol , <span class=\"hljs-number\">-1</span> ,<span class=\"hljs-built_in\">sizeof</span>(sol));<br>    cout &lt;&lt; <span class=\"hljs-built_in\">steps</span>(n);<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>改完了。</p>\n<h2><span id=\"p1928-%E5%A4%96%E6%98%9F%E5%AF%86%E7%A0%81\"></span></h2><p>啊这个我是真没搞明白，ac代码如下：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">expand</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    string result=<span class=\"hljs-string\">\"\"</span>;<br>    <span class=\"hljs-type\">char</span> c;<br>    <span class=\"hljs-type\">int</span> d;<br>    string U=<span class=\"hljs-string\">\"\"</span>;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; c)<br>    {<br>        <span class=\"hljs-keyword\">if</span> (c==<span class=\"hljs-string\">'['</span>)<br>        {<br>            cin &gt;&gt; d;<br>            U = <span class=\"hljs-built_in\">expand</span>();<br>        <br>        <span class=\"hljs-keyword\">while</span> (d--) result += U;<br>        }<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(c==<span class=\"hljs-string\">']'</span>) <span class=\"hljs-keyword\">return</span> result;<br>        <span class=\"hljs-keyword\">else</span> result += c; <br>    }<br>    <span class=\"hljs-keyword\">return</span> result;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    cout &lt;&lt; <span class=\"hljs-built_in\">expand</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>gemini的解释如下：<br>这是一个非常棒的问题！写递归函数时感到困惑是每个程序员的必经之路。你的“外星密码”代码其实已经非常接近递归的精髓了。</p>\n<p>当你写一个新的递归函数时，你应该像写一个清单一样，<strong>严格检查</strong>以下四点。如果你能清晰地回答这四个问题，你的递归函数99%就是对的。</p>\n<hr>\n<h3><span id=\"1-%F0%9F%9B%91-%E5%81%9C%E6%AD%A2%E6%9D%A1%E4%BB%B6-base-case\">1. 🛑 停止条件 (Base Case)</span></h3><p>这是<strong>最重要</strong>的一点。递归必须有出口，否则它会无限调用自己，直到程序崩溃 (称为“栈溢出”，Stack Overflow)。</p>\n<ul>\n<li><p><strong>你要问自己：</strong> “这个问题的<strong>最简单</strong>情况是什么？” “什么时候我不需要再调用自己，而是可以直接返回一个答案？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li><strong>显式停止条件：</strong> <code>if (c == ']')</code>。当“工人”读到 <code>]</code> 时，它的子任务完成了，它必须立刻 <code>return result;</code>。</li>\n<li><strong>隐式停止条件：</strong> <code>while (cin &gt;&gt; c)</code> 循环结束 (读到文件末尾)。这是你之前 RE (Runtime Error) 的地方。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 我的函数是否至少有一个 <code>if</code> 或 <code>else if</code> 来处理“最简单情况”？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 这个“最简单情况”<strong>是否正确地 <code>return</code> 了一个值</strong>？（这就是你修复的 bug！）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 是否所有可能的“停止”情况都被覆盖了？</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"2-%F0%9F%93%89-%E7%BC%A9%E5%B0%8F%E9%97%AE%E9%A2%98-recursive-step\">2. 📉 缩小问题 (Recursive Step)</span></h3><p>递归的精髓是把一个“大问题”分解成一个“小一点的、同类问题”。你必须确保<strong>每一次</strong>调用自己时，你给它的问题都比当前的问题“更小”或“更简单”。</p>\n<ul>\n<li><p><strong>你要问自己：</strong> “我这次调用自己时，传递的参数是否离‘停止条件’更近了一步？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li>你的“问题”是“处理 <code>cin</code> 输入流”。</li>\n<li>当你调用 <code>U = expand();</code> 时，这个新的“工人”处理的是<strong>输入流的下一个部分</strong>。</li>\n<li>当它 <code>return</code> 时 (在 <code>]</code> 处)，它已经消耗掉了括号里的所有字符。对于“上级工人”来说，输入流这个“问题”确实被“缩小”了（它跳过了一整段 <code>[...D...]</code>）。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 递归调用 (<code>expand()</code>) 是不是在处理一个<em>不同</em>的、<em>更小</em>的子问题？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 这个“缩小”的步骤最终能否<strong>保证</strong>会碰到“停止条件”？（会的，因为输入流总会结束，或者总会碰到 <code>]</code>）。</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"3-%F0%9F%A4%9D-%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%B7%B3%E8%B7%83-the-leap-of-faith\">3. 🤝 “信任的跳跃” (The Leap of Faith)</span></h3><p>这是最难掌握的<strong>思维方式</strong>。你必须强迫自己<strong>不要</strong>去“人肉”跟踪每一层调用。你的人脑不是电脑，你会很快被绕晕。</p>\n<ul>\n<li><p><strong>你要告诉自己：</strong> “我<strong>假设</strong>我正在写的这个 <code>expand()</code> 函数已经能用了。我不需要知道<em>它内部</em>是怎么做到的。”</p>\n</li>\n<li><p><strong>你要问自己：</strong> “<strong>如果</strong> <code>expand()</code> * magically* (神奇地) 帮我解压了 <code>[...]</code> 括号里的内容 (返回了 <code>U</code>)，我<strong>当前这层</strong>还需要做什么？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li>你的代码完美地体现了这一点。</li>\n<li>你<em>没有</em>去想 <code>expand()</code> 是怎么处理 <code>[2CB]</code> 的。</li>\n<li>你只是说：<code>U = expand();</code> // 相信它能返回 “CBCB”</li>\n<li>然后你做了“当前层”该做的事：<code>while (d--) result += U;</code> // 把 “CBCB” 重复 <code>d</code> 次。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 我是否“相信”了我的递归调用能返回正确的结果？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 我是否正确地使用了这个返回结果，来构造我<em>当前层</em>的答案？</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"4-%F0%9F%93%A6-%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%94%E5%9B%9E-state-and-return\">4. 📦 变量与返回 (State and Return)</span></h3><p>这是你遇到 RE 的根源。你必须清楚地知道，每一层“工人”有哪些信息，以及它最终要交回什么。</p>\n<ul>\n<li><p><strong>你要问自己：</strong> “我的函数需要返回什么类型的值 ( <code>string</code>, <code>int</code>, <code>void</code>… )？” “在函数的所有可能路径结束时 (包括 <code>if</code>, <code>else</code>, 和循环结束)，我是否都 <code>return</code> 了一个正确类型的值？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li>你的函数声明了 <code>string expand()</code>。</li>\n<li>你在 <code>c == ']'</code> 时 <code>return result;</code> (正确)。</li>\n<li>你<strong>忘记</strong>了在 <code>while</code> 循环自然结束时 <code>return result;</code> (导致 RE)。</li>\n</ul>\n</li>\n<li><p><strong>你还要问自己：</strong> “每一层递归调用，它自己的‘局部变量’是否正确？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li><code>result</code>, <code>c</code>, <code>d</code>, <code>U</code> 都是局部变量。</li>\n<li>这意味着每个“工人”都有<strong>自己的一套</strong> <code>result</code>, <code>d</code> 和 <code>U</code>。</li>\n<li>“工人A”的 <code>d=2</code> 和“工人B”的 <code>d=2</code> (在 <code>[2[2CB]]</code> 例子中) 是<strong>完全独立</strong>的，互不干扰。这非常重要，而你的代码也做对了。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 我的函数声明了 <code>string</code> 返回值，那么<strong>所有</strong>可能的代码出口（<code>if</code>, <code>else</code>, 循环结束…）是否都 <code>return</code> 了一个 <code>string</code>？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 我是应该用“局部变量”（每个工人自己有份），还是“全局变量”（所有工人共享）？(提示：99% 的情况你都应该用局部变量，就像你做的那样)。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><span id=\"%E6%80%BB%E7%BB%93%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%89%E9%97%AE\">总结：递归的“三问”</span></h3><p>下次你写递归时，就问这三个问题：</p>\n<ol>\n<li><strong>“停”：</strong> 我的停止条件是什么？它写对了吗？</li>\n<li><strong>“小”：</strong> 我调用自己时，问题规模缩小了吗？</li>\n<li><strong>“信”：</strong> 我相信了那个“小”的调用会返回正确答案吗？我用这个答案做了什么？</li>\n</ol>\n<p>(第四点“返回”是 C++ 语法要求，但也是“停止”的一部分。)</p>\n<p>你写的代码其实非常漂亮，你只是在“停止条件”的语法实现上漏掉了一个情况。你的递归逻辑思维是完全正确的！</p>\n<p>希望这个清单对你有帮助！你还想试试用递归解决另一个经典问题吗？。</p>\n<hr>\n<p>我自己再阅读研究一下，递归的本质我是真的没有理解，虽然代码都能看懂，但是自己写写不出来。</p>\n<h2><span id=\"p2437-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF\"></span></h2><p>简单递推，记得他妈的高精度</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//已修改</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(a.<span class=\"hljs-built_in\">size</span>(), b.<span class=\"hljs-built_in\">size</span>()), jw = <span class=\"hljs-number\">0</span>;<br>    string c = <span class=\"hljs-string\">\"\"</span>;<br>    <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-built_in\">size</span>() &lt; len) a = <span class=\"hljs-string\">'0'</span> + a;<br>    <span class=\"hljs-keyword\">while</span> (b.<span class=\"hljs-built_in\">size</span>() &lt; len) b = <span class=\"hljs-string\">'0'</span> + b;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = len - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>    {<br>        <span class=\"hljs-type\">int</span> t1 = a[i] - <span class=\"hljs-string\">'0'</span>, t2 = b[i] - <span class=\"hljs-string\">'0'</span>;<br>        <span class=\"hljs-type\">int</span> t = t1 + t2 + jw;<br>        jw = t / <span class=\"hljs-number\">10</span>;<br>        t %= <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">char</span> ch = t + <span class=\"hljs-string\">'0'</span>;<br>        c = ch + c;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (jw != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'1'</span> + c;<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> n,m;<br>    cin &gt;&gt;m&gt;&gt;n;<br>    <span class=\"hljs-keyword\">if</span>(m==n)<br>    {<br>        cout &lt;&lt;<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    }<br>    <span class=\"hljs-type\">int</span> num=n-m<span class=\"hljs-number\">+1</span>;<br>    vector &lt;string&gt; <span class=\"hljs-built_in\">a</span>(num);<br>    a[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-string\">'1'</span>;<br>    a[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-string\">'1'</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;num;i++) a[i]=<span class=\"hljs-built_in\">add</span>(a[i<span class=\"hljs-number\">-1</span>],a[i<span class=\"hljs-number\">-2</span>]);<br>    cout &lt;&lt; a[num <span class=\"hljs-number\">-1</span>];<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p><del>不是 他妈的为什么错了？</del><br>让我看下代码。。<br>vector初始化了什么东西？居然还能通过编译？<br>还有逻辑错误天，<code>m=n</code>的时候要做一下修正 <del>（真的有这个测试点吗）</del><br>修改完了<br>我草全部wa<br>我是傻逼，==写成=了。</p>\n<h2><span id=\"p1164-%E5%B0%8Fa%E7%82%B9%E8%8F%9C\"></span></h2><p>又想dfs了，但是肯定tle。<br>应该是dp吧，找一下递推的关系式。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">int</span> m,n;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class=\"hljs-type\">int</span> f[n][<span class=\"hljs-number\">10010</span>];<br>    <span class=\"hljs-type\">int</span> a[n];<br>    <span class=\"hljs-built_in\">memset</span>(f, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(f));<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)  <br>    {<br>        cin &gt;&gt; a[i];<br>    }<br>    f[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>    f[<span class=\"hljs-number\">0</span>][a[<span class=\"hljs-number\">0</span>]]=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)<br>    {<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;=m;j++)<br>        {<br>            f[i][j] = f[i<span class=\"hljs-number\">-1</span>][j];<br>            <span class=\"hljs-keyword\">if</span> (j&gt;=a[i]) f[i][j]+=f[i<span class=\"hljs-number\">-1</span>][j-a[i]];<br>        }<br>    }<br>    cout &lt;&lt; f[n<span class=\"hljs-number\">-1</span>][m];<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>有点魂不守舍了，写了一堆低级错误</p>\n<hr>\n</body></html>","excerpt":"","more":"<h2 id=\"P1044-NOIP-2003-普及组-栈\"><a href=\"#P1044-NOIP-2003-普及组-栈\" class=\"headerlink\" title=\"P1044 [NOIP 2003 普及组] 栈\"></a><a href=\"https://www.luogu.com.cn/problem/P1044\">P1044 [NOIP 2003 普及组] 栈</a></h2><p>我想使用dfs算法，但是很明显如果数据量过大会超时。  </p>\n<p>应该是一个简单的dp问题，但是要想下怎么规划出来。  </p>\n<p>假设我们用一个函数 dp(x,y) 表示：<br>x：当前还未入栈的数字个数。<br>y：当前栈中的数字个数。<br>这个时候的方案可能性；</p>\n<p>那么<code>dp[x][y]</code>&#x3D;<code>dp[x-1][y+1]</code>+<code>dp[x][y-1]</code></p>\n<p>由于是反推，那么实际上操作前的可能性就是操作后两种的可能数之和。<br>边界条件：<code>x=0</code>,<code>y=0</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">int</span> dp[<span class=\"hljs-number\">20</span>][<span class=\"hljs-number\">20</span>],n;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cin &gt;&gt;n;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (i==<span class=\"hljs-number\">0</span>) dp[i][j]=<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (j==<span class=\"hljs-number\">0</span>) dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">+1</span>];<br>            <span class=\"hljs-keyword\">else</span> dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">+1</span>]+dp[i][j<span class=\"hljs-number\">-1</span>];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[n][<span class=\"hljs-number\">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>代码实现如上，一定要注意<em><strong>怎么递归</strong></em>，<em><strong>边界条件</strong></em>，<em><strong>初始化</strong></em>。</p>\n<blockquote>\n<p>可能dp的重点就是这些？完全不用管中间的过程，只要在乎关系，初始化，然后遍历就好了。</p>\n</blockquote>\n<h2 id=\"P1028-NOIP-2001-普及组-数的计算\"><a href=\"#P1028-NOIP-2001-普及组-数的计算\" class=\"headerlink\" title=\"P1028 [NOIP 2001 普及组] 数的计算\"></a><a href=\"https://www.luogu.com.cn/problem/P1028\">P1028 [NOIP 2001 普及组] 数的计算</a></h2><p>这题比较简单 直接函数递归，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">steps</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> k=n/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=k;i++) sum += <span class=\"hljs-built_in\">steps</span>(i);<br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class=\"hljs-built_in\">steps</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后tle了。。<br>看眼题解，<br>哦，要把计算过的东西记录下来，减少重复运算。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">int</span> sol[<span class=\"hljs-number\">1010</span>];<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">steps</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> k=n/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (sol[n]!=<span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span> sol[n];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=k;i++) sum += <span class=\"hljs-built_in\">steps</span>(i);<br>    sol [n]=sum;<br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class=\"hljs-built_in\">memset</span> (sol , <span class=\"hljs-number\">-1</span> ,<span class=\"hljs-built_in\">sizeof</span>(sol));<br>    cout &lt;&lt; <span class=\"hljs-built_in\">steps</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>改完了。</p>\n<h2 id=\"P1928-外星密码\"><a href=\"#P1928-外星密码\" class=\"headerlink\" title=\"P1928 外星密码\"></a><a href=\"https://www.luogu.com.cn/problem/P1928\">P1928 外星密码</a></h2><p>啊这个我是真没搞明白，ac代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">expand</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    string result=<span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-type\">char</span> c;<br>    <span class=\"hljs-type\">int</span> d;<br>    string U=<span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; c)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (c==<span class=\"hljs-string\">&#x27;[&#x27;</span>)<br>        &#123;<br>            cin &gt;&gt; d;<br>            U = <span class=\"hljs-built_in\">expand</span>();<br>        <br>        <span class=\"hljs-keyword\">while</span> (d--) result += U;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(c==<span class=\"hljs-string\">&#x27;]&#x27;</span>) <span class=\"hljs-keyword\">return</span> result;<br>        <span class=\"hljs-keyword\">else</span> result += c; <br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-built_in\">expand</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>gemini的解释如下：<br>这是一个非常棒的问题！写递归函数时感到困惑是每个程序员的必经之路。你的“外星密码”代码其实已经非常接近递归的精髓了。</p>\n<p>当你写一个新的递归函数时，你应该像写一个清单一样，<strong>严格检查</strong>以下四点。如果你能清晰地回答这四个问题，你的递归函数99%就是对的。</p>\n<hr>\n<h3 id=\"1-🛑-停止条件-Base-Case\"><a href=\"#1-🛑-停止条件-Base-Case\" class=\"headerlink\" title=\"1. 🛑 停止条件 (Base Case)\"></a>1. 🛑 停止条件 (Base Case)</h3><p>这是<strong>最重要</strong>的一点。递归必须有出口，否则它会无限调用自己，直到程序崩溃 (称为“栈溢出”，Stack Overflow)。</p>\n<ul>\n<li><p><strong>你要问自己：</strong> “这个问题的<strong>最简单</strong>情况是什么？” “什么时候我不需要再调用自己，而是可以直接返回一个答案？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li><strong>显式停止条件：</strong> <code>if (c == &#39;]&#39;)</code>。当“工人”读到 <code>]</code> 时，它的子任务完成了，它必须立刻 <code>return result;</code>。</li>\n<li><strong>隐式停止条件：</strong> <code>while (cin &gt;&gt; c)</code> 循环结束 (读到文件末尾)。这是你之前 RE (Runtime Error) 的地方。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 我的函数是否至少有一个 <code>if</code> 或 <code>else if</code> 来处理“最简单情况”？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 这个“最简单情况”<strong>是否正确地 <code>return</code> 了一个值</strong>？（这就是你修复的 bug！）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 是否所有可能的“停止”情况都被覆盖了？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-📉-缩小问题-Recursive-Step\"><a href=\"#2-📉-缩小问题-Recursive-Step\" class=\"headerlink\" title=\"2. 📉 缩小问题 (Recursive Step)\"></a>2. 📉 缩小问题 (Recursive Step)</h3><p>递归的精髓是把一个“大问题”分解成一个“小一点的、同类问题”。你必须确保<strong>每一次</strong>调用自己时，你给它的问题都比当前的问题“更小”或“更简单”。</p>\n<ul>\n<li><p><strong>你要问自己：</strong> “我这次调用自己时，传递的参数是否离‘停止条件’更近了一步？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li>你的“问题”是“处理 <code>cin</code> 输入流”。</li>\n<li>当你调用 <code>U = expand();</code> 时，这个新的“工人”处理的是<strong>输入流的下一个部分</strong>。</li>\n<li>当它 <code>return</code> 时 (在 <code>]</code> 处)，它已经消耗掉了括号里的所有字符。对于“上级工人”来说，输入流这个“问题”确实被“缩小”了（它跳过了一整段 <code>[...D...]</code>）。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 递归调用 (<code>expand()</code>) 是不是在处理一个<em>不同</em>的、<em>更小</em>的子问题？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 这个“缩小”的步骤最终能否<strong>保证</strong>会碰到“停止条件”？（会的，因为输入流总会结束，或者总会碰到 <code>]</code>）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-🤝-“信任的跳跃”-The-Leap-of-Faith\"><a href=\"#3-🤝-“信任的跳跃”-The-Leap-of-Faith\" class=\"headerlink\" title=\"3. 🤝 “信任的跳跃” (The Leap of Faith)\"></a>3. 🤝 “信任的跳跃” (The Leap of Faith)</h3><p>这是最难掌握的<strong>思维方式</strong>。你必须强迫自己<strong>不要</strong>去“人肉”跟踪每一层调用。你的人脑不是电脑，你会很快被绕晕。</p>\n<ul>\n<li><p><strong>你要告诉自己：</strong> “我<strong>假设</strong>我正在写的这个 <code>expand()</code> 函数已经能用了。我不需要知道<em>它内部</em>是怎么做到的。”</p>\n</li>\n<li><p><strong>你要问自己：</strong> “<strong>如果</strong> <code>expand()</code> * magically* (神奇地) 帮我解压了 <code>[...]</code> 括号里的内容 (返回了 <code>U</code>)，我<strong>当前这层</strong>还需要做什么？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li>你的代码完美地体现了这一点。</li>\n<li>你<em>没有</em>去想 <code>expand()</code> 是怎么处理 <code>[2CB]</code> 的。</li>\n<li>你只是说：<code>U = expand();</code> &#x2F;&#x2F; 相信它能返回 “CBCB”</li>\n<li>然后你做了“当前层”该做的事：<code>while (d--) result += U;</code> &#x2F;&#x2F; 把 “CBCB” 重复 <code>d</code> 次。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 我是否“相信”了我的递归调用能返回正确的结果？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 我是否正确地使用了这个返回结果，来构造我<em>当前层</em>的答案？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-📦-变量与返回-State-and-Return\"><a href=\"#4-📦-变量与返回-State-and-Return\" class=\"headerlink\" title=\"4. 📦 变量与返回 (State and Return)\"></a>4. 📦 变量与返回 (State and Return)</h3><p>这是你遇到 RE 的根源。你必须清楚地知道，每一层“工人”有哪些信息，以及它最终要交回什么。</p>\n<ul>\n<li><p><strong>你要问自己：</strong> “我的函数需要返回什么类型的值 ( <code>string</code>, <code>int</code>, <code>void</code>… )？” “在函数的所有可能路径结束时 (包括 <code>if</code>, <code>else</code>, 和循环结束)，我是否都 <code>return</code> 了一个正确类型的值？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li>你的函数声明了 <code>string expand()</code>。</li>\n<li>你在 <code>c == &#39;]&#39;</code> 时 <code>return result;</code> (正确)。</li>\n<li>你<strong>忘记</strong>了在 <code>while</code> 循环自然结束时 <code>return result;</code> (导致 RE)。</li>\n</ul>\n</li>\n<li><p><strong>你还要问自己：</strong> “每一层递归调用，它自己的‘局部变量’是否正确？”</p>\n</li>\n<li><p><strong>在你的代码中：</strong></p>\n<ul>\n<li><code>result</code>, <code>c</code>, <code>d</code>, <code>U</code> 都是局部变量。</li>\n<li>这意味着每个“工人”都有<strong>自己的一套</strong> <code>result</code>, <code>d</code> 和 <code>U</code>。</li>\n<li>“工人A”的 <code>d=2</code> 和“工人B”的 <code>d=2</code> (在 <code>[2[2CB]]</code> 例子中) 是<strong>完全独立</strong>的，互不干扰。这非常重要，而你的代码也做对了。</li>\n</ul>\n</li>\n<li><p><strong>检查清单：</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 我的函数声明了 <code>string</code> 返回值，那么<strong>所有</strong>可能的代码出口（<code>if</code>, <code>else</code>, 循环结束…）是否都 <code>return</code> 了一个 <code>string</code>？</li>\n<li><input disabled=\"\" type=\"checkbox\"> 我是应该用“局部变量”（每个工人自己有份），还是“全局变量”（所有工人共享）？(提示：99% 的情况你都应该用局部变量，就像你做的那样)。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"总结：递归的“三问”\"><a href=\"#总结：递归的“三问”\" class=\"headerlink\" title=\"总结：递归的“三问”\"></a>总结：递归的“三问”</h3><p>下次你写递归时，就问这三个问题：</p>\n<ol>\n<li><strong>“停”：</strong> 我的停止条件是什么？它写对了吗？</li>\n<li><strong>“小”：</strong> 我调用自己时，问题规模缩小了吗？</li>\n<li><strong>“信”：</strong> 我相信了那个“小”的调用会返回正确答案吗？我用这个答案做了什么？</li>\n</ol>\n<p>(第四点“返回”是 C++ 语法要求，但也是“停止”的一部分。)</p>\n<p>你写的代码其实非常漂亮，你只是在“停止条件”的语法实现上漏掉了一个情况。你的递归逻辑思维是完全正确的！</p>\n<p>希望这个清单对你有帮助！你还想试试用递归解决另一个经典问题吗？。</p>\n<hr>\n<p>我自己再阅读研究一下，递归的本质我是真的没有理解，虽然代码都能看懂，但是自己写写不出来。</p>\n<h2 id=\"P2437-蜜蜂路线\"><a href=\"#P2437-蜜蜂路线\" class=\"headerlink\" title=\"P2437 蜜蜂路线\"></a><a href=\"https://www.luogu.com.cn/problem/P2437\">P2437 蜜蜂路线</a></h2><p>简单递推，记得他妈的高精度</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//已修改</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(a.<span class=\"hljs-built_in\">size</span>(), b.<span class=\"hljs-built_in\">size</span>()), jw = <span class=\"hljs-number\">0</span>;<br>    string c = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-built_in\">size</span>() &lt; len) a = <span class=\"hljs-string\">&#x27;0&#x27;</span> + a;<br>    <span class=\"hljs-keyword\">while</span> (b.<span class=\"hljs-built_in\">size</span>() &lt; len) b = <span class=\"hljs-string\">&#x27;0&#x27;</span> + b;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = len - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> t1 = a[i] - <span class=\"hljs-string\">&#x27;0&#x27;</span>, t2 = b[i] - <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        <span class=\"hljs-type\">int</span> t = t1 + t2 + jw;<br>        jw = t / <span class=\"hljs-number\">10</span>;<br>        t %= <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">char</span> ch = t + <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        c = ch + c;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (jw != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;1&#x27;</span> + c;<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n,m;<br>    cin &gt;&gt;m&gt;&gt;n;<br>    <span class=\"hljs-keyword\">if</span>(m==n)<br>    &#123;<br>        cout &lt;&lt;<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> num=n-m<span class=\"hljs-number\">+1</span>;<br>    vector &lt;string&gt; <span class=\"hljs-built_in\">a</span>(num);<br>    a[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-string\">&#x27;1&#x27;</span>;<br>    a[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-string\">&#x27;1&#x27;</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;num;i++) a[i]=<span class=\"hljs-built_in\">add</span>(a[i<span class=\"hljs-number\">-1</span>],a[i<span class=\"hljs-number\">-2</span>]);<br>    cout &lt;&lt; a[num <span class=\"hljs-number\">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><del>不是 他妈的为什么错了？</del><br>让我看下代码。。<br>vector初始化了什么东西？居然还能通过编译？<br>还有逻辑错误天，<code>m=n</code>的时候要做一下修正 <del>（真的有这个测试点吗）</del><br>修改完了<br>我草全部wa<br>我是傻逼，&#x3D;&#x3D;写成&#x3D;了。</p>\n<h2 id=\"P1164-小A点菜\"><a href=\"#P1164-小A点菜\" class=\"headerlink\" title=\"P1164 小A点菜\"></a><a href=\"https://www.luogu.com.cn/problem/P1164\">P1164 小A点菜</a></h2><p>又想dfs了，但是肯定tle。<br>应该是dp吧，找一下递推的关系式。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">int</span> m,n;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class=\"hljs-type\">int</span> f[n][<span class=\"hljs-number\">10010</span>];<br>    <span class=\"hljs-type\">int</span> a[n];<br>    <span class=\"hljs-built_in\">memset</span>(f, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(f));<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)  <br>    &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    f[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>    f[<span class=\"hljs-number\">0</span>][a[<span class=\"hljs-number\">0</span>]]=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;=m;j++)<br>        &#123;<br>            f[i][j] = f[i<span class=\"hljs-number\">-1</span>][j];<br>            <span class=\"hljs-keyword\">if</span> (j&gt;=a[i]) f[i][j]+=f[i<span class=\"hljs-number\">-1</span>][j-a[i]];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n<span class=\"hljs-number\">-1</span>][m];<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>有点魂不守舍了，写了一堆低级错误</p>\n<hr>\n"},{"title":"digui1","date":"2025-11-06T06:54:16.000Z","cover":"/images/oi_cover.jpg","_content":"昨晚再写了点题，还是没有什么思路。。。  \ngemini提示我：先明确函数目的，找到终止条件，然后信仰之跃。  \n今天再做些题,找找感觉。  \n~~不过近纲坐在第一排用电脑真的好吗~~\n\n---\n## [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)  \n\n我真不行了怎么这么难。  \n\n问题就是怎么想出这个状态转移方程。  \n\n可以看下这篇[题解](https://www.luogu.com.cn/article/3bzlgs8u)。\n\n也就是说，如果不行的话，可以写一个辅助dp来辅助计算。  \n\n我草我放弃了，这玩意不是给人学的，先学点别的。\n\n","source":"_posts/digui1.md","raw":"---\ntitle: digui1\ndate: 2025-11-06 14:54:16\ntags:\ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n昨晚再写了点题，还是没有什么思路。。。  \ngemini提示我：先明确函数目的，找到终止条件，然后信仰之跃。  \n今天再做些题,找找感觉。  \n~~不过近纲坐在第一排用电脑真的好吗~~\n\n---\n## [P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)  \n\n我真不行了怎么这么难。  \n\n问题就是怎么想出这个状态转移方程。  \n\n可以看下这篇[题解](https://www.luogu.com.cn/article/3bzlgs8u)。\n\n也就是说，如果不行的话，可以写一个辅助dp来辅助计算。  \n\n我草我放弃了，这玩意不是给人学的，先学点别的。\n\n","slug":"digui1","published":1,"updated":"2025-11-16T08:22:08.354Z","comments":1,"layout":"post","photos":[],"_id":"cuid2Z_LqxZo6ny3lyNcLe6L7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>昨晚再写了点题，还是没有什么思路。。。<br>gemini提示我：先明确函数目的，找到终止条件，然后信仰之跃。<br>今天再做些题,找找感觉。<br><del>不过近纲坐在第一排用电脑真的好吗</del></p>\n<hr>\n<h2><span id=\"p1990-%E8%A6%86%E7%9B%96%E5%A2%99%E5%A3%81\"></span></h2><p>我真不行了怎么这么难。  </p>\n<p>问题就是怎么想出这个状态转移方程。  </p>\n<p>可以看下这篇<a href=\"https://www.luogu.com.cn/article/3bzlgs8u\">题解</a>。</p>\n<p>也就是说，如果不行的话，可以写一个辅助dp来辅助计算。  </p>\n<p>我草我放弃了，这玩意不是给人学的，先学点别的。</p>\n</body></html>","excerpt":"","more":"<p>昨晚再写了点题，还是没有什么思路。。。<br>gemini提示我：先明确函数目的，找到终止条件，然后信仰之跃。<br>今天再做些题,找找感觉。<br><del>不过近纲坐在第一排用电脑真的好吗</del></p>\n<hr>\n<h2 id=\"P1990-覆盖墙壁\"><a href=\"#P1990-覆盖墙壁\" class=\"headerlink\" title=\"P1990 覆盖墙壁\"></a><a href=\"https://www.luogu.com.cn/problem/P1990\">P1990 覆盖墙壁</a></h2><p>我真不行了怎么这么难。  </p>\n<p>问题就是怎么想出这个状态转移方程。  </p>\n<p>可以看下这篇<a href=\"https://www.luogu.com.cn/article/3bzlgs8u\">题解</a>。</p>\n<p>也就是说，如果不行的话，可以写一个辅助dp来辅助计算。  </p>\n<p>我草我放弃了，这玩意不是给人学的，先学点别的。</p>\n"},{"title":"笔记简介","date":"2025-11-05T07:12:57.000Z","cover":"/images/oi_cover.jpg","_content":"## 为什么要写这个笔记\n在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。\n\n## 我会在笔记中记录什么\n* 我做的题目，解题思路，每次错误的版本，错误的原因。\n\n* 算法的解析，ai的解释，我的思考。\n\n* 我的心路历程\n\n* 一些碎碎念\n\n> 准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。  \n希望能和在记录过程中不断进步。\n---\n目前的想法是利用[洛谷题单](https://www.luogu.com.cn/training/list)，洛谷编的书逐步学习。\n\n那么就开始吧。","source":"_posts/oi-note-description.md","raw":"---\ntitle: 笔记简介\ndate: 2025-11-05 15:12:57\ntags: \ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n## 为什么要写这个笔记\n在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。\n\n## 我会在笔记中记录什么\n* 我做的题目，解题思路，每次错误的版本，错误的原因。\n\n* 算法的解析，ai的解释，我的思考。\n\n* 我的心路历程\n\n* 一些碎碎念\n\n> 准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。  \n希望能和在记录过程中不断进步。\n---\n目前的想法是利用[洛谷题单](https://www.luogu.com.cn/training/list)，洛谷编的书逐步学习。\n\n那么就开始吧。","slug":"oi-note-description","published":1,"updated":"2025-11-08T09:45:22.482Z","comments":1,"layout":"post","photos":[],"_id":"cuid1aivnn5X1TqaJH-0qiLSa","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E8%BF%99%E4%B8%AA%E7%AC%94%E8%AE%B0\">为什么要写这个笔记</span></h2><p>在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。</p>\n<h2><span id=\"%E6%88%91%E4%BC%9A%E5%9C%A8%E7%AC%94%E8%AE%B0%E4%B8%AD%E8%AE%B0%E5%BD%95%E4%BB%80%E4%B9%88\">我会在笔记中记录什么</span></h2><ul>\n<li><p>我做的题目，解题思路，每次错误的版本，错误的原因。</p>\n</li>\n<li><p>算法的解析，ai的解释，我的思考。</p>\n</li>\n<li><p>我的心路历程</p>\n</li>\n<li><p>一些碎碎念</p>\n</li>\n</ul>\n<blockquote>\n<p>准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。<br>希望能和在记录过程中不断进步。</p>\n</blockquote>\n<hr>\n<p>目前的想法是利用<a href=\"https://www.luogu.com.cn/training/list\">洛谷题单</a>，洛谷编的书逐步学习。</p>\n<p>那么就开始吧。</p>\n</body></html>","excerpt":"","more":"<h2 id=\"为什么要写这个笔记\"><a href=\"#为什么要写这个笔记\" class=\"headerlink\" title=\"为什么要写这个笔记\"></a>为什么要写这个笔记</h2><p>在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。</p>\n<h2 id=\"我会在笔记中记录什么\"><a href=\"#我会在笔记中记录什么\" class=\"headerlink\" title=\"我会在笔记中记录什么\"></a>我会在笔记中记录什么</h2><ul>\n<li><p>我做的题目，解题思路，每次错误的版本，错误的原因。</p>\n</li>\n<li><p>算法的解析，ai的解释，我的思考。</p>\n</li>\n<li><p>我的心路历程</p>\n</li>\n<li><p>一些碎碎念</p>\n</li>\n</ul>\n<blockquote>\n<p>准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。<br>希望能和在记录过程中不断进步。</p>\n</blockquote>\n<hr>\n<p>目前的想法是利用<a href=\"https://www.luogu.com.cn/training/list\">洛谷题单</a>，洛谷编的书逐步学习。</p>\n<p>那么就开始吧。</p>\n"},{"title":"高精度&排序","date":"2025-11-05T07:28:03.000Z","cover":"/images/oi_cover.jpg","_content":"## 高精度\n在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。\n\n高精度加法比较简单，将数组反转处理，将进位临时储存，*需注意算法结束后还要验证最后进位是否为0*。\n\n---\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nstring add(string a, string b)\n{\n    int len = max(a.size(), b.size()), jw = 0;\n    string c = \"\";\n    while (a.size() < len) a = '0' + a;\n    while (b.size() < len) b = '0' + b;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        int t1 = a[i] - '0', t2 = b[i] - '0';\n        int t = t1 + t2 + jw;\n        jw = t / 10;\n        t %= 10;\n        char ch = t + '0';\n        c = ch + c;\n    }\n    if (jw != 0) return '1' + c;\n    return c;\n}\nsigned main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tcout << add(s1, s2);\n    return 0;\n}\n```\n\n---\n发现自己高精度乘法解释不清楚，这个[高精度乘法](https://www.luogu.com.cn/article/pxfpoeoi)题解写的很好，可以参考下。\n\n---\n然后我发现[p1009](https://www.luogu.com.cn/problem/P1009)不会做。  \n不是这高精算法怎么这么智障。  \n~~于是我决定跳过，之后再看。~~  \n还是看完了，其实并不难，题解写的很傻逼。\n需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n//高精度加法s1 s2 result均为倒叙储存\nvector<int> add(vector<int> &s1,vector<int> &s2)\n{\n    vector<int> c;\n    int len = max(s1.size(),s2.size());\n    int temp=0;\n    for (int i=0;i<len;i++)\n    {\n        int a,b;\n        a=(i<s1.size())?s1[i] : 0;\n        b=(i<s2.size())?s2[i] : 0;\n        c.push_back((a+b+temp)%10);\n        temp=(a+b+temp)/10;\n    }\n    if (temp>0) c.push_back(temp);\n    return c;\n}\n//高精度乘以低精度乘法\nvector<int> mul(vector<int>& a, int b) {\n    vector<int> c;\n    int temp = 0;\n    for (int i = 0; i < a.size(); i++) {\n        temp += a[i] * b;      \n        c.push_back(temp % 10); \n        temp /= 10;            \n    }\n    while (temp) {\n        c.push_back(temp % 10);\n        temp /= 10;\n    }\n    if (c.empty()) {\n        c.push_back(0);\n    }\n    return c;\n}\n\n//主函数调用\nint main ()\n{\n    int n;\n    cin>>n;\n    vector<int> sum = {0}; \n    vector<int> term = {1};\n    for(int i=1;i<=n;i++)\n    {\n        term = mul(term,i);\n        sum = add(sum,term);\n    }\n    for (int i = sum.size() - 1; i >= 0; i--) {\n        cout << sum[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n第一版代码编译错误。  \n***我是不是有病***  \n错误在s1.[i]，和结构体搞混了。  \n改好了就过了\n\n\n好我们开始学习排序；\n\n---\n\n## 排序\n\n### 计数排序\n\n[P1271 【深基9.例1】选举学生会](https://www.luogu.com.cn/problem/P1271)，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  \n\n计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  \n\n~~比较简单，且时间复杂度很高，感觉没什么用，下一个。~~  \n\n[oiwiki](https://oi-wiki.org/basic/counting-sort/)上写了要计算前缀和，我并不太理解，接下来是gemini的解释：\n\n---\n> 这是一个非常好的问题！“前缀和”这一步是计数排序**从一个简单的“计数”算法变成一个强大的“排序”算法**的关键。\n>\n> 简单来说，前缀和的核心作用是：**把“计数”转变为“最终位置”**。\n>\n> 它解决了两个问题：\n> 1.  **定位问题**：知道有3个“5”，但我该把它们放在输出数组的哪个**具体索引**上？\n> 2.  **稳定性问题**：如果原始数组中有两个“5”（比如一个是 `(5, 'a')`，一个是 `(5, 'b')`），如何保证排序后它们的相对顺序不变？\n>\n> ### 1. 如果没有前缀和（朴素想法）\n>\n> 我们先看看，如果**只有**第一步“计算每个数出现了几次”，我们会怎么做。\n>\n> 假设待排序数组 `A = {1, 4, 1, 2, 4, 3, 1}`\n>\n> **步骤 1：计数**\n> 我们得到一个“计数数组” `C`：\n> * `C[1] = 3` (有 3 个 '1')\n> * `C[2] = 1` (有 1 个 '2')\n> * `C[3] = 1` (有 1 个 '3')\n> * `C[4] = 2` (有 2 个 '4')\n>\n> **朴素的“排序”：**\n> 我们可以遍历 `C` 数组，然后直接重写 `A`：\n> * 看到 `C[1] = 3`，就在 `A` 里写 3 个 '1'：`A = {1, 1, 1, ...}`\n> * 看到 `C[2] = 1`，接着写 1 个 '2'：`A = {1, 1, 1, 2, ...}`\n> * ...\n> * 最终得到 `A = {1, 1, 1, 2, 3, 4, 4}`\n>\n> **问题所在：**\n> 这确实排序了。但是，如果我们的 `A` 数组存的不是简单的数字，而是**对象**呢？\n> 比如 `A = {(1, 'a'), (4, 'b'), (1, 'c'), (4, 'd'), (1, 'e')}`\n> 我们的 `C` 数组还是一样：`C[1]=3`，`C[4]=2`。\n> 如果用朴素方法，我们只会得到 `{1, 1, 1, 4, 4}`。我们完全**丢失了 'a', 'b', 'c', 'd', 'e' 这些附加信息**。\n>\n> 我们需要的不是“覆盖”原数组，而是把原数组中的**每一个元素**，**“搬运”** 到一个新数组（或最终位置）的正确索引上。\n>\n> ### 2. 前缀和的作用：计算“位置边界”\n>\n> 前缀和就是用来计算这个“搬运”目标的。\n>\n> 我们换一个例子：`A = {2, 5, 3, 0, 2, 3, 0, 3}`\n>\n> **步骤 1：计数**\n> `C` 数组 (索引 0 到 5):\n> * `C[0] = 2` (2 个 '0')\n> * `C[1] = 0` (0 个 '1')\n> * `C[2] = 2` (2 个 '2')\n> * `C[3] = 3` (3 个 '3')\n> * `C[4] = 0` (0 个 '4')\n> * `C[5] = 1` (1 个 '5')\n> * 数组 `C`：`{2, 0, 2, 3, 0, 1}`\n>\n> **步骤 2：计算前缀和**\n> 我们对 `C` 数组进行累加：\n> * `C[0] = 2`\n> * `C[1] = C[1] + C[0] = 0 + 2 = 2`\n> * `C[2] = C[2] + C[1] = 2 + 2 = 4`\n> * `C[3] = C[3] + C[2] = 3 + 4 = 7`\n> * `C[4] = C[4] + C[3] = 0 + 7 = 7`\n> * `C[5] = C[5] + C[4] = 1 + 7 = 8`\n> * 数组 `C`（前缀和）：`{2, 2, 4, 7, 7, 8}`\n>\n> **现在，这个前缀和数组 `C` 的含义**变得非常重要：\n> `C[i]` 的值 = 原始数组中 **小于或等于 `i`** 的元素总个数。\n>\n> * `C[0] = 2`：有 2 个元素 $\\le 0$。\n> * `C[2] = 4`：有 4 个元素 $\\le 2$ (即 '0' 和 '2')。\n> * `C[3] = 7`：有 7 个元素 $\\le 3$ (即 '0', '2' 和 '3')。\n> * `C[5] = 8`：有 8 个元素 $\\le 5$ (即所有元素)。\n>\n> **这就是关键点！**\n> > 如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 '2' 应该放在**第 4 位**。\n> >\n> > 如果有 7 个元素小于或等于 3，那么最后一个 '3' 应该放在**第 7 位**。\n>\n> **`C[i]` 现在直接告诉了我们：值 `i` 的元素在排序后，最后一个应该放的“坑位”是第 `C[i]` 个。**\n>\n> ### 3. 步骤 3：利用前缀和（从后往前）放置元素\n>\n> 我们准备一个和 `A` 一样大的空数组 `B` (大小为 8)。\n> 我们**从右至左**（从后往前）遍历原始数组 `A`。\n>\n> `A = {2, 5, 3, 0, 2, 3, 0, 3}`\n> `C = {2, 2, 4, 7, 7, 8}` (前缀和)\n> `B = {_, _, _, _, _, _, _, _}`\n>\n> 1.  **遍历 `A[7] = 3`**\n>     * 查找 `C[3]`，值为 `7`。\n>     * 这告诉我们：'3' 应该放在第 7 个位置（即 0-based 索引的 `7-1 = 6`）。\n>     * `B[6] = 3`。\n>     * **重要**：我们用掉了一个 '3' 的位置，所以 `C[3]` 减 1。`C[3]` 变为 `6`。\n>     * `B`：`{_, _, _, _, _, _, 3, _}`\n>\n> 2.  **遍历 `A[6] = 0`**\n>     * 查找 `C[0]`，值为 `2`。\n>     * 位置：`2-1 = 1`。\n>     * `B[1] = 0`。\n>     * `C[0]` 减 1，变为 `1`。\n>     * `B`：`{_, 0, _, _, _, _, 3, _}`\n>\n> 3.  **遍历 `A[5] = 3`** (这是第二个 '3')\n>     * 查找 `C[3]`，值现在是 `6` (上次用过 '3' 后减 1 了)。\n>     * 位置：`6-1 = 5`。\n>     * `B[5] = 3`。\n>     * `C[3]` 减 1，变为 `5`。\n>     * `B`：`{_, 0, _, _, _, 3, 3, _}`\n>\n> 4.  **遍历 `A[4] = 2`**\n>     * 查找 `C[2]`，值为 `4`。\n>     * 位置：`4-1 = 3`。\n>     * `B[3] = 2`。\n>     * `C[2]` 减 1，变为 `3`。\n>     * `B`：`{_, 0, _, 2, _, 3, 3, _}`\n>\n> ... 以此类推，直到 `A[0]`。\n>\n> 5.  **遍历 `A[2] = 3`** (这是第一个 '3')\n>     * 查找 `C[3]`，值现在是 `5`。\n>     * 位置：`5-1 = 4`。\n>     * `B[4] = 3`。\n>     * `C[3]` 减 1，变为 `4`。\n>     * `B`：`{_, 0, _, 2, 3, 3, 3, _}`\n>\n> 最后我们会得到 `B = {0, 0, 2, 2, 3, 3, 3, 5}`，排序完成。\n>\n> ### 总结\n>\n> 前缀和是计数排序的灵魂，它完成了两个核心任务：\n>\n> 1.  **精确**\n>     **定位**：`C[i]` 从“`i` 的个数”转变成了“小于等于 `i` 的总数”，这个总数**直接映射**到了排序后数组的**索引（位置）**。\n> 2.  **保证稳定性**：通过**从后往前**遍历原数组 `A`，并结合 `C[i]--` 操作，我们确保了：\n>     * 原数组中**靠后**的重复元素，会先被放入新数组中**靠后**的“坑位”。\n>     * 原数组中**靠前**的重复元素，会后被放入新数组中**靠前**的“坑位”。\n>     * 从而保持了它们的相对顺序不变（即“稳定性”）。\n---\n我理解了什么意思了，但是怎么这么繁琐。。。  \n我可能之后还是不记得这个**前缀和**怎么用，不过至少了解了，先写个代码熟悉一下。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> count_sort(vector<int> &s1,int n)//需要输入的数组，里面的最大数（默认从0开始排序）\n{   \n    vector<int> c (n+1,0);//初始化计数数组；\n    //遍历计数\n    int leng=s1.size();\n    for (int i=0;i<leng;i++) c[s1[i]]++;\n    //计算前缀和；\n    for (int i=1;i<n+1;i++) c[i]+=c[i-1];\n    //将c数组里的每一个数替换成前缀和\n    \n    //定义输出数组\n    vector<int> result(leng);\n    //利用前缀和（从后往前）放置元素\n    for (int i = leng-1;i>=0;--i)\n    {\n        int num = s1[i];//查找第i元素\n        int postion=c[num]-1;//查找这个元素应该放在第几个位置\n        /*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个\n        那么这个数减一就是应该放在结果数组的位置\n        */\n        result[postion]=num;\n        c[num]--;//用掉了一个数，应该减一\n\n    }\n    return result;\n\n}\n```\n\n\n### 选择排序\n\n[oi wiki的选择排序](https://oi-wiki.org/basic/selection-sort/)解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  \n\n```cpp\n#include <utility>\n\nvoid selection_sort(int* a, int n) {\n  for (int i = 1; i < n; ++i) {\n    int ith = i;\n    for (int j = i + 1; j <= n; ++j) {\n      if (a[j] < a[ith]) {\n        ith = j;\n      }\n    }\n    std::swap(a[i], a[ith]);\n  }\n}\n```\n如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。\n本质上是打擂台，找到最小的数字，排在最前面。\n\n### 冒泡排序\n这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。  \n当不再发生交换的时候，排序完成。 \n```cpp\nvoid bubble_sort (int *a,int n)\n{\n    bool switched = true;//switched表示上一轮是否交换\n    /*这是个断终止的方法，只要上一轮没有交换说明排序结束*/\n    while (switched)\n    {\n        switched = false;\n        for(int i=0;i<n-1;++i)//注意数组越界问题，应当要再减一\n        {\n            if (a[i] > a[i + 1]) \n            {\n                switched = true;\n                swap(a[i],a[i+1]);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。\n>可数组的插入不是很复杂的吗？？\n\n代码实现如下\n\n```cpp\nvoid insertion_sort(int arr[], int len) {\n  for (int i = 1; i < len; ++i) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n}\n```\n这是gemini的解释，我觉得很形象\n\n---\n> 它的核心思想是模拟我们**玩扑克牌时整理手牌**的动作。\n>\n> ### 🃏 插入排序的核心比喻 (整理手牌)\n>\n> 想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（`key`）。\n>\n> 你会怎么做？\n>\n> 1.  你从左手中**最右边**的牌（`j`）开始，和你的新牌（`key`）比较。\n> 2.  如果左手的牌（`arr[j]`）比你的新牌（`key`）大，你就把这张牌**往右移一个位置**（`arr[j + 1] = arr[j]`），腾出它原来的空位。\n> 3.  你继续看左手边下一张牌（`j--`），重复这个比较。\n> 4.  直到你找到一张比新牌（`key`）小的牌，或者你已经比较完了所有手里的牌 ( `j < 0` )。\n> 5.  这时，你找到了正确的位置，把你手里的新牌（`key`）**插入**到刚刚腾出来的那个空位上（`arr[j + 1] = key`）。\n---\n如果基本有序，就可以使用这个插入算法。  \n\n>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。\n\n***至少下一个排序很有用***\n\n## 快速排序\n[洛谷P1177](https://www.luogu.com.cn/problem/P1177)就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  \n\n不行了这个gemini讲的太好了,我直接复制就行\n\n---\n\n\n您可以把快速排序想象成一个“**不断找人站队**”的过程。\n\n\n### 快速排序的核心思想\n\n正如您资料中提到的，它的核心是 **“分治”（Divide and Conquer）**。\n\n简单来说，就是：\n\n1.  **找一个“基准” (Pivot)：** 在队伍里（数组中）随便挑一个人（一个数）当“基准”。\n2.  **站队 (Partition)：** 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。\n3.  **分而治之 (Recurse)：** 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别**重复**第1步和第2步。\n4.  **完成：** 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。\n\n-----\n\n### 详细解释您提供的 C++ 代码\n\n您提供的代码是实现这个过程的经典方法。我们一步一步来看：\n\n#### 1\\. `Partition` 函数（最关键的“站队”过程）\n\n这个函数的目标是：**选定一个基准，并完成“站队”**。\n\n```c++\ntemplate <typename T>\nint Partition(T A[], int low, int high) {//这里low是排序的第一个指针， high是最后一个指针\n  int pivot = A[low]; // 1. 选择基准：就选第一个元素当基准 (pivot)\n                      //    此时 A[low] 这个位置可以看成一个“坑”\n\n  while (low < high) { // 2. 只要左右指针没相遇，就继续\n    \n    // 3. 从右往左找“小”的\n    while (low < high && pivot <= A[high]) --high; \n    A[low] = A[high]; // 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”\n\n    // 5. 从左往右找“大”的\n    while (low < high && A[low] <= pivot) ++low; \n    A[high] = A[low]; // 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”\n  }\n  \n  // 7. 循环结束，low 和 high 相遇了\n  A[low] = pivot; // 8. 把一开始存的基准值，放回这个最后的“坑”\n  return low;     // 9. 返回基准最后站的位置\n}\n```\n\n**用一个例子来模拟 `Partition`：**\n假设数组是 `[5, 2, 8, 1, 9, 4]`，`low = 0`, `high = 5`。\n\n1.  `pivot = A[low]`，`pivot` 存了 **5**。 `A[0]` 现在是“坑”。\n    数组：`[坑, 2, 8, 1, 9, 4]`\n2.  **从右往左**（`high` 从 5 开始）找比 5 小的。\n      * `A[5]` 是 4。比 5 小。\n3.  把 4 扔到左边的“坑” (`A[low]` 即 `A[0]`)。`A[5]` 变成新“坑”。\n    数组：`[4, 2, 8, 1, 9, 坑]`\n4.  **从左往右**（`low` 从 0 开始）找比 5 大的。\n      * `A[0]` 是 4。\n      * `A[1]` 是 2。\n      * `A[2]` 是 8。比 5 大。\n5.  把 8 扔到右边的“坑” (`A[high]` 即 `A[5]`)。`A[2]` 变成新“坑”。\n    数组：`[4, 2, 坑, 1, 9, 8]`\n6.  **从右往左**（`high` 从 5 开始）...\n      * ... `A[4]` 是 9。\n      * `A[3]` 是 1。比 5 小。\n7.  把 1 扔到左边的“坑” (`A[low]` 即 `A[2]`)。`A[3]` 变成新“坑”。\n    数组：`[4, 2, 1, 坑, 9, 8]`\n8.  **从左往右**（`low` 从 2 开始）...\n      * `A[2]` 是 1。\n      * `A[3]`... `low` 和 `high` 在 3 这个位置相遇了。循环 `while (low < high)` 结束。\n9.  把 `pivot` (存的 **5**) 放到 `A[low]` (即 `A[3]`)。\n    数组：`[4, 2, 1, 5, 9, 8]`\n10. 返回 `low` (即 3)。\n\n**看，现在数组变成了 `[4, 2, 1]` （都比5小） | `5` | `[9, 8]` （都比5大）。** 这就是“站队”！\n\n-----\n\n#### 2\\. `QuickSort` 函数（“分而治之”的递归）\n\n这个函数是“分治”思想的体现，它来“指挥”`Partition`。\n\n```c++\ntemplate <typename T>\nvoid QuickSort(T A[], int low, int high) {\n  if (low < high) { // 如果队伍里至少有2个人\n    // 1. 先站队，并拿到基准最后的位置\n    int pivot_pos = Partition(A, low, high); \n    \n    // 2. 指挥“左队”去递归排序\n    QuickSort(A, low, pivot_pos - 1); \n    \n    // 3. 指挥“右队”去递归排序\n    QuickSort(A, pivot + 1, high); \n  }\n  // 如果 low >= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。\n}\n```\n\n### 总结\n\n1.  `QuickSort` 函数是**宏观管理者**：它负责“分”，决定对哪一段（从 `low` 到 `high`）进行排序。\n2.  `Partition` 函数是**具体执行者**：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。\n3.  通过**递归**，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。\n\n您提供的资料中提到“不用合并”，就是因为 `Partition` 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。\n\n---\n后面还有[优化算法](https://oi-wiki.org/basic/quick-sort/)，我真不想看了，之后有空再看。\n\n## 归并排序\n我草怎么还有。。。\n直接放[归并](https://oi-wiki.org/basic/merge-sort/)的链接吧\n\n\n## 总结\n其实还有sort函数，要写一个函数作为排序的算法。  \n我感觉我这样学习效率很低，应该做题，不会的再去查概念。  \n先去吃个饭，等下学递归的时候改一下学习方法。","source":"_posts/paixu1.md","raw":"---\ntitle: 高精度&排序\ndate: 2025-11-05 15:28:03\ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n## 高精度\n在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。\n\n高精度加法比较简单，将数组反转处理，将进位临时储存，*需注意算法结束后还要验证最后进位是否为0*。\n\n---\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nstring add(string a, string b)\n{\n    int len = max(a.size(), b.size()), jw = 0;\n    string c = \"\";\n    while (a.size() < len) a = '0' + a;\n    while (b.size() < len) b = '0' + b;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        int t1 = a[i] - '0', t2 = b[i] - '0';\n        int t = t1 + t2 + jw;\n        jw = t / 10;\n        t %= 10;\n        char ch = t + '0';\n        c = ch + c;\n    }\n    if (jw != 0) return '1' + c;\n    return c;\n}\nsigned main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tcout << add(s1, s2);\n    return 0;\n}\n```\n\n---\n发现自己高精度乘法解释不清楚，这个[高精度乘法](https://www.luogu.com.cn/article/pxfpoeoi)题解写的很好，可以参考下。\n\n---\n然后我发现[p1009](https://www.luogu.com.cn/problem/P1009)不会做。  \n不是这高精算法怎么这么智障。  \n~~于是我决定跳过，之后再看。~~  \n还是看完了，其实并不难，题解写的很傻逼。\n需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n//高精度加法s1 s2 result均为倒叙储存\nvector<int> add(vector<int> &s1,vector<int> &s2)\n{\n    vector<int> c;\n    int len = max(s1.size(),s2.size());\n    int temp=0;\n    for (int i=0;i<len;i++)\n    {\n        int a,b;\n        a=(i<s1.size())?s1[i] : 0;\n        b=(i<s2.size())?s2[i] : 0;\n        c.push_back((a+b+temp)%10);\n        temp=(a+b+temp)/10;\n    }\n    if (temp>0) c.push_back(temp);\n    return c;\n}\n//高精度乘以低精度乘法\nvector<int> mul(vector<int>& a, int b) {\n    vector<int> c;\n    int temp = 0;\n    for (int i = 0; i < a.size(); i++) {\n        temp += a[i] * b;      \n        c.push_back(temp % 10); \n        temp /= 10;            \n    }\n    while (temp) {\n        c.push_back(temp % 10);\n        temp /= 10;\n    }\n    if (c.empty()) {\n        c.push_back(0);\n    }\n    return c;\n}\n\n//主函数调用\nint main ()\n{\n    int n;\n    cin>>n;\n    vector<int> sum = {0}; \n    vector<int> term = {1};\n    for(int i=1;i<=n;i++)\n    {\n        term = mul(term,i);\n        sum = add(sum,term);\n    }\n    for (int i = sum.size() - 1; i >= 0; i--) {\n        cout << sum[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n第一版代码编译错误。  \n***我是不是有病***  \n错误在s1.[i]，和结构体搞混了。  \n改好了就过了\n\n\n好我们开始学习排序；\n\n---\n\n## 排序\n\n### 计数排序\n\n[P1271 【深基9.例1】选举学生会](https://www.luogu.com.cn/problem/P1271)，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  \n\n计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  \n\n~~比较简单，且时间复杂度很高，感觉没什么用，下一个。~~  \n\n[oiwiki](https://oi-wiki.org/basic/counting-sort/)上写了要计算前缀和，我并不太理解，接下来是gemini的解释：\n\n---\n> 这是一个非常好的问题！“前缀和”这一步是计数排序**从一个简单的“计数”算法变成一个强大的“排序”算法**的关键。\n>\n> 简单来说，前缀和的核心作用是：**把“计数”转变为“最终位置”**。\n>\n> 它解决了两个问题：\n> 1.  **定位问题**：知道有3个“5”，但我该把它们放在输出数组的哪个**具体索引**上？\n> 2.  **稳定性问题**：如果原始数组中有两个“5”（比如一个是 `(5, 'a')`，一个是 `(5, 'b')`），如何保证排序后它们的相对顺序不变？\n>\n> ### 1. 如果没有前缀和（朴素想法）\n>\n> 我们先看看，如果**只有**第一步“计算每个数出现了几次”，我们会怎么做。\n>\n> 假设待排序数组 `A = {1, 4, 1, 2, 4, 3, 1}`\n>\n> **步骤 1：计数**\n> 我们得到一个“计数数组” `C`：\n> * `C[1] = 3` (有 3 个 '1')\n> * `C[2] = 1` (有 1 个 '2')\n> * `C[3] = 1` (有 1 个 '3')\n> * `C[4] = 2` (有 2 个 '4')\n>\n> **朴素的“排序”：**\n> 我们可以遍历 `C` 数组，然后直接重写 `A`：\n> * 看到 `C[1] = 3`，就在 `A` 里写 3 个 '1'：`A = {1, 1, 1, ...}`\n> * 看到 `C[2] = 1`，接着写 1 个 '2'：`A = {1, 1, 1, 2, ...}`\n> * ...\n> * 最终得到 `A = {1, 1, 1, 2, 3, 4, 4}`\n>\n> **问题所在：**\n> 这确实排序了。但是，如果我们的 `A` 数组存的不是简单的数字，而是**对象**呢？\n> 比如 `A = {(1, 'a'), (4, 'b'), (1, 'c'), (4, 'd'), (1, 'e')}`\n> 我们的 `C` 数组还是一样：`C[1]=3`，`C[4]=2`。\n> 如果用朴素方法，我们只会得到 `{1, 1, 1, 4, 4}`。我们完全**丢失了 'a', 'b', 'c', 'd', 'e' 这些附加信息**。\n>\n> 我们需要的不是“覆盖”原数组，而是把原数组中的**每一个元素**，**“搬运”** 到一个新数组（或最终位置）的正确索引上。\n>\n> ### 2. 前缀和的作用：计算“位置边界”\n>\n> 前缀和就是用来计算这个“搬运”目标的。\n>\n> 我们换一个例子：`A = {2, 5, 3, 0, 2, 3, 0, 3}`\n>\n> **步骤 1：计数**\n> `C` 数组 (索引 0 到 5):\n> * `C[0] = 2` (2 个 '0')\n> * `C[1] = 0` (0 个 '1')\n> * `C[2] = 2` (2 个 '2')\n> * `C[3] = 3` (3 个 '3')\n> * `C[4] = 0` (0 个 '4')\n> * `C[5] = 1` (1 个 '5')\n> * 数组 `C`：`{2, 0, 2, 3, 0, 1}`\n>\n> **步骤 2：计算前缀和**\n> 我们对 `C` 数组进行累加：\n> * `C[0] = 2`\n> * `C[1] = C[1] + C[0] = 0 + 2 = 2`\n> * `C[2] = C[2] + C[1] = 2 + 2 = 4`\n> * `C[3] = C[3] + C[2] = 3 + 4 = 7`\n> * `C[4] = C[4] + C[3] = 0 + 7 = 7`\n> * `C[5] = C[5] + C[4] = 1 + 7 = 8`\n> * 数组 `C`（前缀和）：`{2, 2, 4, 7, 7, 8}`\n>\n> **现在，这个前缀和数组 `C` 的含义**变得非常重要：\n> `C[i]` 的值 = 原始数组中 **小于或等于 `i`** 的元素总个数。\n>\n> * `C[0] = 2`：有 2 个元素 $\\le 0$。\n> * `C[2] = 4`：有 4 个元素 $\\le 2$ (即 '0' 和 '2')。\n> * `C[3] = 7`：有 7 个元素 $\\le 3$ (即 '0', '2' 和 '3')。\n> * `C[5] = 8`：有 8 个元素 $\\le 5$ (即所有元素)。\n>\n> **这就是关键点！**\n> > 如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 '2' 应该放在**第 4 位**。\n> >\n> > 如果有 7 个元素小于或等于 3，那么最后一个 '3' 应该放在**第 7 位**。\n>\n> **`C[i]` 现在直接告诉了我们：值 `i` 的元素在排序后，最后一个应该放的“坑位”是第 `C[i]` 个。**\n>\n> ### 3. 步骤 3：利用前缀和（从后往前）放置元素\n>\n> 我们准备一个和 `A` 一样大的空数组 `B` (大小为 8)。\n> 我们**从右至左**（从后往前）遍历原始数组 `A`。\n>\n> `A = {2, 5, 3, 0, 2, 3, 0, 3}`\n> `C = {2, 2, 4, 7, 7, 8}` (前缀和)\n> `B = {_, _, _, _, _, _, _, _}`\n>\n> 1.  **遍历 `A[7] = 3`**\n>     * 查找 `C[3]`，值为 `7`。\n>     * 这告诉我们：'3' 应该放在第 7 个位置（即 0-based 索引的 `7-1 = 6`）。\n>     * `B[6] = 3`。\n>     * **重要**：我们用掉了一个 '3' 的位置，所以 `C[3]` 减 1。`C[3]` 变为 `6`。\n>     * `B`：`{_, _, _, _, _, _, 3, _}`\n>\n> 2.  **遍历 `A[6] = 0`**\n>     * 查找 `C[0]`，值为 `2`。\n>     * 位置：`2-1 = 1`。\n>     * `B[1] = 0`。\n>     * `C[0]` 减 1，变为 `1`。\n>     * `B`：`{_, 0, _, _, _, _, 3, _}`\n>\n> 3.  **遍历 `A[5] = 3`** (这是第二个 '3')\n>     * 查找 `C[3]`，值现在是 `6` (上次用过 '3' 后减 1 了)。\n>     * 位置：`6-1 = 5`。\n>     * `B[5] = 3`。\n>     * `C[3]` 减 1，变为 `5`。\n>     * `B`：`{_, 0, _, _, _, 3, 3, _}`\n>\n> 4.  **遍历 `A[4] = 2`**\n>     * 查找 `C[2]`，值为 `4`。\n>     * 位置：`4-1 = 3`。\n>     * `B[3] = 2`。\n>     * `C[2]` 减 1，变为 `3`。\n>     * `B`：`{_, 0, _, 2, _, 3, 3, _}`\n>\n> ... 以此类推，直到 `A[0]`。\n>\n> 5.  **遍历 `A[2] = 3`** (这是第一个 '3')\n>     * 查找 `C[3]`，值现在是 `5`。\n>     * 位置：`5-1 = 4`。\n>     * `B[4] = 3`。\n>     * `C[3]` 减 1，变为 `4`。\n>     * `B`：`{_, 0, _, 2, 3, 3, 3, _}`\n>\n> 最后我们会得到 `B = {0, 0, 2, 2, 3, 3, 3, 5}`，排序完成。\n>\n> ### 总结\n>\n> 前缀和是计数排序的灵魂，它完成了两个核心任务：\n>\n> 1.  **精确**\n>     **定位**：`C[i]` 从“`i` 的个数”转变成了“小于等于 `i` 的总数”，这个总数**直接映射**到了排序后数组的**索引（位置）**。\n> 2.  **保证稳定性**：通过**从后往前**遍历原数组 `A`，并结合 `C[i]--` 操作，我们确保了：\n>     * 原数组中**靠后**的重复元素，会先被放入新数组中**靠后**的“坑位”。\n>     * 原数组中**靠前**的重复元素，会后被放入新数组中**靠前**的“坑位”。\n>     * 从而保持了它们的相对顺序不变（即“稳定性”）。\n---\n我理解了什么意思了，但是怎么这么繁琐。。。  \n我可能之后还是不记得这个**前缀和**怎么用，不过至少了解了，先写个代码熟悉一下。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> count_sort(vector<int> &s1,int n)//需要输入的数组，里面的最大数（默认从0开始排序）\n{   \n    vector<int> c (n+1,0);//初始化计数数组；\n    //遍历计数\n    int leng=s1.size();\n    for (int i=0;i<leng;i++) c[s1[i]]++;\n    //计算前缀和；\n    for (int i=1;i<n+1;i++) c[i]+=c[i-1];\n    //将c数组里的每一个数替换成前缀和\n    \n    //定义输出数组\n    vector<int> result(leng);\n    //利用前缀和（从后往前）放置元素\n    for (int i = leng-1;i>=0;--i)\n    {\n        int num = s1[i];//查找第i元素\n        int postion=c[num]-1;//查找这个元素应该放在第几个位置\n        /*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个\n        那么这个数减一就是应该放在结果数组的位置\n        */\n        result[postion]=num;\n        c[num]--;//用掉了一个数，应该减一\n\n    }\n    return result;\n\n}\n```\n\n\n### 选择排序\n\n[oi wiki的选择排序](https://oi-wiki.org/basic/selection-sort/)解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  \n\n```cpp\n#include <utility>\n\nvoid selection_sort(int* a, int n) {\n  for (int i = 1; i < n; ++i) {\n    int ith = i;\n    for (int j = i + 1; j <= n; ++j) {\n      if (a[j] < a[ith]) {\n        ith = j;\n      }\n    }\n    std::swap(a[i], a[ith]);\n  }\n}\n```\n如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。\n本质上是打擂台，找到最小的数字，排在最前面。\n\n### 冒泡排序\n这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。  \n当不再发生交换的时候，排序完成。 \n```cpp\nvoid bubble_sort (int *a,int n)\n{\n    bool switched = true;//switched表示上一轮是否交换\n    /*这是个断终止的方法，只要上一轮没有交换说明排序结束*/\n    while (switched)\n    {\n        switched = false;\n        for(int i=0;i<n-1;++i)//注意数组越界问题，应当要再减一\n        {\n            if (a[i] > a[i + 1]) \n            {\n                switched = true;\n                swap(a[i],a[i+1]);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。\n>可数组的插入不是很复杂的吗？？\n\n代码实现如下\n\n```cpp\nvoid insertion_sort(int arr[], int len) {\n  for (int i = 1; i < len; ++i) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n}\n```\n这是gemini的解释，我觉得很形象\n\n---\n> 它的核心思想是模拟我们**玩扑克牌时整理手牌**的动作。\n>\n> ### 🃏 插入排序的核心比喻 (整理手牌)\n>\n> 想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（`key`）。\n>\n> 你会怎么做？\n>\n> 1.  你从左手中**最右边**的牌（`j`）开始，和你的新牌（`key`）比较。\n> 2.  如果左手的牌（`arr[j]`）比你的新牌（`key`）大，你就把这张牌**往右移一个位置**（`arr[j + 1] = arr[j]`），腾出它原来的空位。\n> 3.  你继续看左手边下一张牌（`j--`），重复这个比较。\n> 4.  直到你找到一张比新牌（`key`）小的牌，或者你已经比较完了所有手里的牌 ( `j < 0` )。\n> 5.  这时，你找到了正确的位置，把你手里的新牌（`key`）**插入**到刚刚腾出来的那个空位上（`arr[j + 1] = key`）。\n---\n如果基本有序，就可以使用这个插入算法。  \n\n>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。\n\n***至少下一个排序很有用***\n\n## 快速排序\n[洛谷P1177](https://www.luogu.com.cn/problem/P1177)就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  \n\n不行了这个gemini讲的太好了,我直接复制就行\n\n---\n\n\n您可以把快速排序想象成一个“**不断找人站队**”的过程。\n\n\n### 快速排序的核心思想\n\n正如您资料中提到的，它的核心是 **“分治”（Divide and Conquer）**。\n\n简单来说，就是：\n\n1.  **找一个“基准” (Pivot)：** 在队伍里（数组中）随便挑一个人（一个数）当“基准”。\n2.  **站队 (Partition)：** 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。\n3.  **分而治之 (Recurse)：** 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别**重复**第1步和第2步。\n4.  **完成：** 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。\n\n-----\n\n### 详细解释您提供的 C++ 代码\n\n您提供的代码是实现这个过程的经典方法。我们一步一步来看：\n\n#### 1\\. `Partition` 函数（最关键的“站队”过程）\n\n这个函数的目标是：**选定一个基准，并完成“站队”**。\n\n```c++\ntemplate <typename T>\nint Partition(T A[], int low, int high) {//这里low是排序的第一个指针， high是最后一个指针\n  int pivot = A[low]; // 1. 选择基准：就选第一个元素当基准 (pivot)\n                      //    此时 A[low] 这个位置可以看成一个“坑”\n\n  while (low < high) { // 2. 只要左右指针没相遇，就继续\n    \n    // 3. 从右往左找“小”的\n    while (low < high && pivot <= A[high]) --high; \n    A[low] = A[high]; // 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”\n\n    // 5. 从左往右找“大”的\n    while (low < high && A[low] <= pivot) ++low; \n    A[high] = A[low]; // 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”\n  }\n  \n  // 7. 循环结束，low 和 high 相遇了\n  A[low] = pivot; // 8. 把一开始存的基准值，放回这个最后的“坑”\n  return low;     // 9. 返回基准最后站的位置\n}\n```\n\n**用一个例子来模拟 `Partition`：**\n假设数组是 `[5, 2, 8, 1, 9, 4]`，`low = 0`, `high = 5`。\n\n1.  `pivot = A[low]`，`pivot` 存了 **5**。 `A[0]` 现在是“坑”。\n    数组：`[坑, 2, 8, 1, 9, 4]`\n2.  **从右往左**（`high` 从 5 开始）找比 5 小的。\n      * `A[5]` 是 4。比 5 小。\n3.  把 4 扔到左边的“坑” (`A[low]` 即 `A[0]`)。`A[5]` 变成新“坑”。\n    数组：`[4, 2, 8, 1, 9, 坑]`\n4.  **从左往右**（`low` 从 0 开始）找比 5 大的。\n      * `A[0]` 是 4。\n      * `A[1]` 是 2。\n      * `A[2]` 是 8。比 5 大。\n5.  把 8 扔到右边的“坑” (`A[high]` 即 `A[5]`)。`A[2]` 变成新“坑”。\n    数组：`[4, 2, 坑, 1, 9, 8]`\n6.  **从右往左**（`high` 从 5 开始）...\n      * ... `A[4]` 是 9。\n      * `A[3]` 是 1。比 5 小。\n7.  把 1 扔到左边的“坑” (`A[low]` 即 `A[2]`)。`A[3]` 变成新“坑”。\n    数组：`[4, 2, 1, 坑, 9, 8]`\n8.  **从左往右**（`low` 从 2 开始）...\n      * `A[2]` 是 1。\n      * `A[3]`... `low` 和 `high` 在 3 这个位置相遇了。循环 `while (low < high)` 结束。\n9.  把 `pivot` (存的 **5**) 放到 `A[low]` (即 `A[3]`)。\n    数组：`[4, 2, 1, 5, 9, 8]`\n10. 返回 `low` (即 3)。\n\n**看，现在数组变成了 `[4, 2, 1]` （都比5小） | `5` | `[9, 8]` （都比5大）。** 这就是“站队”！\n\n-----\n\n#### 2\\. `QuickSort` 函数（“分而治之”的递归）\n\n这个函数是“分治”思想的体现，它来“指挥”`Partition`。\n\n```c++\ntemplate <typename T>\nvoid QuickSort(T A[], int low, int high) {\n  if (low < high) { // 如果队伍里至少有2个人\n    // 1. 先站队，并拿到基准最后的位置\n    int pivot_pos = Partition(A, low, high); \n    \n    // 2. 指挥“左队”去递归排序\n    QuickSort(A, low, pivot_pos - 1); \n    \n    // 3. 指挥“右队”去递归排序\n    QuickSort(A, pivot + 1, high); \n  }\n  // 如果 low >= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。\n}\n```\n\n### 总结\n\n1.  `QuickSort` 函数是**宏观管理者**：它负责“分”，决定对哪一段（从 `low` 到 `high`）进行排序。\n2.  `Partition` 函数是**具体执行者**：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。\n3.  通过**递归**，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。\n\n您提供的资料中提到“不用合并”，就是因为 `Partition` 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。\n\n---\n后面还有[优化算法](https://oi-wiki.org/basic/quick-sort/)，我真不想看了，之后有空再看。\n\n## 归并排序\n我草怎么还有。。。\n直接放[归并](https://oi-wiki.org/basic/merge-sort/)的链接吧\n\n\n## 总结\n其实还有sort函数，要写一个函数作为排序的算法。  \n我感觉我这样学习效率很低，应该做题，不会的再去查概念。  \n先去吃个饭，等下学递归的时候改一下学习方法。","slug":"paixu1","published":1,"updated":"2025-11-08T09:45:22.483Z","comments":1,"layout":"post","photos":[],"_id":"cuidOYf4kH2juGa8Q0IqGDNYS","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"%E9%AB%98%E7%B2%BE%E5%BA%A6\">高精度</span></h2><p>在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。</p>\n<p>高精度加法比较简单，将数组反转处理，将进位临时储存，<em>需注意算法结束后还要验证最后进位是否为0</em>。</p>\n<hr>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> int long long</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(a.<span class=\"hljs-built_in\">size</span>(), b.<span class=\"hljs-built_in\">size</span>()), jw = <span class=\"hljs-number\">0</span>;<br>    string c = <span class=\"hljs-string\">\"\"</span>;<br>    <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-built_in\">size</span>() &lt; len) a = <span class=\"hljs-string\">'0'</span> + a;<br>    <span class=\"hljs-keyword\">while</span> (b.<span class=\"hljs-built_in\">size</span>() &lt; len) b = <span class=\"hljs-string\">'0'</span> + b;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = len - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>    {<br>        <span class=\"hljs-type\">int</span> t1 = a[i] - <span class=\"hljs-string\">'0'</span>, t2 = b[i] - <span class=\"hljs-string\">'0'</span>;<br>        <span class=\"hljs-type\">int</span> t = t1 + t2 + jw;<br>        jw = t / <span class=\"hljs-number\">10</span>;<br>        t %= <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">char</span> ch = t + <span class=\"hljs-string\">'0'</span>;<br>        c = ch + c;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (jw != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'1'</span> + c;<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">signed</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>\tios::<span class=\"hljs-built_in\">sync_with_stdio</span>(<span class=\"hljs-number\">0</span>);<br>\tcin.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tcout.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tstring s1, s2;<br>\tcin &gt;&gt; s1 &gt;&gt; s2;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">add</span>(s1, s2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<hr>\n<p>发现自己高精度乘法解释不清楚，这个<a href=\"https://www.luogu.com.cn/article/pxfpoeoi\">高精度乘法</a>题解写的很好，可以参考下。</p>\n<hr>\n<p>然后我发现<a href=\"https://www.luogu.com.cn/problem/P1009\">p1009</a>不会做。<br>不是这高精算法怎么这么智障。<br><del>于是我决定跳过，之后再看。</del><br>还是看完了，其实并不难，题解写的很傻逼。<br>需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  </p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//高精度加法s1 s2 result均为倒叙储存</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s2)</span></span><br><span class=\"hljs-function\"></span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>(),s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>());<br>    <span class=\"hljs-type\">int</span> temp=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++)<br>    {<br>        <span class=\"hljs-type\">int</span> a,b;<br>        a=(i&lt;s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>())?s1[i] : <span class=\"hljs-number\">0</span>;<br>        b=(i&lt;s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>())?s2[i] : <span class=\"hljs-number\">0</span>;<br>        c.<span class=\"hljs-built_in\">push_back</span>((a+b+temp)%<span class=\"hljs-number\">10</span>);<br>        temp=(a+b+temp)/<span class=\"hljs-number\">10</span>;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (temp&gt;<span class=\"hljs-number\">0</span>) c.<span class=\"hljs-built_in\">push_back</span>(temp);<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><span class=\"hljs-comment\">//高精度乘以低精度乘法</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">mul</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; a, <span class=\"hljs-type\">int</span> b)</span> </span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.<span class=\"hljs-built_in\">size</span>(); i++) {<br>        temp += a[i] * b;      <br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>); <br>        temp /= <span class=\"hljs-number\">10</span>;            <br>    }<br>    <span class=\"hljs-keyword\">while</span> (temp) {<br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>);<br>        temp /= <span class=\"hljs-number\">10</span>;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (c.<span class=\"hljs-built_in\">empty</span>()) {<br>        c.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>    }<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><br><span class=\"hljs-comment\">//主函数调用</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; sum = {<span class=\"hljs-number\">0</span>}; <br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; term = {<span class=\"hljs-number\">1</span>};<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<br>    {<br>        term = <span class=\"hljs-built_in\">mul</span>(term,i);<br>        sum = <span class=\"hljs-built_in\">add</span>(sum,term);<br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = sum.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {<br>        cout &lt;&lt; sum[i];<br>    }<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>第一版代码编译错误。<br><em><strong>我是不是有病</strong></em><br>错误在s1.[i]，和结构体搞混了。<br>改好了就过了</p>\n<p>好我们开始学习排序；</p>\n<hr>\n<h2><span id=\"%E6%8E%92%E5%BA%8F\">排序</span></h2><h3><span id=\"%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\">计数排序</span></h3><p><a href=\"https://www.luogu.com.cn/problem/P1271\">P1271 【深基9.例1】选举学生会</a>，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  </p>\n<p>计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  </p>\n<p><del>比较简单，且时间复杂度很高，感觉没什么用，下一个。</del>  </p>\n<p><a href=\"https://oi-wiki.org/basic/counting-sort/\">oiwiki</a>上写了要计算前缀和，我并不太理解，接下来是gemini的解释：</p>\n<hr>\n<blockquote>\n<p>这是一个非常好的问题！“前缀和”这一步是计数排序<strong>从一个简单的“计数”算法变成一个强大的“排序”算法</strong>的关键。</p>\n<p>简单来说，前缀和的核心作用是：<strong>把“计数”转变为“最终位置”</strong>。</p>\n<p>它解决了两个问题：</p>\n<ol>\n<li><strong>定位问题</strong>：知道有3个“5”，但我该把它们放在输出数组的哪个<strong>具体索引</strong>上？</li>\n<li><strong>稳定性问题</strong>：如果原始数组中有两个“5”（比如一个是 <code>(5, 'a')</code>，一个是 <code>(5, 'b')</code>），如何保证排序后它们的相对顺序不变？</li>\n</ol>\n<h3><span id=\"1-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95\">1. 如果没有前缀和（朴素想法）</span></h3><p>我们先看看，如果<strong>只有</strong>第一步“计算每个数出现了几次”，我们会怎么做。</p>\n<p>假设待排序数组 <code>A = {1, 4, 1, 2, 4, 3, 1}</code></p>\n<p><strong>步骤 1：计数</strong><br>我们得到一个“计数数组” <code>C</code>：</p>\n<ul>\n<li><code>C[1] = 3</code> (有 3 个 ‘1’)</li>\n<li><code>C[2] = 1</code> (有 1 个 ‘2’)</li>\n<li><code>C[3] = 1</code> (有 1 个 ‘3’)</li>\n<li><code>C[4] = 2</code> (有 2 个 ‘4’)</li>\n</ul>\n<p><strong>朴素的“排序”：</strong><br>我们可以遍历 <code>C</code> 数组，然后直接重写 <code>A</code>：</p>\n<ul>\n<li>看到 <code>C[1] = 3</code>，就在 <code>A</code> 里写 3 个 ‘1’：<code>A = {1, 1, 1, ...}</code></li>\n<li>看到 <code>C[2] = 1</code>，接着写 1 个 ‘2’：<code>A = {1, 1, 1, 2, ...}</code></li>\n<li>…</li>\n<li>最终得到 <code>A = {1, 1, 1, 2, 3, 4, 4}</code></li>\n</ul>\n<p><strong>问题所在：</strong><br>这确实排序了。但是，如果我们的 <code>A</code> 数组存的不是简单的数字，而是<strong>对象</strong>呢？<br>比如 <code>A = {(1, 'a'), (4, 'b'), (1, 'c'), (4, 'd'), (1, 'e')}</code><br>我们的 <code>C</code> 数组还是一样：<code>C[1]=3</code>，<code>C[4]=2</code>。<br>如果用朴素方法，我们只会得到 <code>{1, 1, 1, 4, 4}</code>。我们完全<strong>丢失了 ‘a’, ‘b’, ‘c’, ‘d’, ‘e’ 这些附加信息</strong>。</p>\n<p>我们需要的不是“覆盖”原数组，而是把原数组中的<strong>每一个元素</strong>，<strong>“搬运”</strong> 到一个新数组（或最终位置）的正确索引上。</p>\n<h3><span id=\"2-%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AE%A1%E7%AE%97%E4%BD%8D%E7%BD%AE%E8%BE%B9%E7%95%8C\">2. 前缀和的作用：计算“位置边界”</span></h3><p>前缀和就是用来计算这个“搬运”目标的。</p>\n<p>我们换一个例子：<code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code></p>\n<p><strong>步骤 1：计数</strong><br><code>C</code> 数组 (索引 0 到 5):</p>\n<ul>\n<li><code>C[0] = 2</code> (2 个 ‘0’)</li>\n<li><code>C[1] = 0</code> (0 个 ‘1’)</li>\n<li><code>C[2] = 2</code> (2 个 ‘2’)</li>\n<li><code>C[3] = 3</code> (3 个 ‘3’)</li>\n<li><code>C[4] = 0</code> (0 个 ‘4’)</li>\n<li><code>C[5] = 1</code> (1 个 ‘5’)</li>\n<li>数组 <code>C</code>：<code>{2, 0, 2, 3, 0, 1}</code></li>\n</ul>\n<p><strong>步骤 2：计算前缀和</strong><br>我们对 <code>C</code> 数组进行累加：</p>\n<ul>\n<li><code>C[0] = 2</code></li>\n<li><code>C[1] = C[1] + C[0] = 0 + 2 = 2</code></li>\n<li><code>C[2] = C[2] + C[1] = 2 + 2 = 4</code></li>\n<li><code>C[3] = C[3] + C[2] = 3 + 4 = 7</code></li>\n<li><code>C[4] = C[4] + C[3] = 0 + 7 = 7</code></li>\n<li><code>C[5] = C[5] + C[4] = 1 + 7 = 8</code></li>\n<li>数组 <code>C</code>（前缀和）：<code>{2, 2, 4, 7, 7, 8}</code></li>\n</ul>\n<p><strong>现在，这个前缀和数组 <code>C</code> 的含义</strong>变得非常重要：<br><code>C[i]</code> 的值 = 原始数组中 <strong>小于或等于 <code>i</code></strong> 的元素总个数。</p>\n<ul>\n<li><code>C[0] = 2</code>：有 2 个元素 $\\le 0$。</li>\n<li><code>C[2] = 4</code>：有 4 个元素 $\\le 2$ (即 ‘0’ 和 ‘2’)。</li>\n<li><code>C[3] = 7</code>：有 7 个元素 $\\le 3$ (即 ‘0’, ‘2’ 和 ‘3’)。</li>\n<li><code>C[5] = 8</code>：有 8 个元素 $\\le 5$ (即所有元素)。</li>\n</ul>\n<p><strong>这就是关键点！</strong></p>\n<blockquote>\n<p>如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 ‘2’ 应该放在<strong>第 4 位</strong>。</p>\n<p>如果有 7 个元素小于或等于 3，那么最后一个 ‘3’ 应该放在<strong>第 7 位</strong>。</p>\n</blockquote>\n<p><strong><code>C[i]</code> 现在直接告诉了我们：值 <code>i</code> 的元素在排序后，最后一个应该放的“坑位”是第 <code>C[i]</code> 个。</strong></p>\n<h3><span id=\"3-%E6%AD%A5%E9%AA%A4-3%E5%88%A9%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0\">3. 步骤 3：利用前缀和（从后往前）放置元素</span></h3><p>我们准备一个和 <code>A</code> 一样大的空数组 <code>B</code> (大小为 8)。<br>我们<strong>从右至左</strong>（从后往前）遍历原始数组 <code>A</code>。</p>\n<p><code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code><br><code>C = {2, 2, 4, 7, 7, 8}</code> (前缀和)<br><code>B = {_, _, _, _, _, _, _, _}</code></p>\n<ol>\n<li><p><strong>遍历 <code>A[7] = 3</code></strong></p>\n<ul>\n<li>查找 <code>C[3]</code>，值为 <code>7</code>。</li>\n<li>这告诉我们：’3’ 应该放在第 7 个位置（即 0-based 索引的 <code>7-1 = 6</code>）。</li>\n<li><code>B[6] = 3</code>。</li>\n<li><strong>重要</strong>：我们用掉了一个 ‘3’ 的位置，所以 <code>C[3]</code> 减 1。<code>C[3]</code> 变为 <code>6</code>。</li>\n<li><code>B</code>：<code>{_, _, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[6] = 0</code></strong></p>\n<ul>\n<li>查找 <code>C[0]</code>，值为 <code>2</code>。</li>\n<li>位置：<code>2-1 = 1</code>。</li>\n<li><code>B[1] = 0</code>。</li>\n<li><code>C[0]</code> 减 1，变为 <code>1</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[5] = 3</code></strong> (这是第二个 ‘3’)</p>\n<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>6</code> (上次用过 ‘3’ 后减 1 了)。</li>\n<li>位置：<code>6-1 = 5</code>。</li>\n<li><code>B[5] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>5</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, 3, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[4] = 2</code></strong></p>\n<ul>\n<li>查找 <code>C[2]</code>，值为 <code>4</code>。</li>\n<li>位置：<code>4-1 = 3</code>。</li>\n<li><code>B[3] = 2</code>。</li>\n<li><code>C[2]</code> 减 1，变为 <code>3</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, _, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>… 以此类推，直到 <code>A[0]</code>。</p>\n<ol start=\"5\">\n<li><strong>遍历 <code>A[2] = 3</code></strong> (这是第一个 ‘3’)<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>5</code>。</li>\n<li>位置：<code>5-1 = 4</code>。</li>\n<li><code>B[4] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>4</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, 3, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>最后我们会得到 <code>B = {0, 0, 2, 2, 3, 3, 3, 5}</code>，排序完成。</p>\n<h3><span id=\"%E6%80%BB%E7%BB%93\">总结</span></h3><p>前缀和是计数排序的灵魂，它完成了两个核心任务：</p>\n<ol>\n<li><strong>精确</strong><br><strong>定位</strong>：<code>C[i]</code> 从“<code>i</code> 的个数”转变成了“小于等于 <code>i</code> 的总数”，这个总数<strong>直接映射</strong>到了排序后数组的<strong>索引（位置）</strong>。</li>\n<li><strong>保证稳定性</strong>：通过<strong>从后往前</strong>遍历原数组 <code>A</code>，并结合 <code>C[i]--</code> 操作，我们确保了：<ul>\n<li>原数组中<strong>靠后</strong>的重复元素，会先被放入新数组中<strong>靠后</strong>的“坑位”。</li>\n<li>原数组中<strong>靠前</strong>的重复元素，会后被放入新数组中<strong>靠前</strong>的“坑位”。</li>\n<li>从而保持了它们的相对顺序不变（即“稳定性”）。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<hr>\n<p>我理解了什么意思了，但是怎么这么繁琐。。。<br>我可能之后还是不记得这个<strong>前缀和</strong>怎么用，不过至少了解了，先写个代码熟悉一下。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">count_sort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,<span class=\"hljs-type\">int</span> n)</span><span class=\"hljs-comment\">//需要输入的数组，里面的最大数（默认从0开始排序）</span></span><br><span class=\"hljs-function\"></span>{   <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">c</span> <span class=\"hljs-params\">(n<span class=\"hljs-number\">+1</span>,<span class=\"hljs-number\">0</span>)</span></span>;<span class=\"hljs-comment\">//初始化计数数组；</span><br>    <span class=\"hljs-comment\">//遍历计数</span><br>    <span class=\"hljs-type\">int</span> leng=s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;leng;i++) c[s1[i]]++;<br>    <span class=\"hljs-comment\">//计算前缀和；</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">+1</span>;i++) c[i]+=c[i<span class=\"hljs-number\">-1</span>];<br>    <span class=\"hljs-comment\">//将c数组里的每一个数替换成前缀和</span><br>    <br>    <span class=\"hljs-comment\">//定义输出数组</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(leng)</span></span>;<br>    <span class=\"hljs-comment\">//利用前缀和（从后往前）放置元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = leng<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;--i)<br>    {<br>        <span class=\"hljs-type\">int</span> num = s1[i];<span class=\"hljs-comment\">//查找第i元素</span><br>        <span class=\"hljs-type\">int</span> postion=c[num]<span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//查找这个元素应该放在第几个位置</span><br>        <span class=\"hljs-comment\">/*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个</span><br><span class=\"hljs-comment\">        那么这个数减一就是应该放在结果数组的位置</span><br><span class=\"hljs-comment\">        */</span><br>        result[postion]=num;<br>        c[num]--;<span class=\"hljs-comment\">//用掉了一个数，应该减一</span><br><br>    }<br>    <span class=\"hljs-keyword\">return</span> result;<br><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n<h3><span id=\"%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">选择排序</span></h3><p><a href=\"https://oi-wiki.org/basic/selection-sort/\">oi wiki的选择排序</a>解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  </p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selection_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* a, <span class=\"hljs-type\">int</span> n)</span> </span>{<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) {<br>    <span class=\"hljs-type\">int</span> ith = i;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt;= n; ++j) {<br>      <span class=\"hljs-keyword\">if</span> (a[j] &lt; a[ith]) {<br>        ith = j;<br>      }<br>    }<br>    std::<span class=\"hljs-built_in\">swap</span>(a[i], a[ith]);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。<br>本质上是打擂台，找到最小的数字，排在最前面。</p>\n<h3><span id=\"%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">冒泡排序</span></h3><p>这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。<br>当不再发生交换的时候，排序完成。 </p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubble_sort</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *a,<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">bool</span> switched = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//switched表示上一轮是否交换</span><br>    <span class=\"hljs-comment\">/*这是个断终止的方法，只要上一轮没有交换说明排序结束*/</span><br>    <span class=\"hljs-keyword\">while</span> (switched)<br>    {<br>        switched = <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;++i)<span class=\"hljs-comment\">//注意数组越界问题，应当要再减一</span><br>        {<br>            <span class=\"hljs-keyword\">if</span> (a[i] &gt; a[i + <span class=\"hljs-number\">1</span>]) <br>            {<br>                switched = <span class=\"hljs-literal\">true</span>;<br>                <span class=\"hljs-built_in\">swap</span>(a[i],a[i<span class=\"hljs-number\">+1</span>]);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2><span id=\"%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序</span></h2><p>把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。</p>\n<blockquote>\n<p>可数组的插入不是很复杂的吗？？</p>\n</blockquote>\n<p>代码实现如下</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertion_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> len)</span> </span>{<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; ++i) {<br>    <span class=\"hljs-type\">int</span> key = arr[i];<br>    <span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; key) {<br>      arr[j + <span class=\"hljs-number\">1</span>] = arr[j];<br>      j--;<br>    }<br>    arr[j + <span class=\"hljs-number\">1</span>] = key;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>这是gemini的解释，我觉得很形象</p>\n<hr>\n<blockquote>\n<p>它的核心思想是模拟我们<strong>玩扑克牌时整理手牌</strong>的动作。</p>\n<h3><span id=\"%F0%9F%83%8F-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%AF%94%E5%96%BB-%E6%95%B4%E7%90%86%E6%89%8B%E7%89%8C\">🃏 插入排序的核心比喻 (整理手牌)</span></h3><p>想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（<code>key</code>）。</p>\n<p>你会怎么做？</p>\n<ol>\n<li>&nbsp;你从左手中<strong>最右边</strong>的牌（<code>j</code>）开始，和你的新牌（<code>key</code>）比较。</li>\n<li>&nbsp;如果左手的牌（<code>arr[j]</code>）比你的新牌（<code>key</code>）大，你就把这张牌<strong>往右移一个位置</strong>（<code>arr[j + 1] = arr[j]</code>），腾出它原来的空位。</li>\n<li>&nbsp;你继续看左手边下一张牌（<code>j--</code>），重复这个比较。</li>\n<li>&nbsp;直到你找到一张比新牌（<code>key</code>）小的牌，或者你已经比较完了所有手里的牌 ( <code>j &lt; 0</code> )。</li>\n<li>&nbsp;这时，你找到了正确的位置，把你手里的新牌（<code>key</code>）<strong>插入</strong>到刚刚腾出来的那个空位上（<code>arr[j + 1] = key</code>）。</li>\n</ol>\n</blockquote>\n<hr>\n<p>如果基本有序，就可以使用这个插入算法。  </p>\n<blockquote>\n<p>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。</p>\n</blockquote>\n<p><em><strong>至少下一个排序很有用</strong></em></p>\n<h2><span id=\"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">快速排序</span></h2><p><a href=\"https://www.luogu.com.cn/problem/P1177\">洛谷P1177</a>就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  </p>\n<p>不行了这个gemini讲的太好了,我直接复制就行</p>\n<hr>\n<p>您可以把快速排序想象成一个“<strong>不断找人站队</strong>”的过程。</p>\n<h3><span id=\"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\">快速排序的核心思想</span></h3><p>正如您资料中提到的，它的核心是 <strong>“分治”（Divide and Conquer）</strong>。</p>\n<p>简单来说，就是：</p>\n<ol>\n<li><strong>找一个“基准” (Pivot)：</strong> 在队伍里（数组中）随便挑一个人（一个数）当“基准”。</li>\n<li><strong>站队 (Partition)：</strong> 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。</li>\n<li><strong>分而治之 (Recurse)：</strong> 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别<strong>重复</strong>第1步和第2步。</li>\n<li><strong>完成：</strong> 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。</li>\n</ol>\n<hr>\n<h3><span id=\"%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E6%82%A8%E6%8F%90%E4%BE%9B%E7%9A%84-c-%E4%BB%A3%E7%A0%81\">详细解释您提供的 C++ 代码</span></h3><p>您提供的代码是实现这个过程的经典方法。我们一步一步来看：</p>\n<h4><span id=\"1-partition-%E5%87%BD%E6%95%B0%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E7%AB%99%E9%98%9F%E8%BF%87%E7%A8%8B\">1. <code>Partition</code> 函数（最关键的“站队”过程）</span></h4><p>这个函数的目标是：<strong>选定一个基准，并完成“站队”</strong>。</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Partition</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>{<span class=\"hljs-comment\">//这里low是排序的第一个指针， high是最后一个指针</span><br>  <span class=\"hljs-type\">int</span> pivot = A[low]; <span class=\"hljs-comment\">// 1. 选择基准：就选第一个元素当基准 (pivot)</span><br>                      <span class=\"hljs-comment\">//    此时 A[low] 这个位置可以看成一个“坑”</span><br><br>  <span class=\"hljs-keyword\">while</span> (low &lt; high) { <span class=\"hljs-comment\">// 2. 只要左右指针没相遇，就继续</span><br>    <br>    <span class=\"hljs-comment\">// 3. 从右往左找“小”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; pivot &lt;= A[high]) --high; <br>    A[low] = A[high]; <span class=\"hljs-comment\">// 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”</span><br><br>    <span class=\"hljs-comment\">// 5. 从左往右找“大”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; <br>    A[high] = A[low]; <span class=\"hljs-comment\">// 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”</span><br>  }<br>  <br>  <span class=\"hljs-comment\">// 7. 循环结束，low 和 high 相遇了</span><br>  A[low] = pivot; <span class=\"hljs-comment\">// 8. 把一开始存的基准值，放回这个最后的“坑”</span><br>  <span class=\"hljs-keyword\">return</span> low;     <span class=\"hljs-comment\">// 9. 返回基准最后站的位置</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>用一个例子来模拟 <code>Partition</code>：</strong><br>假设数组是 <code>[5, 2, 8, 1, 9, 4]</code>，<code>low = 0</code>, <code>high = 5</code>。</p>\n<ol>\n<li><code>pivot = A[low]</code>，<code>pivot</code> 存了 <strong>5</strong>。 <code>A[0]</code> 现在是“坑”。<br>数组：<code>[坑, 2, 8, 1, 9, 4]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）找比 5 小的。<ul>\n<li><code>A[5]</code> 是 4。比 5 小。</li>\n</ul>\n</li>\n<li>把 4 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[0]</code>)。<code>A[5]</code> 变成新“坑”。<br>数组：<code>[4, 2, 8, 1, 9, 坑]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 0 开始）找比 5 大的。<ul>\n<li><code>A[0]</code> 是 4。</li>\n<li><code>A[1]</code> 是 2。</li>\n<li><code>A[2]</code> 是 8。比 5 大。</li>\n</ul>\n</li>\n<li>把 8 扔到右边的“坑” (<code>A[high]</code> 即 <code>A[5]</code>)。<code>A[2]</code> 变成新“坑”。<br>数组：<code>[4, 2, 坑, 1, 9, 8]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）…<ul>\n<li>… <code>A[4]</code> 是 9。</li>\n<li><code>A[3]</code> 是 1。比 5 小。</li>\n</ul>\n</li>\n<li>把 1 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[2]</code>)。<code>A[3]</code> 变成新“坑”。<br>数组：<code>[4, 2, 1, 坑, 9, 8]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 2 开始）…<ul>\n<li><code>A[2]</code> 是 1。</li>\n<li><code>A[3]</code>… <code>low</code> 和 <code>high</code> 在 3 这个位置相遇了。循环 <code>while (low &lt; high)</code> 结束。</li>\n</ul>\n</li>\n<li>把 <code>pivot</code> (存的 <strong>5</strong>) 放到 <code>A[low]</code> (即 <code>A[3]</code>)。<br>数组：<code>[4, 2, 1, 5, 9, 8]</code></li>\n<li>返回 <code>low</code> (即 3)。</li>\n</ol>\n<p><strong>看，现在数组变成了 <code>[4, 2, 1]</code> （都比5小） | <code>5</code> | <code>[9, 8]</code> （都比5大）。</strong> 这就是“站队”！</p>\n<hr>\n<h4><span id=\"2-quicksort-%E5%87%BD%E6%95%B0%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%9A%84%E9%80%92%E5%BD%92\">2. <code>QuickSort</code> 函数（“分而治之”的递归）</span></h4><p>这个函数是“分治”思想的体现，它来“指挥”<code>Partition</code>。</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">QuickSort</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>{<br>  <span class=\"hljs-keyword\">if</span> (low &lt; high) { <span class=\"hljs-comment\">// 如果队伍里至少有2个人</span><br>    <span class=\"hljs-comment\">// 1. 先站队，并拿到基准最后的位置</span><br>    <span class=\"hljs-type\">int</span> pivot_pos = <span class=\"hljs-built_in\">Partition</span>(A, low, high); <br>    <br>    <span class=\"hljs-comment\">// 2. 指挥“左队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, low, pivot_pos - <span class=\"hljs-number\">1</span>); <br>    <br>    <span class=\"hljs-comment\">// 3. 指挥“右队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, pivot + <span class=\"hljs-number\">1</span>, high); <br>  }<br>  <span class=\"hljs-comment\">// 如果 low &gt;= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E6%80%BB%E7%BB%93\">总结</span></h3><ol>\n<li><code>QuickSort</code> 函数是<strong>宏观管理者</strong>：它负责“分”，决定对哪一段（从 <code>low</code> 到 <code>high</code>）进行排序。</li>\n<li><code>Partition</code> 函数是<strong>具体执行者</strong>：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。</li>\n<li>通过<strong>递归</strong>，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。</li>\n</ol>\n<p>您提供的资料中提到“不用合并”，就是因为 <code>Partition</code> 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。</p>\n<hr>\n<p>后面还有<a href=\"https://oi-wiki.org/basic/quick-sort/\">优化算法</a>，我真不想看了，之后有空再看。</p>\n<h2><span id=\"%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序</span></h2><p>我草怎么还有。。。<br>直接放<a href=\"https://oi-wiki.org/basic/merge-sort/\">归并</a>的链接吧</p>\n<h2><span id=\"%E6%80%BB%E7%BB%93\">总结</span></h2><p>其实还有sort函数，要写一个函数作为排序的算法。<br>我感觉我这样学习效率很低，应该做题，不会的再去查概念。<br>先去吃个饭，等下学递归的时候改一下学习方法。</p>\n</body></html>","excerpt":"","more":"<h2 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h2><p>在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。</p>\n<p>高精度加法比较简单，将数组反转处理，将进位临时储存，<em>需注意算法结束后还要验证最后进位是否为0</em>。</p>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> int long long</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(a.<span class=\"hljs-built_in\">size</span>(), b.<span class=\"hljs-built_in\">size</span>()), jw = <span class=\"hljs-number\">0</span>;<br>    string c = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-built_in\">size</span>() &lt; len) a = <span class=\"hljs-string\">&#x27;0&#x27;</span> + a;<br>    <span class=\"hljs-keyword\">while</span> (b.<span class=\"hljs-built_in\">size</span>() &lt; len) b = <span class=\"hljs-string\">&#x27;0&#x27;</span> + b;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = len - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> t1 = a[i] - <span class=\"hljs-string\">&#x27;0&#x27;</span>, t2 = b[i] - <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        <span class=\"hljs-type\">int</span> t = t1 + t2 + jw;<br>        jw = t / <span class=\"hljs-number\">10</span>;<br>        t %= <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">char</span> ch = t + <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        c = ch + c;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (jw != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;1&#x27;</span> + c;<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">signed</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tios::<span class=\"hljs-built_in\">sync_with_stdio</span>(<span class=\"hljs-number\">0</span>);<br>\tcin.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tcout.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tstring s1, s2;<br>\tcin &gt;&gt; s1 &gt;&gt; s2;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">add</span>(s1, s2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p>发现自己高精度乘法解释不清楚，这个<a href=\"https://www.luogu.com.cn/article/pxfpoeoi\">高精度乘法</a>题解写的很好，可以参考下。</p>\n<hr>\n<p>然后我发现<a href=\"https://www.luogu.com.cn/problem/P1009\">p1009</a>不会做。<br>不是这高精算法怎么这么智障。<br><del>于是我决定跳过，之后再看。</del><br>还是看完了，其实并不难，题解写的很傻逼。<br>需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//高精度加法s1 s2 result均为倒叙储存</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s2)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>(),s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>());<br>    <span class=\"hljs-type\">int</span> temp=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> a,b;<br>        a=(i&lt;s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>())?s1[i] : <span class=\"hljs-number\">0</span>;<br>        b=(i&lt;s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>())?s2[i] : <span class=\"hljs-number\">0</span>;<br>        c.<span class=\"hljs-built_in\">push_back</span>((a+b+temp)%<span class=\"hljs-number\">10</span>);<br>        temp=(a+b+temp)/<span class=\"hljs-number\">10</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (temp&gt;<span class=\"hljs-number\">0</span>) c.<span class=\"hljs-built_in\">push_back</span>(temp);<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><span class=\"hljs-comment\">//高精度乘以低精度乘法</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">mul</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>        temp += a[i] * b;      <br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>); <br>        temp /= <span class=\"hljs-number\">10</span>;            <br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (temp) &#123;<br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>);<br>        temp /= <span class=\"hljs-number\">10</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (c.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        c.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><br><span class=\"hljs-comment\">//主函数调用</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; sum = &#123;<span class=\"hljs-number\">0</span>&#125;; <br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; term = &#123;<span class=\"hljs-number\">1</span>&#125;;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<br>    &#123;<br>        term = <span class=\"hljs-built_in\">mul</span>(term,i);<br>        sum = <span class=\"hljs-built_in\">add</span>(sum,term);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = sum.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>        cout &lt;&lt; sum[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第一版代码编译错误。<br><em><strong>我是不是有病</strong></em><br>错误在s1.[i]，和结构体搞混了。<br>改好了就过了</p>\n<p>好我们开始学习排序；</p>\n<hr>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><p><a href=\"https://www.luogu.com.cn/problem/P1271\">P1271 【深基9.例1】选举学生会</a>，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  </p>\n<p>计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  </p>\n<p><del>比较简单，且时间复杂度很高，感觉没什么用，下一个。</del>  </p>\n<p><a href=\"https://oi-wiki.org/basic/counting-sort/\">oiwiki</a>上写了要计算前缀和，我并不太理解，接下来是gemini的解释：</p>\n<hr>\n<blockquote>\n<p>这是一个非常好的问题！“前缀和”这一步是计数排序<strong>从一个简单的“计数”算法变成一个强大的“排序”算法</strong>的关键。</p>\n<p>简单来说，前缀和的核心作用是：<strong>把“计数”转变为“最终位置”</strong>。</p>\n<p>它解决了两个问题：</p>\n<ol>\n<li><strong>定位问题</strong>：知道有3个“5”，但我该把它们放在输出数组的哪个<strong>具体索引</strong>上？</li>\n<li><strong>稳定性问题</strong>：如果原始数组中有两个“5”（比如一个是 <code>(5, &#39;a&#39;)</code>，一个是 <code>(5, &#39;b&#39;)</code>），如何保证排序后它们的相对顺序不变？</li>\n</ol>\n<h3 id=\"1-如果没有前缀和（朴素想法）\"><a href=\"#1-如果没有前缀和（朴素想法）\" class=\"headerlink\" title=\"1. 如果没有前缀和（朴素想法）\"></a>1. 如果没有前缀和（朴素想法）</h3><p>我们先看看，如果<strong>只有</strong>第一步“计算每个数出现了几次”，我们会怎么做。</p>\n<p>假设待排序数组 <code>A = {1, 4, 1, 2, 4, 3, 1}</code></p>\n<p><strong>步骤 1：计数</strong><br>我们得到一个“计数数组” <code>C</code>：</p>\n<ul>\n<li><code>C[1] = 3</code> (有 3 个 ‘1’)</li>\n<li><code>C[2] = 1</code> (有 1 个 ‘2’)</li>\n<li><code>C[3] = 1</code> (有 1 个 ‘3’)</li>\n<li><code>C[4] = 2</code> (有 2 个 ‘4’)</li>\n</ul>\n<p><strong>朴素的“排序”：</strong><br>我们可以遍历 <code>C</code> 数组，然后直接重写 <code>A</code>：</p>\n<ul>\n<li>看到 <code>C[1] = 3</code>，就在 <code>A</code> 里写 3 个 ‘1’：<code>A = {1, 1, 1, ...}</code></li>\n<li>看到 <code>C[2] = 1</code>，接着写 1 个 ‘2’：<code>A = {1, 1, 1, 2, ...}</code></li>\n<li>…</li>\n<li>最终得到 <code>A = {1, 1, 1, 2, 3, 4, 4}</code></li>\n</ul>\n<p><strong>问题所在：</strong><br>这确实排序了。但是，如果我们的 <code>A</code> 数组存的不是简单的数字，而是<strong>对象</strong>呢？<br>比如 <code>A = {(1, &#39;a&#39;), (4, &#39;b&#39;), (1, &#39;c&#39;), (4, &#39;d&#39;), (1, &#39;e&#39;)}</code><br>我们的 <code>C</code> 数组还是一样：<code>C[1]=3</code>，<code>C[4]=2</code>。<br>如果用朴素方法，我们只会得到 <code>{1, 1, 1, 4, 4}</code>。我们完全<strong>丢失了 ‘a’, ‘b’, ‘c’, ‘d’, ‘e’ 这些附加信息</strong>。</p>\n<p>我们需要的不是“覆盖”原数组，而是把原数组中的<strong>每一个元素</strong>，<strong>“搬运”</strong> 到一个新数组（或最终位置）的正确索引上。</p>\n<h3 id=\"2-前缀和的作用：计算“位置边界”\"><a href=\"#2-前缀和的作用：计算“位置边界”\" class=\"headerlink\" title=\"2. 前缀和的作用：计算“位置边界”\"></a>2. 前缀和的作用：计算“位置边界”</h3><p>前缀和就是用来计算这个“搬运”目标的。</p>\n<p>我们换一个例子：<code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code></p>\n<p><strong>步骤 1：计数</strong><br><code>C</code> 数组 (索引 0 到 5):</p>\n<ul>\n<li><code>C[0] = 2</code> (2 个 ‘0’)</li>\n<li><code>C[1] = 0</code> (0 个 ‘1’)</li>\n<li><code>C[2] = 2</code> (2 个 ‘2’)</li>\n<li><code>C[3] = 3</code> (3 个 ‘3’)</li>\n<li><code>C[4] = 0</code> (0 个 ‘4’)</li>\n<li><code>C[5] = 1</code> (1 个 ‘5’)</li>\n<li>数组 <code>C</code>：<code>{2, 0, 2, 3, 0, 1}</code></li>\n</ul>\n<p><strong>步骤 2：计算前缀和</strong><br>我们对 <code>C</code> 数组进行累加：</p>\n<ul>\n<li><code>C[0] = 2</code></li>\n<li><code>C[1] = C[1] + C[0] = 0 + 2 = 2</code></li>\n<li><code>C[2] = C[2] + C[1] = 2 + 2 = 4</code></li>\n<li><code>C[3] = C[3] + C[2] = 3 + 4 = 7</code></li>\n<li><code>C[4] = C[4] + C[3] = 0 + 7 = 7</code></li>\n<li><code>C[5] = C[5] + C[4] = 1 + 7 = 8</code></li>\n<li>数组 <code>C</code>（前缀和）：<code>{2, 2, 4, 7, 7, 8}</code></li>\n</ul>\n<p><strong>现在，这个前缀和数组 <code>C</code> 的含义</strong>变得非常重要：<br><code>C[i]</code> 的值 &#x3D; 原始数组中 <strong>小于或等于 <code>i</code></strong> 的元素总个数。</p>\n<ul>\n<li><code>C[0] = 2</code>：有 2 个元素 $\\le 0$。</li>\n<li><code>C[2] = 4</code>：有 4 个元素 $\\le 2$ (即 ‘0’ 和 ‘2’)。</li>\n<li><code>C[3] = 7</code>：有 7 个元素 $\\le 3$ (即 ‘0’, ‘2’ 和 ‘3’)。</li>\n<li><code>C[5] = 8</code>：有 8 个元素 $\\le 5$ (即所有元素)。</li>\n</ul>\n<p><strong>这就是关键点！</strong></p>\n<blockquote>\n<p>如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 ‘2’ 应该放在<strong>第 4 位</strong>。</p>\n<p>如果有 7 个元素小于或等于 3，那么最后一个 ‘3’ 应该放在<strong>第 7 位</strong>。</p>\n</blockquote>\n<p><strong><code>C[i]</code> 现在直接告诉了我们：值 <code>i</code> 的元素在排序后，最后一个应该放的“坑位”是第 <code>C[i]</code> 个。</strong></p>\n<h3 id=\"3-步骤-3：利用前缀和（从后往前）放置元素\"><a href=\"#3-步骤-3：利用前缀和（从后往前）放置元素\" class=\"headerlink\" title=\"3. 步骤 3：利用前缀和（从后往前）放置元素\"></a>3. 步骤 3：利用前缀和（从后往前）放置元素</h3><p>我们准备一个和 <code>A</code> 一样大的空数组 <code>B</code> (大小为 8)。<br>我们<strong>从右至左</strong>（从后往前）遍历原始数组 <code>A</code>。</p>\n<p><code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code><br><code>C = {2, 2, 4, 7, 7, 8}</code> (前缀和)<br><code>B = {_, _, _, _, _, _, _, _}</code></p>\n<ol>\n<li><p><strong>遍历 <code>A[7] = 3</code></strong></p>\n<ul>\n<li>查找 <code>C[3]</code>，值为 <code>7</code>。</li>\n<li>这告诉我们：’3’ 应该放在第 7 个位置（即 0-based 索引的 <code>7-1 = 6</code>）。</li>\n<li><code>B[6] = 3</code>。</li>\n<li><strong>重要</strong>：我们用掉了一个 ‘3’ 的位置，所以 <code>C[3]</code> 减 1。<code>C[3]</code> 变为 <code>6</code>。</li>\n<li><code>B</code>：<code>{_, _, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[6] = 0</code></strong></p>\n<ul>\n<li>查找 <code>C[0]</code>，值为 <code>2</code>。</li>\n<li>位置：<code>2-1 = 1</code>。</li>\n<li><code>B[1] = 0</code>。</li>\n<li><code>C[0]</code> 减 1，变为 <code>1</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[5] = 3</code></strong> (这是第二个 ‘3’)</p>\n<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>6</code> (上次用过 ‘3’ 后减 1 了)。</li>\n<li>位置：<code>6-1 = 5</code>。</li>\n<li><code>B[5] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>5</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, 3, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[4] = 2</code></strong></p>\n<ul>\n<li>查找 <code>C[2]</code>，值为 <code>4</code>。</li>\n<li>位置：<code>4-1 = 3</code>。</li>\n<li><code>B[3] = 2</code>。</li>\n<li><code>C[2]</code> 减 1，变为 <code>3</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, _, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>… 以此类推，直到 <code>A[0]</code>。</p>\n<ol start=\"5\">\n<li><strong>遍历 <code>A[2] = 3</code></strong> (这是第一个 ‘3’)<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>5</code>。</li>\n<li>位置：<code>5-1 = 4</code>。</li>\n<li><code>B[4] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>4</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, 3, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>最后我们会得到 <code>B = {0, 0, 2, 2, 3, 3, 3, 5}</code>，排序完成。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前缀和是计数排序的灵魂，它完成了两个核心任务：</p>\n<ol>\n<li><strong>精确</strong><br><strong>定位</strong>：<code>C[i]</code> 从“<code>i</code> 的个数”转变成了“小于等于 <code>i</code> 的总数”，这个总数<strong>直接映射</strong>到了排序后数组的<strong>索引（位置）</strong>。</li>\n<li><strong>保证稳定性</strong>：通过<strong>从后往前</strong>遍历原数组 <code>A</code>，并结合 <code>C[i]--</code> 操作，我们确保了：<ul>\n<li>原数组中<strong>靠后</strong>的重复元素，会先被放入新数组中<strong>靠后</strong>的“坑位”。</li>\n<li>原数组中<strong>靠前</strong>的重复元素，会后被放入新数组中<strong>靠前</strong>的“坑位”。</li>\n<li>从而保持了它们的相对顺序不变（即“稳定性”）。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<hr>\n<p>我理解了什么意思了，但是怎么这么繁琐。。。<br>我可能之后还是不记得这个<strong>前缀和</strong>怎么用，不过至少了解了，先写个代码熟悉一下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">count_sort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,<span class=\"hljs-type\">int</span> n)</span><span class=\"hljs-comment\">//需要输入的数组，里面的最大数（默认从0开始排序）</span></span><br><span class=\"hljs-function\"></span>&#123;   <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">c</span> <span class=\"hljs-params\">(n<span class=\"hljs-number\">+1</span>,<span class=\"hljs-number\">0</span>)</span></span>;<span class=\"hljs-comment\">//初始化计数数组；</span><br>    <span class=\"hljs-comment\">//遍历计数</span><br>    <span class=\"hljs-type\">int</span> leng=s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;leng;i++) c[s1[i]]++;<br>    <span class=\"hljs-comment\">//计算前缀和；</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">+1</span>;i++) c[i]+=c[i<span class=\"hljs-number\">-1</span>];<br>    <span class=\"hljs-comment\">//将c数组里的每一个数替换成前缀和</span><br>    <br>    <span class=\"hljs-comment\">//定义输出数组</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(leng)</span></span>;<br>    <span class=\"hljs-comment\">//利用前缀和（从后往前）放置元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = leng<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;--i)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> num = s1[i];<span class=\"hljs-comment\">//查找第i元素</span><br>        <span class=\"hljs-type\">int</span> postion=c[num]<span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//查找这个元素应该放在第几个位置</span><br>        <span class=\"hljs-comment\">/*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个</span><br><span class=\"hljs-comment\">        那么这个数减一就是应该放在结果数组的位置</span><br><span class=\"hljs-comment\">        */</span><br>        result[postion]=num;<br>        c[num]--;<span class=\"hljs-comment\">//用掉了一个数，应该减一</span><br><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p><a href=\"https://oi-wiki.org/basic/selection-sort/\">oi wiki的选择排序</a>解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selection_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* a, <span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-type\">int</span> ith = i;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt;= n; ++j) &#123;<br>      <span class=\"hljs-keyword\">if</span> (a[j] &lt; a[ith]) &#123;<br>        ith = j;<br>      &#125;<br>    &#125;<br>    std::<span class=\"hljs-built_in\">swap</span>(a[i], a[ith]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。<br>本质上是打擂台，找到最小的数字，排在最前面。</p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。<br>当不再发生交换的时候，排序完成。 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubble_sort</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *a,<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">bool</span> switched = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//switched表示上一轮是否交换</span><br>    <span class=\"hljs-comment\">/*这是个断终止的方法，只要上一轮没有交换说明排序结束*/</span><br>    <span class=\"hljs-keyword\">while</span> (switched)<br>    &#123;<br>        switched = <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;++i)<span class=\"hljs-comment\">//注意数组越界问题，应当要再减一</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (a[i] &gt; a[i + <span class=\"hljs-number\">1</span>]) <br>            &#123;<br>                switched = <span class=\"hljs-literal\">true</span>;<br>                <span class=\"hljs-built_in\">swap</span>(a[i],a[i<span class=\"hljs-number\">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。</p>\n<blockquote>\n<p>可数组的插入不是很复杂的吗？？</p>\n</blockquote>\n<p>代码实现如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertion_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> len)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; ++i) &#123;<br>    <span class=\"hljs-type\">int</span> key = arr[i];<br>    <span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>      arr[j + <span class=\"hljs-number\">1</span>] = arr[j];<br>      j--;<br>    &#125;<br>    arr[j + <span class=\"hljs-number\">1</span>] = key;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这是gemini的解释，我觉得很形象</p>\n<hr>\n<blockquote>\n<p>它的核心思想是模拟我们<strong>玩扑克牌时整理手牌</strong>的动作。</p>\n<h3 id=\"🃏-插入排序的核心比喻-整理手牌\"><a href=\"#🃏-插入排序的核心比喻-整理手牌\" class=\"headerlink\" title=\"🃏 插入排序的核心比喻 (整理手牌)\"></a>🃏 插入排序的核心比喻 (整理手牌)</h3><p>想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（<code>key</code>）。</p>\n<p>你会怎么做？</p>\n<ol>\n<li> 你从左手中<strong>最右边</strong>的牌（<code>j</code>）开始，和你的新牌（<code>key</code>）比较。</li>\n<li> 如果左手的牌（<code>arr[j]</code>）比你的新牌（<code>key</code>）大，你就把这张牌<strong>往右移一个位置</strong>（<code>arr[j + 1] = arr[j]</code>），腾出它原来的空位。</li>\n<li> 你继续看左手边下一张牌（<code>j--</code>），重复这个比较。</li>\n<li> 直到你找到一张比新牌（<code>key</code>）小的牌，或者你已经比较完了所有手里的牌 ( <code>j &lt; 0</code> )。</li>\n<li> 这时，你找到了正确的位置，把你手里的新牌（<code>key</code>）<strong>插入</strong>到刚刚腾出来的那个空位上（<code>arr[j + 1] = key</code>）。</li>\n</ol>\n</blockquote>\n<hr>\n<p>如果基本有序，就可以使用这个插入算法。  </p>\n<blockquote>\n<p>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。</p>\n</blockquote>\n<p><em><strong>至少下一个排序很有用</strong></em></p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p><a href=\"https://www.luogu.com.cn/problem/P1177\">洛谷P1177</a>就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  </p>\n<p>不行了这个gemini讲的太好了,我直接复制就行</p>\n<hr>\n<p>您可以把快速排序想象成一个“<strong>不断找人站队</strong>”的过程。</p>\n<h3 id=\"快速排序的核心思想\"><a href=\"#快速排序的核心思想\" class=\"headerlink\" title=\"快速排序的核心思想\"></a>快速排序的核心思想</h3><p>正如您资料中提到的，它的核心是 <strong>“分治”（Divide and Conquer）</strong>。</p>\n<p>简单来说，就是：</p>\n<ol>\n<li><strong>找一个“基准” (Pivot)：</strong> 在队伍里（数组中）随便挑一个人（一个数）当“基准”。</li>\n<li><strong>站队 (Partition)：</strong> 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。</li>\n<li><strong>分而治之 (Recurse)：</strong> 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别<strong>重复</strong>第1步和第2步。</li>\n<li><strong>完成：</strong> 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。</li>\n</ol>\n<hr>\n<h3 id=\"详细解释您提供的-C-代码\"><a href=\"#详细解释您提供的-C-代码\" class=\"headerlink\" title=\"详细解释您提供的 C++ 代码\"></a>详细解释您提供的 C++ 代码</h3><p>您提供的代码是实现这个过程的经典方法。我们一步一步来看：</p>\n<h4 id=\"1-Partition-函数（最关键的“站队”过程）\"><a href=\"#1-Partition-函数（最关键的“站队”过程）\" class=\"headerlink\" title=\"1. Partition 函数（最关键的“站队”过程）\"></a>1. <code>Partition</code> 函数（最关键的“站队”过程）</h4><p>这个函数的目标是：<strong>选定一个基准，并完成“站队”</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Partition</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>&#123;<span class=\"hljs-comment\">//这里low是排序的第一个指针， high是最后一个指针</span><br>  <span class=\"hljs-type\">int</span> pivot = A[low]; <span class=\"hljs-comment\">// 1. 选择基准：就选第一个元素当基准 (pivot)</span><br>                      <span class=\"hljs-comment\">//    此时 A[low] 这个位置可以看成一个“坑”</span><br><br>  <span class=\"hljs-keyword\">while</span> (low &lt; high) &#123; <span class=\"hljs-comment\">// 2. 只要左右指针没相遇，就继续</span><br>    <br>    <span class=\"hljs-comment\">// 3. 从右往左找“小”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; pivot &lt;= A[high]) --high; <br>    A[low] = A[high]; <span class=\"hljs-comment\">// 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”</span><br><br>    <span class=\"hljs-comment\">// 5. 从左往右找“大”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; <br>    A[high] = A[low]; <span class=\"hljs-comment\">// 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”</span><br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 7. 循环结束，low 和 high 相遇了</span><br>  A[low] = pivot; <span class=\"hljs-comment\">// 8. 把一开始存的基准值，放回这个最后的“坑”</span><br>  <span class=\"hljs-keyword\">return</span> low;     <span class=\"hljs-comment\">// 9. 返回基准最后站的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>用一个例子来模拟 <code>Partition</code>：</strong><br>假设数组是 <code>[5, 2, 8, 1, 9, 4]</code>，<code>low = 0</code>, <code>high = 5</code>。</p>\n<ol>\n<li><code>pivot = A[low]</code>，<code>pivot</code> 存了 <strong>5</strong>。 <code>A[0]</code> 现在是“坑”。<br>数组：<code>[坑, 2, 8, 1, 9, 4]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）找比 5 小的。<ul>\n<li><code>A[5]</code> 是 4。比 5 小。</li>\n</ul>\n</li>\n<li>把 4 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[0]</code>)。<code>A[5]</code> 变成新“坑”。<br>数组：<code>[4, 2, 8, 1, 9, 坑]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 0 开始）找比 5 大的。<ul>\n<li><code>A[0]</code> 是 4。</li>\n<li><code>A[1]</code> 是 2。</li>\n<li><code>A[2]</code> 是 8。比 5 大。</li>\n</ul>\n</li>\n<li>把 8 扔到右边的“坑” (<code>A[high]</code> 即 <code>A[5]</code>)。<code>A[2]</code> 变成新“坑”。<br>数组：<code>[4, 2, 坑, 1, 9, 8]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）…<ul>\n<li>… <code>A[4]</code> 是 9。</li>\n<li><code>A[3]</code> 是 1。比 5 小。</li>\n</ul>\n</li>\n<li>把 1 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[2]</code>)。<code>A[3]</code> 变成新“坑”。<br>数组：<code>[4, 2, 1, 坑, 9, 8]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 2 开始）…<ul>\n<li><code>A[2]</code> 是 1。</li>\n<li><code>A[3]</code>… <code>low</code> 和 <code>high</code> 在 3 这个位置相遇了。循环 <code>while (low &lt; high)</code> 结束。</li>\n</ul>\n</li>\n<li>把 <code>pivot</code> (存的 <strong>5</strong>) 放到 <code>A[low]</code> (即 <code>A[3]</code>)。<br>数组：<code>[4, 2, 1, 5, 9, 8]</code></li>\n<li>返回 <code>low</code> (即 3)。</li>\n</ol>\n<p><strong>看，现在数组变成了 <code>[4, 2, 1]</code> （都比5小） | <code>5</code> | <code>[9, 8]</code> （都比5大）。</strong> 这就是“站队”！</p>\n<hr>\n<h4 id=\"2-QuickSort-函数（“分而治之”的递归）\"><a href=\"#2-QuickSort-函数（“分而治之”的递归）\" class=\"headerlink\" title=\"2. QuickSort 函数（“分而治之”的递归）\"></a>2. <code>QuickSort</code> 函数（“分而治之”的递归）</h4><p>这个函数是“分治”思想的体现，它来“指挥”<code>Partition</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">QuickSort</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (low &lt; high) &#123; <span class=\"hljs-comment\">// 如果队伍里至少有2个人</span><br>    <span class=\"hljs-comment\">// 1. 先站队，并拿到基准最后的位置</span><br>    <span class=\"hljs-type\">int</span> pivot_pos = <span class=\"hljs-built_in\">Partition</span>(A, low, high); <br>    <br>    <span class=\"hljs-comment\">// 2. 指挥“左队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, low, pivot_pos - <span class=\"hljs-number\">1</span>); <br>    <br>    <span class=\"hljs-comment\">// 3. 指挥“右队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, pivot + <span class=\"hljs-number\">1</span>, high); <br>  &#125;<br>  <span class=\"hljs-comment\">// 如果 low &gt;= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>QuickSort</code> 函数是<strong>宏观管理者</strong>：它负责“分”，决定对哪一段（从 <code>low</code> 到 <code>high</code>）进行排序。</li>\n<li><code>Partition</code> 函数是<strong>具体执行者</strong>：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。</li>\n<li>通过<strong>递归</strong>，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。</li>\n</ol>\n<p>您提供的资料中提到“不用合并”，就是因为 <code>Partition</code> 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。</p>\n<hr>\n<p>后面还有<a href=\"https://oi-wiki.org/basic/quick-sort/\">优化算法</a>，我真不想看了，之后有空再看。</p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>我草怎么还有。。。<br>直接放<a href=\"https://oi-wiki.org/basic/merge-sort/\">归并</a>的链接吧</p>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实还有sort函数，要写一个函数作为排序的算法。<br>我感觉我这样学习效率很低，应该做题，不会的再去查概念。<br>先去吃个饭，等下学递归的时候改一下学习方法。</p>\n"},{"title":"test","date":"2025-10-31T13:46:35.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2025-10-31 21:46:35\ntags:\n---\n","slug":"test","published":1,"updated":"2025-10-31T13:46:35.799Z","comments":1,"layout":"post","photos":[],"_id":"cuidoGm9v92gRza9kHMRtN1A_","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"小小吐槽","date":"2025-11-03T04:20:08.000Z","cover":"/images/ri_chang.jpg","_content":"噫嘘唏，数字电路之难。。。  \n\n现在是中午12点30分，还有三十分钟上程设。  \n\n而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    \n\n真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  \n\n难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！\n\n哦哦还有信息安全 ~~这个是我真没听~~ 马上要结课了，知识点我还没听过一个字呢。  \n\n这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 *KFC* 。至少这能让我心情愉快对吧。\n\n写了一半去上课了，又是听莫名奇妙的c语言知识点。~~***如果只听这些就能找到工作这个世界才完蛋了***~~。又是最后一排摸鱼的一天。\n\n去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。\n\n妈的，我梦想的轻松大学生活到底被谁偷了。\n\n或许明天要轻松点吧，就一节英语，晚上把作业写了就好。\n\n哦，晚上还要开会开到十点。\n\n__杀了我吧。__\n\n不能再写了，再写又浪费了不知道多久时间。\n\n放首歌给我自己听。\n\n{% biliplayer BV1Bt411873Y %}","source":"_posts/tucao.md","raw":"---\ntitle: 小小吐槽\ndate: 2025-11-03 12:20:08\ntags:\n    - 吐槽\ncategories:\n    - 日常\ncover: /images/ri_chang.jpg\n---\n噫嘘唏，数字电路之难。。。  \n\n现在是中午12点30分，还有三十分钟上程设。  \n\n而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    \n\n真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  \n\n难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！\n\n哦哦还有信息安全 ~~这个是我真没听~~ 马上要结课了，知识点我还没听过一个字呢。  \n\n这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 *KFC* 。至少这能让我心情愉快对吧。\n\n写了一半去上课了，又是听莫名奇妙的c语言知识点。~~***如果只听这些就能找到工作这个世界才完蛋了***~~。又是最后一排摸鱼的一天。\n\n去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。\n\n妈的，我梦想的轻松大学生活到底被谁偷了。\n\n或许明天要轻松点吧，就一节英语，晚上把作业写了就好。\n\n哦，晚上还要开会开到十点。\n\n__杀了我吧。__\n\n不能再写了，再写又浪费了不知道多久时间。\n\n放首歌给我自己听。\n\n{% biliplayer BV1Bt411873Y %}","slug":"tucao","published":1,"updated":"2025-11-08T09:45:22.483Z","comments":1,"layout":"post","photos":[],"_id":"cuidXh_nOT0SINbNc_8GTULM1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>噫嘘唏，数字电路之难。。。  </p>\n<p>现在是中午12点30分，还有三十分钟上程设。  </p>\n<p>而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    </p>\n<p>真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  </p>\n<p>难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！</p>\n<p>哦哦还有信息安全 <del>这个是我真没听</del> 马上要结课了，知识点我还没听过一个字呢。  </p>\n<p>这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 <em>KFC</em> 。至少这能让我心情愉快对吧。</p>\n<p>写了一半去上课了，又是听莫名奇妙的c语言知识点。<del><em><strong>如果只听这些就能找到工作这个世界才完蛋了</strong></em></del>。又是最后一排摸鱼的一天。</p>\n<p>去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。</p>\n<p>妈的，我梦想的轻松大学生活到底被谁偷了。</p>\n<p>或许明天要轻松点吧，就一节英语，晚上把作业写了就好。</p>\n<p>哦，晚上还要开会开到十点。</p>\n<p><strong>杀了我吧。</strong></p>\n<p>不能再写了，再写又浪费了不知道多久时间。</p>\n<p>放首歌给我自己听。</p>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1Bt411873Y&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0\" style=\"width: 62em; height: 35em;\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe></body></html>","excerpt":"","more":"<p>噫嘘唏，数字电路之难。。。  </p>\n<p>现在是中午12点30分，还有三十分钟上程设。  </p>\n<p>而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    </p>\n<p>真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  </p>\n<p>难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！</p>\n<p>哦哦还有信息安全 <del>这个是我真没听</del> 马上要结课了，知识点我还没听过一个字呢。  </p>\n<p>这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 <em>KFC</em> 。至少这能让我心情愉快对吧。</p>\n<p>写了一半去上课了，又是听莫名奇妙的c语言知识点。<del><em><strong>如果只听这些就能找到工作这个世界才完蛋了</strong></em></del>。又是最后一排摸鱼的一天。</p>\n<p>去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。</p>\n<p>妈的，我梦想的轻松大学生活到底被谁偷了。</p>\n<p>或许明天要轻松点吧，就一节英语，晚上把作业写了就好。</p>\n<p>哦，晚上还要开会开到十点。</p>\n<p><strong>杀了我吧。</strong></p>\n<p>不能再写了，再写又浪费了不知道多久时间。</p>\n<p>放首歌给我自己听。</p>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1Bt411873Y&page=1&as_wide=1&high_quality=1&danmaku=0\"\nstyle=\"width: 62em; height: 35em;\"\nallowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>"}],"PostAsset":[{"_id":"source/_posts/Another_Page/cover_Another_Page.jpg","slug":"cover_Another_Page.jpg","post":"cuid4tYE5P1hd-w5o-EjLAFx9","modified":0,"renderable":0},{"_id":"source/_posts/Another_Page/image1.jpg","slug":"image1.jpg","post":"cuid4tYE5P1hd-w5o-EjLAFx9","modified":0,"renderable":0},{"_id":"source/_posts/Another_Page/image2.jpg","slug":"image2.jpg","post":"cuid4tYE5P1hd-w5o-EjLAFx9","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cuid4tYE5P1hd-w5o-EjLAFx9","category_id":"cuid9aOgD6sLL1Gh5isEHSNOG","_id":"cuidLVZRJwCOfxD5WTqZXfWA7"},{"post_id":"cuidrSeEai2EWWXetJju_6ZrF","category_id":"cuidJOSPQk3YZbZxvZOH5NDKw","_id":"cuid3-KnKder4twr83NuzSwZ2"},{"post_id":"cuiddnvVZx2OfPViH-V85wQJV","category_id":"cuidDmF7ARvsiWJ993zazYXOX","_id":"cuid3KFphnCefGD_OSoHs_dQp"},{"post_id":"cuidk9tQx0WzoLet_B9x6C8Wf","category_id":"cuidJOSPQk3YZbZxvZOH5NDKw","_id":"cuid96IYPeecFlIvVj-9mgDVk"},{"post_id":"cuid2Z_LqxZo6ny3lyNcLe6L7","category_id":"cuidJOSPQk3YZbZxvZOH5NDKw","_id":"cuidxFYIwOG-AWm_nm7o_wJk9"},{"post_id":"cuid1aivnn5X1TqaJH-0qiLSa","category_id":"cuidJOSPQk3YZbZxvZOH5NDKw","_id":"cuid6nLAzc2-4Zfp5OmZ1p9Dt"},{"post_id":"cuidOYf4kH2juGa8Q0IqGDNYS","category_id":"cuidJOSPQk3YZbZxvZOH5NDKw","_id":"cuidfqX41Vqu-GyPboa--uZ86"},{"post_id":"cuidXh_nOT0SINbNc_8GTULM1","category_id":"cuidntwAN0NmbESCr8aAXPPFo","_id":"cuid1K0rO-e4PN-t_lgyOV6-v"}],"PostTag":[{"post_id":"cuid4tYE5P1hd-w5o-EjLAFx9","tag_id":"cuidBlTc1vDq8FarGNHHdKjBz","_id":"cuidxzSlMqRsMThLccCvMahI2"},{"post_id":"cuidXh_nOT0SINbNc_8GTULM1","tag_id":"cuidExIxsCmEsLPGjkPCr7T-1","_id":"cuidetiGggIccCygPb9DKXnIJ"}],"Tag":[{"name":"胡思乱想","_id":"cuidBlTc1vDq8FarGNHHdKjBz"},{"name":"吐槽","_id":"cuidExIxsCmEsLPGjkPCr7T-1"}]}}
=======
{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-kira/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/constants.styl","path":"css/constants.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/color.styl","path":"css/color.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/content.styl","path":"css/content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-code-copy.styl","path":"css/kira-code-copy.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-friends.styl","path":"css/kira-friends.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/kira-image.styl","path":"css/kira-image.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/media.styl","path":"css/media.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/post.styl","path":"css/post.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/right-column.styl","path":"css/right-column.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/css/sidebar.styl","path":"css/sidebar.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/js/kira-code-copy.js","path":"js/kira-code-copy.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/js/kira-image.js","path":"js/kira-image.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/lazysizes.js","path":"lib/lazysizes.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/smooth-scrolling.js","path":"lib/smooth-scrolling.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/css/APlayer.min.css","path":"deps/css/APlayer.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/js/APlayer.min.js","path":"deps/js/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/deps/js/Meting.min.js","path":"deps/js/Meting.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/atom-one-dark.min.css","path":"lib/highlight/atom-one-dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/highlight.min.js","path":"lib/highlight/highlight.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.css","path":"lib/mdui/mdui.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.js","path":"lib/mdui/mdui.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Bold.woff2","path":"lib/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Regular.woff2","path":"lib/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Medium.woff2","path":"lib/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/background.png","path":"images/background.png","modified":0,"renderable":0},{"_id":"source/images/cover_Another_Page.jpg","path":"images/cover_Another_Page.jpg","modified":0,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/ri_chang.jpg","path":"images/ri_chang.jpg","modified":0,"renderable":0},{"_id":"source/images/note_cover.jpg","path":"images/note_cover.jpg","modified":0,"renderable":0},{"_id":"source/images/oi_cover.jpg","path":"images/oi_cover.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/archive.md","hash":"00d3773d9b4a900f930fab0daa16a60e505470b1","modified":1762595122484},{"_id":"source/about/index.md","hash":"35fdf3afd5d1d95585b8af4ed10c294f08670a62","modified":1762595122484},{"_id":"source/note/index.md","hash":"5acb79eb1ebc329939a4f6e1a6d043f1e6424f9a","modified":1762595122500},{"_id":"source/_posts/Another_Page.md","hash":"f43eb6dbd5d500525bce7a1ae74c4dae1baa63d0","modified":1762595122477},{"_id":"source/_posts/test.md","hash":"0424346b162534c4d4ddb25542fe4959e3c90f84","modified":1761918395799},{"_id":"source/_posts/tucao.md","hash":"0a4f8931579ec4539badd287380ecad15c209f47","modified":1762595122483},{"_id":"source/images/avatar.jpg","hash":"1200d19dd2c6781c320658e4b5f120ea84eded02","modified":1762088600350},{"_id":"source/images/logo.jpg","hash":"d588814657ae54a23639b80fbf0ab91b05e8b775","modified":1762088607904},{"_id":"source/_posts/Another_Page/image1.jpg","hash":"61d9dfe8d775d04caf01fa01d4014dcee24251af","modified":1762098182583},{"_id":"source/images/ri_chang.jpg","hash":"c4a5ac1aae09ce542056f2fbfb96c5852e3adf5e","modified":1762143873359},{"_id":"source/images/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1762102316022},{"_id":"source/_posts/Another_Page/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1762102316022},{"_id":"node_modules/hexo-theme-kira/languages/default.yml","hash":"975a90fd111336055181085e3c27e6f67d41f68b","modified":1762090396555},{"_id":"node_modules/hexo-theme-kira/languages/en.yml","hash":"d3e7f13edbe8c6fcf1c18f679c8fa9f919941d5b","modified":1762090396557},{"_id":"node_modules/hexo-theme-kira/languages/it.yml","hash":"708e1a520eebd468b9895fe5f80c79c1cdca0fc8","modified":1762090396559},{"_id":"node_modules/hexo-theme-kira/LICENSE","hash":"16401737d2489b2399c6bcb2274e8835bc21c2ec","modified":1762090395566},{"_id":"node_modules/hexo-theme-kira/readme.md","hash":"a32af4ed2ed53d223ad5456a5e0a45b46972306a","modified":1762090396434},{"_id":"node_modules/hexo-theme-kira/package.json","hash":"7366cfb765732b16fa06f243a6cce21b6aeb1749","modified":1762090396429},{"_id":"node_modules/hexo-theme-kira/languages/ja.yml","hash":"2f848f022dd6eb70893dbf0d1f68440d487b285e","modified":1762090396561},{"_id":"node_modules/hexo-theme-kira/layout/archives.ejs","hash":"bc09ed31aea541e207edfa0dc1482f74ed6d8361","modified":1762090396014},{"_id":"node_modules/hexo-theme-kira/layout/index.ejs","hash":"d7dd4eba4d8b4306f78e59b7f7b7142e5e9755f2","modified":1762090396198},{"_id":"node_modules/hexo-theme-kira/layout/layout.ejs","hash":"8b693f9d8f1579f29c3585b1f68edb0d9eea8945","modified":1762090396220},{"_id":"node_modules/hexo-theme-kira/layout/friends.ejs","hash":"0702afdbfa01a4266a29f3e018928a3a4aedd16a","modified":1762090396123},{"_id":"node_modules/hexo-theme-kira/languages/zh-HK.yml","hash":"52c501d778ed22d242c0cd405db38c985dbccfce","modified":1762090396566},{"_id":"node_modules/hexo-theme-kira/languages/zh-CN.yml","hash":"975a90fd111336055181085e3c27e6f67d41f68b","modified":1762090396564},{"_id":"node_modules/hexo-theme-kira/layout/post.ejs","hash":"4ec75cf603d272ed094ea79c615cda56b861bdcb","modified":1762090396230},{"_id":"node_modules/hexo-theme-kira/languages/zh-TW.yml","hash":"52c501d778ed22d242c0cd405db38c985dbccfce","modified":1762090396569},{"_id":"node_modules/hexo-theme-kira/layout/_widget/social.ejs","hash":"78ee34ba7813bc3cb9ac0155a251a7db5fc20668","modified":1762090396262},{"_id":"node_modules/hexo-theme-kira/layout/_widget/archive.ejs","hash":"1b7927c453a4ba3bc91f57585d1c9a028f3a2634","modified":1762090395987},{"_id":"node_modules/hexo-theme-kira/layout/_widget/tagcloud.ejs","hash":"ae70b1e05f4b9e0bdc4bc4946aab9a2f04b62441","modified":1762090396271},{"_id":"node_modules/hexo-theme-kira/layout/components/copyright.ejs","hash":"7a6bf6be3cd1605c7974a33baf8b54a90a50b141","modified":1762090396077},{"_id":"node_modules/hexo-theme-kira/layout/components/friends.ejs","hash":"1833dafebc1997996b8c77d55683b1d97de2a71b","modified":1762090396110},{"_id":"node_modules/hexo-theme-kira/layout/_widget/category.ejs","hash":"249ecb1c70bcbb5dd792deb7ca597ece06497cac","modified":1762090396047},{"_id":"node_modules/hexo-theme-kira/scripts/tag/biliplayer.js","hash":"573c7bd45e38c96c5cad922e23d19e1abd70fb7b","modified":1762090396308},{"_id":"node_modules/hexo-theme-kira/layout/components/header.ejs","hash":"c1e28f64f4ea8cbccb77bcb7ebd78a7bbecf2f94","modified":1762090396178},{"_id":"node_modules/hexo-theme-kira/scripts/utils/image_auto_lazyload.js","hash":"fef224ee29365821af9a0d4fe18f99665a65eb80","modified":1762090396356},{"_id":"node_modules/hexo-theme-kira/layout/components/right-column.ejs","hash":"6db93a9722a5288f96ab16dd54783e187909657f","modified":1762090396241},{"_id":"node_modules/hexo-theme-kira/source/css/archive.styl","hash":"014aeb1e8edee23ab191accde28b903094e0250a","modified":1762090396447},{"_id":"node_modules/hexo-theme-kira/scripts/tag/codepen.js","hash":"8b871ebc448984b97559f07313845c384080ed0f","modified":1762090396317},{"_id":"node_modules/hexo-theme-kira/source/css/article.styl","hash":"5d71b0348e8777d44fcac4dd1b42691bb60ca0a0","modified":1762090396455},{"_id":"node_modules/hexo-theme-kira/scripts/tag/kira-player.js","hash":"cfbae6ff10abc986ea05044c536b6870f3c2a0f5","modified":1762090396378},{"_id":"node_modules/hexo-theme-kira/scripts/tag/meting.js","hash":"9d9474ea97a789b3c1d7b1153c30475eca0967d9","modified":1762090396405},{"_id":"node_modules/hexo-theme-kira/layout/components/kira-image.ejs","hash":"3222ae7c8d79afc3cd5ed0f1e8ef1b51b3fdda36","modified":1762090396210},{"_id":"node_modules/hexo-theme-kira/layout/components/sidebar.ejs","hash":"f3a34ba45e03f231a0acc2ca81214cbb61c80d7e","modified":1762090396252},{"_id":"node_modules/hexo-theme-kira/source/css/constants.styl","hash":"9882f6fdf8b0a840b461fe68b5a5781ac5f9a135","modified":1762090396465},{"_id":"node_modules/hexo-theme-kira/source/css/color.styl","hash":"de24fe89ea6609bedb10d6883813900613bc666c","modified":1762090396460},{"_id":"node_modules/hexo-theme-kira/source/css/content.styl","hash":"f855d66a230c058d879afabe9440d6983228f75c","modified":1762090396469},{"_id":"node_modules/hexo-theme-kira/source/css/kira-code-copy.styl","hash":"0ec2c5bee6b740d1c470b1552b0489ce2752a43b","modified":1762090396475},{"_id":"node_modules/hexo-theme-kira/source/css/kira-friends.styl","hash":"174acae9379c2521e9658ee7a9cca78121efdb56","modified":1762090396479},{"_id":"node_modules/hexo-theme-kira/source/css/kira-image.styl","hash":"6012db7df3e0491f2469025b8e39e3542a389e00","modified":1762090396485},{"_id":"node_modules/hexo-theme-kira/source/css/layout.styl","hash":"4638f0d7f257287e680ac67abd3241331a7f57c5","modified":1762090396491},{"_id":"node_modules/hexo-theme-kira/source/css/media.styl","hash":"24e882ac68cc8ae1bbcdd156192101c68859bdc7","modified":1762090396496},{"_id":"node_modules/hexo-theme-kira/source/js/kira-code-copy.js","hash":"768b978c8bef776a5ac32b3c86df498b881f882b","modified":1762090396363},{"_id":"node_modules/hexo-theme-kira/source/css/post.styl","hash":"30165070270d51377ab8a5b2bd6ee03d81c2ab26","modified":1762090396501},{"_id":"node_modules/hexo-theme-kira/source/js/kira-image.js","hash":"84aa358b87ca68af35b331fc1c807f68f8c22dd4","modified":1762090396371},{"_id":"node_modules/hexo-theme-kira/source/css/right-column.styl","hash":"a50707cf85e00790344d1822ca6aaf3482e06e90","modified":1762090396505},{"_id":"node_modules/hexo-theme-kira/source/css/sidebar.styl","hash":"172f73ad5a78d7976a3b0e8f69672270520002ff","modified":1762090396512},{"_id":"node_modules/hexo-theme-kira/source/lib/lazysizes.js","hash":"3d7d083ddd43da4fbc5af70d888ad2f39d7c5f9b","modified":1762090396385},{"_id":"node_modules/hexo-theme-kira/source/lib/smooth-scrolling.js","hash":"13c907c5a0df08f4a94be5ee2ca544b5a5a247ad","modified":1762090396420},{"_id":"node_modules/hexo-theme-kira/source/deps/css/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1762090395594},{"_id":"node_modules/hexo-theme-kira/source/deps/js/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1762090396300},{"_id":"node_modules/hexo-theme-kira/layout/components/comments/giscus.ejs","hash":"2df2a6b98e5060d0c2dd2ef9bb2f6a690a747e16","modified":1762090396142},{"_id":"node_modules/hexo-theme-kira/layout/components/comments/gitalk.ejs","hash":"6ea24c937c1b38598323cae3f42c2a5e12d8fff0","modified":1762090396160},{"_id":"node_modules/hexo-theme-kira/source/deps/js/Meting.min.js","hash":"c9a7d747dfa8fe4d3fc7ddb096b0506f55ff1fd4","modified":1762090396413},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/atom-one-dark.min.css","hash":"56dddcd32332b54853ba9eadba3c883f95f00275","modified":1762090395651},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1762090395713},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/demo_index.html","hash":"65b9325f267371c9e5a07a7a3a224c5766d07c18","modified":1762090396285},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.css","hash":"84918de2a2e36d051ee51c3ea17f5d6e601714da","modified":1762090395783},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.json","hash":"fccceb7956fd4f43c5ce1a18a100513ba353753c","modified":1762090396426},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff","hash":"7938931f0d753453933c6c75ff1ff1d02b51c983","modified":1762090396525},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.js","hash":"72c1211ab8026e3f7419f05bf8860fac6e96fe65","modified":1762090396350},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.ttf","hash":"a066712350eb107bdfeb78130ec4ce58d3a29655","modified":1762090396520},{"_id":"node_modules/hexo-theme-kira/source/lib/iconfont/iconfont.woff2","hash":"47b0a99b271ef70b3663dab0d611e471db59a49b","modified":1762090396530},{"_id":"source/_posts/Another_Page/image2.jpg","hash":"cd470cd89bac0ec6ad5b1ae7bc0362493e454f62","modified":1762102525767},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1762090396537},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1762090396553},{"_id":"node_modules/hexo-theme-kira/source/lib/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1762090396545},{"_id":"node_modules/hexo-theme-kira/source/lib/highlight/highlight.min.js","hash":"9b0794e07fb0b700c73032b6ea596d88b2bbe196","modified":1762090396338},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.js","hash":"003a814293e06d95d569b7ba7bb4d2eb2a774caa","modified":1762090396398},{"_id":"node_modules/hexo-theme-kira/source/lib/mdui/mdui.min.css","hash":"5b08b35be36d94907e2205c3ed221db03a1f7b69","modified":1762090395958},{"_id":"source/images/background.png","hash":"b6d89125771f420fcb606f9f3176fd425b854694","modified":1753496499832},{"_id":"source/_posts/c-languange-midterm.md","hash":"77f1820d30c6d6b839ce2a60cdcd1e4cd3cc5b7f","modified":1763279954085},{"_id":"source/_posts/digui.md","hash":"ddcf15966fcc6028b8205ef19f11a90228162a5b","modified":1762595122481},{"_id":"source/_posts/digui1.md","hash":"6b497fa36be132ca3bb0e016731f77aafc62cdb5","modified":1762595122482},{"_id":"source/_posts/note-example.md","hash":"685ce6df7296c5813d5e8e2466ba88fd7a8d40fc","modified":1762595122482},{"_id":"source/_posts/oi-note-description.md","hash":"54de7a0d864e6574e09aaa20db7e2efdf6688ccc","modified":1762595122482},{"_id":"source/_posts/paixu1.md","hash":"67402979901eb545c068abf224af66fc1bac22ca","modified":1762595122483},{"_id":"source/images/oi_cover.jpg","hash":"3fcc1a62714617e401ba2ec86a1534d07445b48b","modified":1762595122498},{"_id":"source/images/note_cover.jpg","hash":"ded2453441d2e97bc2cd957f81b4fa91d471db3c","modified":1763279580700},{"_id":"public/archive.html","hash":"be9e26941069239c9081392473958116173fa263","modified":1763279976299},{"_id":"public/note/index.html","hash":"2df2c47f739193d139ec279a809205008829749b","modified":1763279976299},{"_id":"public/2025/11/16/c-languange-midterm/index.html","hash":"f9c6342019b0db530e6d3b23b93296f000d8b240","modified":1763279976299},{"_id":"public/about/index.html","hash":"77111770df220258cffd41e0d681f959c3e7e594","modified":1763279976299},{"_id":"public/2025/11/05/note-example/index.html","hash":"6f235ade71f1413ba0f24334afffd2142aee0adf","modified":1763279976299},{"_id":"public/2025/11/05/paixu1/index.html","hash":"caf1475c2f569d78c3211b9419919c1b753638e8","modified":1763279976299},{"_id":"public/2025/11/05/oi-note-description/index.html","hash":"24720de532240a4d3b4a1d939eb76ea3b854a5ed","modified":1763279976299},{"_id":"public/2025/11/03/tucao/index.html","hash":"243f9f68b496121630022ed9feecb23775b7fad7","modified":1763279976299},{"_id":"public/2025/11/02/Another_Page/index.html","hash":"270a28949c33c55345289b9fcf1eea0ba47f477c","modified":1763279976299},{"_id":"public/2025/10/31/test/index.html","hash":"ebba80f473913f668ebe235ef2ac4fff2e53451f","modified":1763279976299},{"_id":"public/archives/index.html","hash":"4e70e5082a42a6576bf7dd8a6bd65cb9f26002c6","modified":1763279976299},{"_id":"public/archives/2025/10/index.html","hash":"87bbcfe5001dbec76f5cade22c82c5a030054316","modified":1763279976299},{"_id":"public/archives/2025/index.html","hash":"38f0ac277d9256628f65f994135144bef6351781","modified":1763279976299},{"_id":"public/archives/2025/11/index.html","hash":"5d021a3016eacb1343c8add007f4d2eb9374ef50","modified":1763279976299},{"_id":"public/categories/一些碎碎念/index.html","hash":"bb265af8666e9ba881e58632360062d89911a44f","modified":1763279976299},{"_id":"public/categories/日常/index.html","hash":"3d7e254a45829f504cb7acbaacf0b1d795a7800f","modified":1763279976299},{"_id":"public/categories/大学学习笔记/index.html","hash":"379ed6373bdb062af9b047dd253a8ff54fb32cf1","modified":1763279976299},{"_id":"public/categories/算法学习笔记/index.html","hash":"bc88e165c0b13bcf57fcff812367239022585251","modified":1763279976299},{"_id":"public/tags/胡思乱想/index.html","hash":"d027cd6cd09c8625dd27755d0b20cfa585e746f3","modified":1763279976299},{"_id":"public/index.html","hash":"9441a8cabc71b60d6e51c379aebbab5319f56c2d","modified":1763279976299},{"_id":"public/tags/吐槽/index.html","hash":"bf5e53e27e6a3300ad60a98e03928f0b3efcfb99","modified":1763279976299},{"_id":"public/lib/iconfont/iconfont.woff","hash":"7938931f0d753453933c6c75ff1ff1d02b51c983","modified":1763279976299},{"_id":"public/lib/iconfont/iconfont.ttf","hash":"a066712350eb107bdfeb78130ec4ce58d3a29655","modified":1763279976299},{"_id":"public/lib/iconfont/iconfont.woff2","hash":"47b0a99b271ef70b3663dab0d611e471db59a49b","modified":1763279976299},{"_id":"public/lib/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1763279976299},{"_id":"public/lib/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1763279976299},{"_id":"public/lib/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1763279976299},{"_id":"public/css/article.css","hash":"534dcfa3e3263a517c78af7129ed90664cb5a932","modified":1763279976299},{"_id":"public/css/archive.css","hash":"f2e607d91144f695c7c37aba2ff3412ee650e2f6","modified":1763279976299},{"_id":"public/css/content.css","hash":"2b9f949c73dcf423afa7a4cf263b7dab13f8db06","modified":1763279976299},{"_id":"public/css/constants.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1763279976299},{"_id":"public/css/kira-code-copy.css","hash":"e2e06b934d904d17afd80023cd219736d95d45dd","modified":1763279976299},{"_id":"public/css/color.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1763279976299},{"_id":"public/css/kira-image.css","hash":"e7f148597ad415ee431676cf694118f197e2bccc","modified":1763279976299},{"_id":"public/css/layout.css","hash":"7287fc37de97906622ba253e061a3ab5520d141f","modified":1763279976299},{"_id":"public/css/media.css","hash":"2add1ea023389a10ab5899749097adf68ddc27a5","modified":1763279976299},{"_id":"public/css/post.css","hash":"2c17a348b346072c24361c51e1b1519cef4a026d","modified":1763279976299},{"_id":"public/css/kira-friends.css","hash":"737dc0fd52d21322f9da44f8f439c14d24562641","modified":1763279976299},{"_id":"public/css/sidebar.css","hash":"82078bacb367b75625c6a61dbf036068702323cc","modified":1763279976299},{"_id":"public/css/right-column.css","hash":"be70153defb41896afe1efcaa96455e38b820e4a","modified":1763279976299},{"_id":"public/js/kira-code-copy.js","hash":"8229b6a7b22b313e99334d347463deaf17a92c94","modified":1763279976299},{"_id":"public/js/kira-image.js","hash":"833d671ac4f4bc9020914250f4708e27f7bd4fbe","modified":1763279976299},{"_id":"public/lib/lazysizes.js","hash":"460d0fc31226c9865b16d23b60200ddcd1c3feb4","modified":1763279976299},{"_id":"public/lib/smooth-scrolling.js","hash":"9eb8797a5d71849192d9e2ab6a7626c5c512be91","modified":1763279976299},{"_id":"public/deps/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1763279976299},{"_id":"public/deps/js/Meting.min.js","hash":"1b76611da71b63f7c0c1f04601a8ec02b0650667","modified":1763279976299},{"_id":"public/deps/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1763279976299},{"_id":"public/lib/highlight/atom-one-dark.min.css","hash":"56dddcd32332b54853ba9eadba3c883f95f00275","modified":1763279976299},{"_id":"public/lib/highlight/highlight.min.js","hash":"f599d9b58453de85ab2ee2e68b2702a3d55c0830","modified":1763279976299},{"_id":"public/lib/iconfont/demo_index.html","hash":"b7b1a61ac0c224ee9f74a1b3e2caf2a0dfc0b486","modified":1763279976299},{"_id":"public/lib/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1763279976299},{"_id":"public/lib/iconfont/iconfont.json","hash":"22fc847df082b51e1fb4f5a0cd234f2949bc6cbc","modified":1763279976299},{"_id":"public/lib/iconfont/iconfont.css","hash":"cee8b34fa5a48b6cac84115af7e4f9f454aa9bba","modified":1763279976299},{"_id":"public/lib/iconfont/iconfont.js","hash":"72c1211ab8026e3f7419f05bf8860fac6e96fe65","modified":1763279976299},{"_id":"public/lib/mdui/mdui.min.css","hash":"839d68be2a7fd54543f43335482047dd4becd43a","modified":1763279976299},{"_id":"public/lib/mdui/mdui.min.js","hash":"52c385061981e1818540f8a58ac7318cfe51e50f","modified":1763279976299},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1763279976299},{"_id":"public/images/avatar.jpg","hash":"1200d19dd2c6781c320658e4b5f120ea84eded02","modified":1763279976299},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1763279976299},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1763279976299},{"_id":"public/images/logo.jpg","hash":"d588814657ae54a23639b80fbf0ab91b05e8b775","modified":1763279976299},{"_id":"public/2025/11/02/Another_Page/image1.jpg","hash":"61d9dfe8d775d04caf01fa01d4014dcee24251af","modified":1763279976299},{"_id":"public/images/oi_cover.jpg","hash":"3fcc1a62714617e401ba2ec86a1534d07445b48b","modified":1763279976299},{"_id":"public/images/ri_chang.jpg","hash":"c4a5ac1aae09ce542056f2fbfb96c5852e3adf5e","modified":1763279976299},{"_id":"public/images/note_cover.jpg","hash":"ded2453441d2e97bc2cd957f81b4fa91d471db3c","modified":1763279976299},{"_id":"public/images/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1763279976299},{"_id":"public/2025/11/02/Another_Page/cover_Another_Page.jpg","hash":"2537c3ff1c30c18dc02e085c1d51d7a324aaa04e","modified":1763279976299},{"_id":"public/2025/11/02/Another_Page/image2.jpg","hash":"cd470cd89bac0ec6ad5b1ae7bc0362493e454f62","modified":1763279976299},{"_id":"public/images/background.png","hash":"b6d89125771f420fcb606f9f3176fd425b854694","modified":1763279976299}],"Category":[{"name":"一些碎碎念","_id":"cuideuhaFnnhgmsle-TofSvUZ"},{"name":"日常","_id":"cuidsHeMOEo3SoxtOhuvorDAX"},{"name":"大学学习笔记","_id":"cuidOPV_bdCTy7OmpVySwcRij"},{"name":"算法学习笔记","_id":"cuidvYjl1UMtfcUK5Fvz-vxZV"}],"Data":[],"Page":[{"title":"笔记","layout":"category","category":"note","_content":"\n","source":"note/index.md","raw":"---\ntitle: 笔记\nlayout: category\ncategory: note\n---\n\n","date":"2025-11-08T09:45:22.500Z","updated":"2025-11-08T09:45:22.500Z","path":"note/index.html","_id":"cuid7L1kKm3PwLlfW1j_YLtX3","comments":1,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"文章归档","layout":"archives","_content":"","source":"archive.md","raw":"---\ntitle: 文章归档\nlayout: archives\n---\n","date":"2025-11-08T09:45:22.484Z","updated":"2025-11-08T09:45:22.484Z","path":"archive.html","_id":"cuid-SKaTOZ7rmr9SBQs41oOu","comments":1,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"关于我自己","date":"2025-11-03T06:00:00.000Z","_content":"{% meting \"002NKWkV2LfpGY\" \"tencent\" \"song\"  \"mutex:false\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%}\n### 初次见面 👋🏻\n\n*   我是n0irzzz，可以叫我诺子或者n0。\n*   欢迎访问我的个人网站。\n*   是 ~~__世界顶级强校__~~ 中国普通大学的一名大一新生，正在学习软件工程~\n*   空闲时我会做什么：Random(\"看小说\", \"玩游戏\", \"看动漫\")\n*   有什么兴趣?   \n忠诚的铁佛寺 ~~已切割~~  jpop爱好者 纯正fps菜狗\n*   期待与你成为朋友 🤟🏻\n\n\n### 特别鸣谢 ⭐\n*   感谢[若则](https://chiyoyuki.uk/)向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  \n*   感谢[小小小朋友](https://onelittlechild.cn/),是他告诉我文字的力量，并认真阅读我的小学生作文。  \n*   感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  \n*   感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  \n*   特别感谢[gemini](https://gemini.google.com/) ~~伟大无需多言~~","source":"about/index.md","raw":"---\ntitle: 关于我自己\ndate: 2025-11-03 14:00:00\n---\n{% meting \"002NKWkV2LfpGY\" \"tencent\" \"song\"  \"mutex:false\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%}\n### 初次见面 👋🏻\n\n*   我是n0irzzz，可以叫我诺子或者n0。\n*   欢迎访问我的个人网站。\n*   是 ~~__世界顶级强校__~~ 中国普通大学的一名大一新生，正在学习软件工程~\n*   空闲时我会做什么：Random(\"看小说\", \"玩游戏\", \"看动漫\")\n*   有什么兴趣?   \n忠诚的铁佛寺 ~~已切割~~  jpop爱好者 纯正fps菜狗\n*   期待与你成为朋友 🤟🏻\n\n\n### 特别鸣谢 ⭐\n*   感谢[若则](https://chiyoyuki.uk/)向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  \n*   感谢[小小小朋友](https://onelittlechild.cn/),是他告诉我文字的力量，并认真阅读我的小学生作文。  \n*   感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  \n*   感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  \n*   特别感谢[gemini](https://gemini.google.com/) ~~伟大无需多言~~","updated":"2025-11-08T09:45:22.484Z","path":"about/index.html","_id":"cuidlWoEzmCEBPCkOboVVVrcG","comments":1,"layout":"page","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><meting-js server=\"tencent\" type=\"song\" id=\"002NKWkV2LfpGY\" mode=\"circulation\" autoplay=\"false\" mutex=\"false\" listmaxheight=\"340px\" preload=\"none\" theme=\"#ad7a86\">\n</meting-js>\n<h3><span id=\"%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2-%F0%9F%91%8B%F0%9F%8F%BB\">初次见面 👋🏻</span></h3><ul>\n<li>我是n0irzzz，可以叫我诺子或者n0。</li>\n<li>欢迎访问我的个人网站。</li>\n<li>是 <del><strong>世界顶级强校</strong></del> 中国普通大学的一名大一新生，正在学习软件工程~</li>\n<li>空闲时我会做什么：Random(“看小说”, “玩游戏”, “看动漫”)</li>\n<li>有什么兴趣?<br>忠诚的铁佛寺 <del>已切割</del>  jpop爱好者 纯正fps菜狗</li>\n<li>期待与你成为朋友 🤟🏻</li>\n</ul>\n<h3><span id=\"%E7%89%B9%E5%88%AB%E9%B8%A3%E8%B0%A2-%E2%AD%90\">特别鸣谢 ⭐</span></h3><ul>\n<li>感谢<a href=\"https://chiyoyuki.uk/\">若则</a>向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  </li>\n<li>感谢<a href=\"https://onelittlechild.cn/\">小小小朋友</a>,是他告诉我文字的力量，并认真阅读我的小学生作文。  </li>\n<li>感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  </li>\n<li>感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  </li>\n<li>特别感谢<a href=\"https://gemini.google.com/\">gemini</a> <del>伟大无需多言</del></li>\n</ul>\n</body></html>","excerpt":"","more":"<meting-js\n  server=\"tencent\"\n  type=\"song\"\n  id=\"002NKWkV2LfpGY\"\n  mode=\"circulation\"\n  autoplay=\"false\"\n  mutex=\"false\"\n  listmaxheight=\"340px\"\n  preload=\"none\"\n  theme=\"#ad7a86\">\n</meting-js>\n<h3 id=\"初次见面-👋🏻\"><a href=\"#初次见面-👋🏻\" class=\"headerlink\" title=\"初次见面 👋🏻\"></a>初次见面 👋🏻</h3><ul>\n<li>我是n0irzzz，可以叫我诺子或者n0。</li>\n<li>欢迎访问我的个人网站。</li>\n<li>是 <del><strong>世界顶级强校</strong></del> 中国普通大学的一名大一新生，正在学习软件工程~</li>\n<li>空闲时我会做什么：Random(“看小说”, “玩游戏”, “看动漫”)</li>\n<li>有什么兴趣?<br>忠诚的铁佛寺 <del>已切割</del>  jpop爱好者 纯正fps菜狗</li>\n<li>期待与你成为朋友 🤟🏻</li>\n</ul>\n<h3 id=\"特别鸣谢-⭐\"><a href=\"#特别鸣谢-⭐\" class=\"headerlink\" title=\"特别鸣谢 ⭐\"></a>特别鸣谢 ⭐</h3><ul>\n<li>感谢<a href=\"https://chiyoyuki.uk/\">若则</a>向我提出了这个想法，并耐心地解答了一些愚蠢的问题。  </li>\n<li>感谢<a href=\"https://onelittlechild.cn/\">小小小朋友</a>,是他告诉我文字的力量，并认真阅读我的小学生作文。  </li>\n<li>感谢414，521的所有人，是你们为我不甚开心的高中三年添上了难忘的一笔。  </li>\n<li>感谢2508的所有同学，是你们让我感受到集体的团结，温暖与爱。  </li>\n<li>特别感谢<a href=\"https://gemini.google.com/\">gemini</a> <del>伟大无需多言</del></li>\n</ul>\n"}],"Post":[{"title":"Another Page","date":"2025-11-02T14:29:29.000Z","cover":"/images/cover_Another_Page.jpg","_content":"# Another Page\n>但有时候我也在想：  \n要是我也能经历这样的青春的话；  \n要是我的面前有一个泪眼迷糊的女主角的话；  \n要是我也是轻小说的主角的话；  \n那时……\n我又会想什么呢？\n\n{% biliplayer BV1D64y187w8 %}\n\n真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  \n\n这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： \n\n***“要不把这个当作我博客的第一篇文章吧！”***  \n\n于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   \n\n如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” ~~搞得像你未来三年能干出什么有意义的事情一样XD~~  \n\n好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  \n  \n我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？\n\n{% asset_img image1.jpg %}  \n\n大概就是这么回应我的 ~~（没这么好看）~~  \n\n可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。\n\n前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。\n\n被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。\n\n可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。\n\n这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，\n\n多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。\n\n骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。\n\n{% asset_img image2.jpg %} \n\n我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。\n\n可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。\n\n>莫名其妙，这和我文章的主题有任何关系吗?  \n我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。\n\n可我终究不是一块枕木，一条铁轨。\n\n大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。\n\n我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？\n\n对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。\n\n“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。**“Another Page”** 我该往里面写点什么呢？\n\n或许留着空白，等我有了头绪再写也不迟吧。\n\n没有再伤感的理由了，明天已然到来。  \n纵使普普通通，也是要交数论作业的。","source":"_posts/Another_Page.md","raw":"---\ntitle: Another Page\ndate: 2025-11-02 22:29:29\ncategories:\n    - 一些碎碎念\ncover: /images/cover_Another_Page.jpg\ntag:\n    - 胡思乱想\n---\n# Another Page\n>但有时候我也在想：  \n要是我也能经历这样的青春的话；  \n要是我的面前有一个泪眼迷糊的女主角的话；  \n要是我也是轻小说的主角的话；  \n那时……\n我又会想什么呢？\n\n{% biliplayer BV1D64y187w8 %}\n\n真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  \n\n这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： \n\n***“要不把这个当作我博客的第一篇文章吧！”***  \n\n于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   \n\n如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” ~~搞得像你未来三年能干出什么有意义的事情一样XD~~  \n\n好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  \n  \n我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？\n\n{% asset_img image1.jpg %}  \n\n大概就是这么回应我的 ~~（没这么好看）~~  \n\n可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。\n\n前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。\n\n被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。\n\n可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。\n\n这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，\n\n多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。\n\n骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。\n\n{% asset_img image2.jpg %} \n\n我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。\n\n可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。\n\n>莫名其妙，这和我文章的主题有任何关系吗?  \n我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。\n\n可我终究不是一块枕木，一条铁轨。\n\n大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。\n\n我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？\n\n对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。\n\n“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。**“Another Page”** 我该往里面写点什么呢？\n\n或许留着空白，等我有了头绪再写也不迟吧。\n\n没有再伤感的理由了，明天已然到来。  \n纵使普普通通，也是要交数论作业的。","slug":"Another_Page","published":1,"updated":"2025-11-08T09:45:22.477Z","_id":"cuidaTRWefn990XXtlzXuzEZE","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h1><span id=\"another-page\">Another Page</span></h1><blockquote>\n<p>但有时候我也在想：<br>要是我也能经历这样的青春的话；<br>要是我的面前有一个泪眼迷糊的女主角的话；<br>要是我也是轻小说的主角的话；<br>那时……<br>我又会想什么呢？</p>\n</blockquote>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1D64y187w8&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0\" style=\"width: 62em; height: 35em;\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>\n\n<p>真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  </p>\n<p>这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： </p>\n<p><em><strong>“要不把这个当作我博客的第一篇文章吧！”</strong></em>  </p>\n<p>于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   </p>\n<p>如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” <del>搞得像你未来三年能干出什么有意义的事情一样XD</del>  </p>\n<p>好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  </p>\n<p>我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？</p>\n<img src=\"/2025/11/02/Another_Page/image1.jpg\" class=\"\">  \n\n<p>大概就是这么回应我的 <del>（没这么好看）</del>  </p>\n<p>可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。</p>\n<p>前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。</p>\n<p>被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。</p>\n<p>可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。</p>\n<p>这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，</p>\n<p>多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。</p>\n<p>骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。</p>\n<img src=\"/2025/11/02/Another_Page/image2.jpg\" class=\"\"> \n\n<p>我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。</p>\n<p>可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。</p>\n<blockquote>\n<p>莫名其妙，这和我文章的主题有任何关系吗?<br>我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。</p>\n</blockquote>\n<p>可我终究不是一块枕木，一条铁轨。</p>\n<p>大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。</p>\n<p>我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？</p>\n<p>对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。</p>\n<p>“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。<strong>“Another Page”</strong> 我该往里面写点什么呢？</p>\n<p>或许留着空白，等我有了头绪再写也不迟吧。</p>\n<p>没有再伤感的理由了，明天已然到来。<br>纵使普普通通，也是要交数论作业的。</p>\n</body></html>","excerpt":"","more":"<h1 id=\"Another-Page\"><a href=\"#Another-Page\" class=\"headerlink\" title=\"Another Page\"></a>Another Page</h1><blockquote>\n<p>但有时候我也在想：<br>要是我也能经历这样的青春的话；<br>要是我的面前有一个泪眼迷糊的女主角的话；<br>要是我也是轻小说的主角的话；<br>那时……<br>我又会想什么呢？</p>\n</blockquote>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1D64y187w8&page=1&as_wide=1&high_quality=1&danmaku=0\"\nstyle=\"width: 62em; height: 35em;\"\nallowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>\n\n<p>真是莫名奇妙，我为什么要放这个链接，再引用这个中二到不知所云的引用呢？难道我还是幻想自己是世界的主角的高中生吗？！  </p>\n<p>这本来是一个测试用的文档，用来练习md的语法以及hexo主题提供的一些功能。可当我准备删掉的时候却突然想： </p>\n<p><em><strong>“要不把这个当作我博客的第一篇文章吧！”</strong></em>  </p>\n<p>于是乎，我便坐下来写了这些文字。就像我不会删去我电脑里的那段helloworld一样，我也打算把这些东西保留下来，或许哪天看到这些的时候，总有一些不一样的感触。   </p>\n<p>如果问高一的我，你会不会搭一个博客，把你所思所想放到网上。他肯定会回答我：“什么鬼东西，感觉好麻烦，写日记这样的事情也太没有意义了！” <del>搞得像你未来三年能干出什么有意义的事情一样XD</del>  </p>\n<p>好像的确如此：我从来没有记笔记的习惯，也鲜有拍照记录下自己的生活。或许的确没有什么可记录的。上学，看动漫，打游戏。我只会在这三个状态来回切换。得过且过 或许可以如此概括我的18年人生。  </p>\n<p>我问我同学，为什么我没有天降女主角关心我，为什么别人的高中生活好像如此丰富多彩？</p>\n<img src=\"/2025/11/02/Another_Page/image1.jpg\" class=\"\">  \n\n<p>大概就是这么回应我的 <del>（没这么好看）</del>  </p>\n<p>可他的确什么都没说错，我并不是轻小说的主角，更不会有一个泪眼迷糊的女主角为我哭泣。我只是一个普通到扔在人海里都找不到的宅男，和大多数人一样，幻想着自己成为世界的中心，手上却不做出任何改变。可当我切切实实地踏入大学的校门，我才意识到那些荧幕里我曾向往过的青春校园，已然遥不可及。</p>\n<p>前些日子是校运动会，而举办的校区就在我高中边上。“回去看看吧！”自然而然的这么想。</p>\n<p>被残忍的拒之门外了。也是，保安不会让一个不穿校服还拿着手机的人进学校。</p>\n<p>可这又怎么难得到我！我立刻回想起来一条高三的时候偷偷出门吃kfc的神秘路线，装作来看场地的羽球球友大摇大摆地走进游泳馆二楼，转头溜进楼梯间，快跑进教学楼。</p>\n<p>这里的确没有任何变化，除了高一高二搬到了另一栋楼，一切都和我离开的时候一样：楼梯间里被扣掉的宣传语，一楼吵吵闹闹的小学生，书柜上莫名其妙的一大堆试卷。她就在那里，只是我已经离开了，</p>\n<p>多么讽刺，我的高中是我这三年的全部，可我只是这他的一个匆匆过客。</p>\n<p>骑车回程的路上，我再次经过了那条贯穿整个城镇的铁路。</p>\n<img src=\"/2025/11/02/Another_Page/image2.jpg\" class=\"\"> \n\n<p>我一直很好奇，为什么这条铁路一直留在这里，明明他不承载任何线路，更不会有任何一辆机车经过这里。</p>\n<p>可他就是在这里，或许是出于战时的考量，也只是单纯的拆除费用太高，他一直留了下来。</p>\n<blockquote>\n<p>莫名其妙，这和我文章的主题有任何关系吗?<br>我的文笔实在是差的可以，让chatgpt来都能写点比这好得多的文字。</p>\n</blockquote>\n<p>可我终究不是一块枕木，一条铁轨。</p>\n<p>大学生活是奇特的。没有目标，没有标准，没有你想要就有的教学和答案，没有人在乎你。只有冰冷的矩阵和奇异的高数构造在冲击我的价值观。</p>\n<p>我不知道未来我会怎么样，一个几个月前还要对着教程打helloworld的人能成为一个优秀的人吗？</p>\n<p>对着电脑屏幕发呆。我的高中同学已经不再我身边了，414里神秘的八卦聊天环节早已在两年前就结束了。留下的只有一个孤独且恐惧的空壳，思考这毫无意义的议题，等待又一个普普通通的明天。</p>\n<p>“进入大学的殿堂，让我们翻开崭新的一页。”在熟悉不过的开场词。<strong>“Another Page”</strong> 我该往里面写点什么呢？</p>\n<p>或许留着空白，等我有了头绪再写也不迟吧。</p>\n<p>没有再伤感的理由了，明天已然到来。<br>纵使普普通通，也是要交数论作业的。</p>\n"},{"title":"test","date":"2025-10-31T13:46:35.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2025-10-31 21:46:35\ntags:\n---\n","slug":"test","published":1,"updated":"2025-10-31T13:46:35.799Z","_id":"cuidMRHKsn53qoycz7LH3Thmw","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body></body></html>","excerpt":"","more":""},{"title":"小小吐槽","date":"2025-11-03T04:20:08.000Z","cover":"/images/ri_chang.jpg","_content":"噫嘘唏，数字电路之难。。。  \n\n现在是中午12点30分，还有三十分钟上程设。  \n\n而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    \n\n真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  \n\n难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！\n\n哦哦还有信息安全 ~~这个是我真没听~~ 马上要结课了，知识点我还没听过一个字呢。  \n\n这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 *KFC* 。至少这能让我心情愉快对吧。\n\n写了一半去上课了，又是听莫名奇妙的c语言知识点。~~***如果只听这些就能找到工作这个世界才完蛋了***~~。又是最后一排摸鱼的一天。\n\n去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。\n\n妈的，我梦想的轻松大学生活到底被谁偷了。\n\n或许明天要轻松点吧，就一节英语，晚上把作业写了就好。\n\n哦，晚上还要开会开到十点。\n\n__杀了我吧。__\n\n不能再写了，再写又浪费了不知道多久时间。\n\n放首歌给我自己听。\n\n{% biliplayer BV1Bt411873Y %}","source":"_posts/tucao.md","raw":"---\ntitle: 小小吐槽\ndate: 2025-11-03 12:20:08\ntags:\n    - 吐槽\ncategories:\n    - 日常\ncover: /images/ri_chang.jpg\n---\n噫嘘唏，数字电路之难。。。  \n\n现在是中午12点30分，还有三十分钟上程设。  \n\n而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    \n\n真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  \n\n难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！\n\n哦哦还有信息安全 ~~这个是我真没听~~ 马上要结课了，知识点我还没听过一个字呢。  \n\n这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 *KFC* 。至少这能让我心情愉快对吧。\n\n写了一半去上课了，又是听莫名奇妙的c语言知识点。~~***如果只听这些就能找到工作这个世界才完蛋了***~~。又是最后一排摸鱼的一天。\n\n去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。\n\n妈的，我梦想的轻松大学生活到底被谁偷了。\n\n或许明天要轻松点吧，就一节英语，晚上把作业写了就好。\n\n哦，晚上还要开会开到十点。\n\n__杀了我吧。__\n\n不能再写了，再写又浪费了不知道多久时间。\n\n放首歌给我自己听。\n\n{% biliplayer BV1Bt411873Y %}","slug":"tucao","published":1,"updated":"2025-11-08T09:45:22.483Z","_id":"cuidtLQBUm2Ide4aYhyUsOfQa","comments":1,"layout":"post","photos":[],"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>噫嘘唏，数字电路之难。。。  </p>\n<p>现在是中午12点30分，还有三十分钟上程设。  </p>\n<p>而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    </p>\n<p>真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  </p>\n<p>难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！</p>\n<p>哦哦还有信息安全 <del>这个是我真没听</del> 马上要结课了，知识点我还没听过一个字呢。  </p>\n<p>这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 <em>KFC</em> 。至少这能让我心情愉快对吧。</p>\n<p>写了一半去上课了，又是听莫名奇妙的c语言知识点。<del><em><strong>如果只听这些就能找到工作这个世界才完蛋了</strong></em></del>。又是最后一排摸鱼的一天。</p>\n<p>去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。</p>\n<p>妈的，我梦想的轻松大学生活到底被谁偷了。</p>\n<p>或许明天要轻松点吧，就一节英语，晚上把作业写了就好。</p>\n<p>哦，晚上还要开会开到十点。</p>\n<p><strong>杀了我吧。</strong></p>\n<p>不能再写了，再写又浪费了不知道多久时间。</p>\n<p>放首歌给我自己听。</p>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1Bt411873Y&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0\" style=\"width: 62em; height: 35em;\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe></body></html>","excerpt":"","more":"<p>噫嘘唏，数字电路之难。。。  </p>\n<p>现在是中午12点30分，还有三十分钟上程设。  </p>\n<p>而我依旧正在听这苦逼的高等数学网课。而一个半小时前结束的数字电路我可谓什么都听不懂。    </p>\n<p>真是神奇，明明是专业课，可一周只排了一节课。并且默认你完完全全吸收了上一周的全部知识点。  </p>\n<p>难道你以为我真是超级学霸？我还搁着和高等数学搏斗呢！</p>\n<p>哦哦还有信息安全 <del>这个是我真没听</del> 马上要结课了，知识点我还没听过一个字呢。  </p>\n<p>这些课到底和我未来的职业有什么鬼联系？！我不如吃两顿 <em>KFC</em> 。至少这能让我心情愉快对吧。</p>\n<p>写了一半去上课了，又是听莫名奇妙的c语言知识点。<del><em><strong>如果只听这些就能找到工作这个世界才完蛋了</strong></em></del>。又是最后一排摸鱼的一天。</p>\n<p>去你的，并非摸鱼！我还有一堆网课要听，为了搭博客我已经不知道多久没做题了，本来今天是要多少写点什么的，可我再不听课内就要绩点0然后被勒令退学了。人生，，，完蛋了。。。</p>\n<p>妈的，我梦想的轻松大学生活到底被谁偷了。</p>\n<p>或许明天要轻松点吧，就一节英语，晚上把作业写了就好。</p>\n<p>哦，晚上还要开会开到十点。</p>\n<p><strong>杀了我吧。</strong></p>\n<p>不能再写了，再写又浪费了不知道多久时间。</p>\n<p>放首歌给我自己听。</p>\n<iframe src=\"https://player.bilibili.com/player.html?bvid=BV1Bt411873Y&page=1&as_wide=1&high_quality=1&danmaku=0\"\nstyle=\"width: 62em; height: 35em;\"\nallowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"100%\" scrolling=\"no\" frameborder=\"0\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"></iframe>"},{"title":"程序设计期中复习","date":"2025-11-16T07:49:51.000Z","cover":"/images/note_cover.jpg","_content":"我发现好久好久没写博客了。  \n懒狗是这样的。  \n先传一点笔记吧。  \n\n---\n\n### 📚 知识点大纲\n\n1.  **第1章：程序设计与问题解决概述**\n    * 1.1 程序与程序设计\n    * 1.2 问题解决的阶段\n    * 1.3 编程语言的层次\n    * 1.4 程序的编译与执行\n    * 1.5 基本控制结构\n    * 1.6 计算机基本组成\n2.  **第2章：C语言基础：类型、变量、常量与运算符**\n    * 2.1 标识符、变量与常量\n    * 2.2 数据类型\n    * 2.3 运算符与表达式\n3.  **第3章：控制结构**\n    * 3.1 选择结构\n    * 3.2 循环结构\n4.  **第4章：函数与程序结构**\n    * 4.1 函数基础\n    * 4.2 参数传递\n    * 4.3 作用域、生命周期与存储类型\n    * 4.4 递归\n    * 4.5 C预处理器\n5.  **第5章：数组**\n    * 5.1 一维数组\n    * 5.2 数组与函数\n    * 5.3 数组算法：排序与搜索\n    * 5.4 多维数组\n\n---\n\n### 📖 详细知识点\n\n## 第1章：程序设计与问题解决概述\n\n### 1.1 程序与程序设计\n* **程序 (Program):** 由计算机执行的一系列指令。\n* **程序设计 (Programming):** 为计算机规划一系列执行步骤的过程。\n\n### 1.2 问题解决的阶段\n1.  **问题解决阶段:**\n    * 需求分析与规范。\n    * **算法设计 (Algorithm):** 在有限的时间内逐步解决问题的过程。\n2.  **实现阶段:**\n    * **编码 (Coding):** 将算法翻译成编程语言。\n    * 调试与测试。\n3.  **维护阶段:**\n    * 使用、修正错误、改进功能。\n\n### 1.3 编程语言的层次\n* **机器语言 (Machine Language):**\n    * 由0和1组成的二进制编码指令。\n    * 计算机唯一可以直接理解和执行的语言。\n    * 不可移植，可读性差。\n* **汇编语言 (Assembly Language):**\n    * 使用助记符（如 `LOAD`, `ADD`）来表示机器指令。\n    * 需要汇编器(Assembler)进行翻译。\n* **高级语言 (High-level Language):**\n    * 语言类似自然语言，易于读、写和理解。\n    * 可移植性好。\n    * 示例：C, C++, Java, Python。\n\n### 1.4 程序的编译与执行\n* **编译器 (Compiler):**\n    * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。\n    * 编译型语言执行速度通常更快，源码是私有的。\n    * 缺点是不跨平台（C, C++）。\n* **解释器 (Interpreter):**\n    * 逐行解释并执行源代码。\n    * 解释型语言通常跨平台，易于调试。\n    * 缺点是执行速度较慢，源码是公开的（Python, PHP）。\n* **C语言的编译执行流程:**\n    1.  **源文件 (Source):** 程序员编写的 `.c` 文件（如 `myprog.c`）。\n    2.  **编译器 (Compiler):** 将源文件翻译成机器语言的 **目标文件 (Object)**（如 `myprog.o`）。\n    3.  **链接器 (Linker):** 将目标文件与库函数等其他代码组合起来，生成 **可执行文件 (Executable)**（如 `myprog.exe`）。\n\n### 1.5 基本控制结构\n程序由四种基本的控制结构组成：\n1.  **顺序结构 (Sequence):** 语句按顺序一条接一条地执行。\n2.  **选择结构 (Selection / Branch):** 根据特定条件执行不同的语句（如 `if`, `switch`）。\n3.  **循环结构 (Loop / Repetition):** 在满足特定条件时重复执行某些语句（如 `while`, `for`）。\n4.  **子程序 (Subprogram / Function):** 将程序分解为更小的单元（函数）。\n\n### 1.6 计算机基本组成\n* **硬件 (Hardware):**\n    * **中央处理单元 (CPU):**\n        * **算术逻辑单元 (ALU):** 执行算术运算和逻辑比较。\n        * **控制单元 (Control Unit):** 控制程序指令的执行顺序。\n    * **内存单元 (Memory Unit):**\n        * 有序的存储单元序列，每个单元有唯一地址。\n        * 用于存放数据和程序指令。\n    * **外围设备 (Peripherals):**\n        * 输入设备（如键盘、鼠标）。\n        * 输出设备（如显示器、打印机）。\n        * 辅助存储设备（如硬盘、CD-ROM）。\n* **软件 (Software):**\n    * **系统软件 (System Software):** 如操作系统（OS），用于管理计算机资源。\n    * **应用软件 (Application):** 用户执行特定任务的程序。\n\n## 第2章：C语言基础：类型、变量、常量与运算符\n\n### 2.1 标识符、变量与常量\n* **变量 (Variable):**\n    * 程序中用于存放数据的容器（存储区域）。\n    * 变量名是内存位置的符号表示。\n    * 声明变量时必须指定其名称和数据类型。\n* **标识符 (Identifier):** (即变量名、函数名等)\n    * **命名规则:**\n        1.  只能包含字母（大小写）、数字和下划线 `_`。\n        2.  必须以字母或下划线 `_` 开头（不能是数字）。\n        3.  长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。\n    * **命名注意事项:**\n        1.  应使用有意义的名称（如 `firstName` 而不是 `fn`）。\n        2.  **区分大小写** (如 `name` 和 `Name` 是不同的)。\n        3.  **不能** 使用C语言的 **关键字** (Reserved words) 作为标识符。\n* **常量 (Constant):**\n    * **字面值常量 (Literal value):** 直接写在代码中的值，如 `100`, `3.14`, `'A'`。\n    * **命名常量 (Named constant):**\n        1.  使用 `const` 修饰符：`const int VOTING_AGE = 18;`。\n        2.  使用 `#define` 预处理指令：`#define VOTING_AGE 18`。\n    * 命名常量的值在程序执行期间不能被更改。\n* **声明与赋值:**\n    * **声明 (Declaration):** 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。\n    * **赋值 (Assignment):** 使用赋值运算符 `=` 来给变量一个值。\n        * 赋值语句的左侧必须是变量，右侧是值或表达式。\n\n### 2.2 数据类型\n* **数据类型 (Data Type):**\n    * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。\n    * 每种数据类型需要不同大小的内存。\n    * C语言数据类型分为：简单类型、结构类型和地址类型。\n* **`sizeof` 运算符:**\n    * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。\n    * 示例：`sizeof(int)`, `sizeof(age)`。\n    * C语言保证的最小大小：`sizeof(char)` 为 1，`short` 至少16位，`long` 至少32位。\n* **整型 (Integral Types):**\n    * 用于表示整数，包括 `char`, `short`, `int`, `long`。\n    * **`char`:** 字符类型，用于表示单个字符。\n        * 字符在内存中以其 **ASCII** 码值（整数）存储。\n        * 字符常量用单引号 `' '` 括起来，如 `'B'`, `'4'`。\n        * **转义字符 (Escape character):** 特殊字符，如 `\\n` (换行), `\\t` (制表符), `\\\\` (反斜杠), `\\\"` (双引号)。\n    * **整型字面值:**\n        * 十进制 (Decimal): 正常书写，如 `16`, `498`。\n        * 八进制 (Octal): 以 `0` 开头，如 `022`。\n        * 十六进制 (Hexadecimal): 以 `0x` 或 `0X` 开头，如 `0xFF`。\n* **浮点型 (Floating Types):**\n    * 用于表示带小数点的实数，包括 `float`, `double`, `long double`。\n    * **科学计数法:** 使用 `E` 或 `e` 表示，如 `1.84E1` (即 1.84 x 10¹)。\n    * **默认类型:** 没有后缀的浮点常量（如 `94.6`）默认为 `double` 类型。\n    * **后缀:** `F` 或 `f` 表示 `float` (如 `94.6F`)；`L` 或 `l` 表示 `long double`。\n    * **精度:** 计算机不能精确表示所有浮点数。`double` 的精度高于或等于 `float`。\n* **布尔型 (`bool`):**\n    * C99标准引入，需要包含头文件 `<stdbool.h>`。\n    * 值只有 `true` (1) 或 `false` (0)。\n* **字符串型 (String):**\n    * 用双引号 `\" \"` 括起来的字符序列，如 `\"Hello\"`。\n    * **不是C的内置类型**，它本质上是一个 **字符数组 (char array)**。\n    * 以空字符 `\\0` 作为结尾标记。\n    * 字符串操作函数（如 `strlen`）定义在 `<string.h>` 头文件中。\n    * `\"a\"` (字符串) 与 `'a'` (字符) 是不同的。\n\n### 2.3 运算符与表达式\n* **表达式 (Expression):** 变量、常量和运算符的有效组合，可被求值以计算出一个值。\n* **算术运算符 (Arithmetic):**\n    * 一元：`+` (正), `-` (负)。\n    * 二元：`+`, `-`, `*`。\n    * **`/` (除法):**\n        * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。\n        * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。\n    * **`%` (模/取余):**\n        * 操作数 **只能是整数**。\n        * 结果是整数除法后的余数。\n        * 结果的符号由左操作数决定 (C语言中)。\n* **自增/自减运算符:**\n    * `++` (自增) 和 `--` (自减)。\n    * **前缀 (Prefix):** `++a`。先改变（加1或减1），再使用新值参与表达式运算。\n    * **后缀 (Postfix):** `a++`。先使用原值参与表达式运算，然后再改变（加1或减1）。\n* **赋值运算符 (Assignment):**\n    * `=` (赋值)。\n    * **复合赋值:** `+=`, `-=`, `*=`, `/=`。例如 `age += 3;` 等同于 `age = age + 3;`。\n* **关系运算符 (Relational):**\n    * `>`, `<`, `>=`, `<=`, `==` (等于), `!=` (不等于)。\n    * 结果为 `true` (非0) 或 `false` (0)。\n    * 注意：`=` (赋值) 和 `==` (等于) 是不同的。\n* **逻辑运算符 (Logical):**\n    * `!` (非), `&&` (与), `||` (或)。\n    * **短路求值 (Short-Circuit):**\n        * 对于 `&&`：如果左侧为 `false` (0)，则不再计算右侧。\n        * 对于 `||`：如果左侧为 `true` (非0)，则不再计算右侧。\n* **条件运算符 (Ternary):**\n    * C语言中唯一的三元运算符：`Expression1 ? Expression2 : Expression3`。\n    * 如果 `Expression1` 为 `true`，则整个表达式的值为 `Expression2`；否则为 `Expression3`。\n* **位运算符 (Bitwise):**\n    * 对操作数的二进制位进行操作。\n    * `&` (按位与), `|` (按位或), `^` (按位异或), `~` (按位非/取反)。\n    * `<<` (左移), `>>` (右移)。\n* **逗号运算符 (Comma):**\n    * `expression1, expression2`。\n    * 从左到右依次求值，整个表达式的值等于最后一个表达式 (`expression2`) 的值。\n    * 优先级是所有运算符中最低的。\n* **优先级 (Precedence) 与 结合性 (Associativity):**\n    * **优先级** 决定了哪个运算符先执行（如 `*` / `/` 优先于 `+` / `-`）。\n    * **结合性** 决定了同优先级运算符的执行顺序（如 `* / % + -` 都是左结合，从左到右）。\n    * 一元运算符、条件运算符、赋值运算符是 **右结合**（从右到左）。\n    * 可以使用 **圆括号 `()`** 来强制改变运算顺序。\n* **类型转换 (Type Conversion):**\n    * **隐式转换 (Coercion):** 编译器自动进行的类型转换。\n        * 发生在赋值时（如 `int i = 4.8;` i 变为 4）。\n        * 发生在混合类型表达式中。\n    * **类型提升 (Promotion):** 在表达式中，`char` 和 `short` 类型的值会自动提升为 `int`。\n    * **混合运算:** 较低类型会临时提升为较高类型（int -> long -> float -> double）。\n    * **显式转换 (Casting):** 程序员强制进行的类型转换。\n        * 语法：`(typename) expression`。\n        * 示例：`celsius = (5.0/9.0) * (fahr-32);`（对比 `5/9` 结果为0）。\n        * 浮点数转整数时，C99规定向0取整（截断小数）。\n\n## 第3章：控制结构\n\n### 3.1 选择结构\n* **`if` 语句 (单路选择):**\n    * 语法：`if ( Expression ) Statement`。\n    * 如果 `Expression` 为 `true` (非0)，则执行 `Statement`。\n* **`if-else` 语句 (双路选择):**\n    * 语法：`if ( Expression ) StatementA else StatementB`。\n    * 如果 `Expression` 为 `true`，执行 `StatementA`；否则执行 `StatementB`。\n* **`{}` 块的使用:**\n    * `if` 或 `else` 后面如果需要执行多条语句，必须使用花括号 `{}` 将它们括起来形成一个语句块。\n    * 如果省略 `{}`，`else` 会与最近的未配对的 `if` 结合（**悬垂else问题**）。\n* **`if-else if-else` 结构 (多路选择):**\n    * 用于实现多路分支。\n    * 按顺序测试每个 `Expression`，一旦找到为 `true` 的，就执行其后的 `Statement`，然后跳出整个结构。\n    * 如果所有 `if` 都不为 `true`，则执行最后的 `else` 块（如果存在）。\n* **`switch` 语句 (多路选择):**\n    * 语法：`switch ( IntegralExpression ) { ... }`。\n    * `IntegralExpression` 必须是整型（`char`, `int`, `long`, `enum`）。\n    * `case Constant:`：`Constant` 必须是常量表达式。\n    * **`break`:**\n        * 用于跳出 `switch` 语句。\n        * 如果省略 `break`，程序会 **穿透 (fall-through)** 并继续执行下一个 `case` 的语句。\n    * **`default`:**\n        * 可选。如果没有任何 `case` 匹配，则执行 `default` 块。\n* **测试:**\n    * 测试选择结构时，应确保每个分支至少被执行一次（**最小完全覆盖**）。\n\n### 3.2 循环结构\n* **循环 (Loop):** 一种重复执行某个语句块的控制结构。\n* **`while` 循环 (当型循环):**\n    * 语法：`while ( Expression ) { ...body... }`。\n    * **先测试 (Pre-test):** 在每次迭代 *之前* 检查 `Expression`。\n    * 如果 `Expression` 为 `false`，循环体可能一次也不执行。\n* **`do-while` 循环 (直到型循环):**\n    * 语法：`do { ...body... } while ( Expression );`。\n    * **后测试 (Post-test):** 在每次迭代 *之后* 检查 `Expression`。\n    * 循环体 **至少执行一次**。\n* **`for` 循环:**\n    * 语法：`for ( initialization ; test_expression ; update ) { ...body... }`。\n    * `initialization`：循环开始前执行一次（通常用于初始化循环变量）。\n    * `test_expression`：每次迭代前检查，若为 `false` 则退出循环。\n    * `update`：每次迭代 *之后* 执行（通常用于更新循环变量）。\n* **循环控制:**\n    * **`break`:** 立即 **跳出** 并终止其所在的最内层循环（或 `switch`）。\n    * **`continue`:** 立即 **跳过** 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 `for` 循环，会先执行 `update`）。\n    * **`goto` 和 `label`:**\n        * 提供从 `goto` 到同一函数内 `label` 的无条件跳转。\n        * 不推荐使用，但可用于跳出深度嵌套的结构。\n* **嵌套循环 (Nested Loop):**\n    * 一个循环体内包含另一个循环。\n    * `break` 或 `continue` 只影响最内层的循环。\n\n## 第4章：函数与程序结构\n\n### 4.1 函数基础\n* **函数 (Function):** 用于实现特定功能的一段程序代码。\n* **使用原因:** 避免代码重复、使程序结构化、提高可读性。\n* **函数声明 (Declaration / Prototype):**\n    * 告知编译器函数的返回类型、名称和参数类型。\n    * 语法：`type function_name(type arg1, type arg2, ...);`。\n    * 必须在使用函数前进行声明（通常放在 `main` 函数之前）。\n* **函数定义 (Definition):**\n    * 提供函数的具体实现（函数头 + 函数体）。\n    * **函数头 (Head):** `type function_name(type arg1, type arg2, ...)`。\n    * **函数体 (Body):** `{ ... your code ... }`。\n* **`return` 语句:**\n    * 用于从函数返回一个值。\n    * 函数最多只能返回 **1个** 值，该值的类型必须与声明的返回类型匹配。\n    * **`void` 函数:**\n        * 表示函数不返回值。\n        * 可以使用 `return;` 语句立即退出函数。\n* **函数调用 (Function Call):**\n    * 通过函数名和参数列表来执行函数。\n    * 程序控制权临时从调用函数转移到被调用函数。\n    * 被调用函数执行完毕后，控制权返回到调用点。\n\n### 4.2 参数传递\n* **形参 (Parameter / Formal Parameter):** 在函数 **定义** 或声明中指定的变量。\n* **实参 (Argument / Actual Parameter):** 在函数 **调用** 时传递给函数的具体值或变量。\n* **传递方式:**\n    1.  **值传递 (Pass by Value):**\n        * C语言的默认方式。\n        * 将实参的 **值复制** 一份传递给形参。\n        * 在函数内部修改形参 **不会** 影响到函数外部的实参。\n    2.  **地址/指针传递 (Pass by Address):**\n        * 将实参的 **地址** 传递给形参。\n        * 形参必须是 **指针类型** (如 `int *x`)。\n        * 实参必须是地址（如 `&a`）。\n        * 在函数内部通过指针修改形参所指向的内存，**会** 影响到函数外部的实参。\n    3.  **引用传递 (Pass by Reference):**\n        * 这是 C++ 的特性，**C语言不支持**。\n        * 形参是实参的别名（如 `int &x`）。\n\n### 4.3 作用域、生命周期与存储类型\n* **作用域 (Scope):** 标识符（变量或函数名）在程序中可以被合法使用的区域。\n    * **局部作用域 (Local Scope):** 标识符在块（`{}`内）或函数内部声明，其作用域从声明点到块或函数结束。\n    * **全局作用域 (Global Scope):** 标识符在所有函数之外声明，其作用域从声明点到文件结尾。\n    * **名称优先级:** 局部变量会“隐藏”同名的全局变量。\n* **生命周期 (Lifetime):** 程序执行期间，标识符实际拥有内存分配的时间。\n* **存储类型:**\n    * **自动变量 (Automatic):**\n        * 默认的局部变量存储类型（可省略 `auto` 关键字）。\n        * 存储在 **栈** 中。\n        * **生命周期:** 函数调用时创建，函数退出时销毁。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n    * **外部变量 (External):**\n        * 即全局变量，定义在所有函数之外。\n        * 使用 `extern` 关键字在其他文件中 **声明** （非定义），表示引用一个已在别处定义的全局变量。\n        * **生命周期:** 整个程序运行期间。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **静态变量 (Static):**\n        * 使用 `static` 关键字声明。\n        * **静态全局变量:** 作用域被限制在声明它的文件内部，其他文件不可访问。\n        * **静态局部变量:**\n            * 作用域仍是局部的（函数内）。\n            * **生命周期:** 整个程序运行期间。\n            * 只在 **第一次** 调用函数时初始化一次。\n            * 在函数多次调用之间 **保持其值**。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **寄存器变量 (Register):**\n        * 使用 `register` 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n\n### 4.4 递归\n* **递归 (Recursion):** 一个函数调用其自身的过程。\n* **递归的两个要素:**\n    1.  **基本情况 (Base Case):** 递归的停止条件，一个无需递归即可解决的简单情况。\n    2.  **递归步骤 (Recursive Step):** 将问题分解为更小的、同类的问题，并通过递归调用来解决。\n* **递归 vs. 迭代 (Iteration):**\n    * 任何递归都可以用迭代（循环）和栈来代替。\n    * 迭代（循环）在执行速度和空间占用上通常 **优于** 递归。\n\n### 4.5 C预处理器\n* 在编译之前对源代码进行处理的程序。\n* **文件包含 (`#include`):**\n    * `#include <filename>`: 在标准库目录或系统路径中查找文件。\n    * `#include \"filename\"`: 从源程序当前目录开始搜索（通常用于自定义头文件）。\n* **宏替换 (`#define`):**\n    * 定义一个宏（一个名称和一段替换文本）。\n    * 预处理器会在编译前进行 **原样文本替换**。\n    * **带参数的宏:** `define max(A,B) ((A) > (B) ? (A) : (B))`。\n    * **宏的陷阱:**\n        * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。\n        * 注意带副作用的参数，如 `max(i++, j++)`，会导致 `i` 或 `j` 被自增多次。\n* **条件包含 (`#if`...):**\n    * 允许根据预处理时的条件来选择性地编译某段代码。\n    * 指令包括：`#if`, `#elif`, `#else`, `#endif`。\n    * `#ifndef`: \"if not defined\"，常用于防止头文件被重复包含。\n\n## 第5章：数组\n\n### 5.1 一维数组\n* **数组 (Array):** 存储 **相同数据类型** 的元素的集合，这些元素在内存中 **连续存放**。\n* **数组声明:**\n    * 语法：`DataType ArrayName [ConstIntExpression];`。\n    * `ConstIntExpression` 必须是 **常量表达式**，指定数组的大小（元素个数）。\n    * 数组大小一旦固定，不可更改。\n* **数组元素访问:**\n    * 通过 **下标 (Index / Subscript)** 访问，下标从 **0** 开始。\n    * `temps[0]` 是第一个元素，`temps[4]` 是第五个元素（对于大小为5的数组）。\n* **数组名:**\n    * 数组名（如 `temps`）本身是一个 **指针**，其值是数组的 **基地址**（即第一个元素 `temps[0]` 的内存地址）。\n* **数组初始化:**\n    * 可以在声明时初始化：`int ages[5] = {40, 13, 20, 19, 36};`。\n    * 可以省略大小，编译器会自动计算：`int ages[] = {40, 13, 20};`。\n    * **部分初始化:** `int a[5] = { 2 };` 第一个元素为2，其余所有元素自动初始化为 0。\n* **数组的限制:**\n    * **无边界检查 (No Bound Checking):** C语言不检查数组下标是否越界。访问 `myList[-1]` 或 `myList[11]`（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。\n    * **无聚合操作 (No Aggregate Operations):** 不能将一个数组整体赋值给另一个数组（如 `x = y;` 是错误的）。\n    * 数组复制必须通过循环逐个元素进行。\n\n### 5.2 数组与函数\n* **数组作为函数参数:**\n    * 当数组作为参数传递时，传递的是数组的 **基地址**。\n    * 因此，函数参数传递总是 **地址传递**。\n    * 在函数内部对形参数组的修改 **会** 影响到主调函数中的实参数组。\n    * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。\n* **形参声明:**\n    * `float FindMax(float arr[], int n)`\n    * `float FindMax(float *arr, int n)` (等价)\n* **`const` 保护数组参数:**\n    * 如果不希望函数修改数组内容，应在形参声明中使用 `const` 关键字。\n    * 示例：`float FindMax(const float arr[], int n)`。\n\n### 5.3 数组算法：排序与搜索\n* **选择排序 (Selection Sort):**\n    * **算法思想:**\n        1.  从头（`passCount = 0`）开始。\n        2.  在 `data[passCount ... length-1]` 范围内找到 **最小** 元素的索引 `minIndx`。\n        3.  将 `data[minIndx]` 与 `data[passCount]` 交换。\n        4.  `passCount` 增加1，重复该过程，直到 `passCount` 达到 `length - 2`。\n* **线性搜索 (Linear / Sequential Search):**\n    * 适用于 **未排序** 的数组。\n    * 从头到尾（`i=0` 到 `n-1`）逐个检查元素，看是否等于目标值 `x`。\n    * 找到则返回索引 `i`，遍历完未找到则返回 `-1`。\n* **二分搜索 (Binary Search):**\n  C* **必须** 适用于 **已排序** 的数组。\n    * **算法思想:**\n        1.  设 `first = 0`, `last = arraySize - 1`。\n        2.  当 `last >= first` 时循环：\n        3.  计算中间索引 `mid = (first + last) / 2`。\n        4.  如果 `key == list[mid]`，则找到，返回 `mid`。\n        5.  如果 `key < list[mid]`，则目标在左半边，令 `last = mid - 1`。\n        6.  如果 `key > list[mid]`，则目标在右半边，令 `first = mid + 1`。\n        7.  循环结束仍未找到，返回 `-1`。\n\n### 5.4 多维数组\n* **二维数组 (Two-Dimensional Array):**\n    * 按行和列组织的同类型元素集合。\n    * **声明:** `DataType ArrayName [Rows] [Cols];`。\n    * **访问:** `stateHighs[2][7]` (访问第3行第8列的元素)。\n    * **内存存储:** 在内存中按 **行优先 (Row Order)** 连续存储（第一行所有元素，接着是第二行所有元素...）。\n* **多维数组作为函数参数:**\n    * 传递的仍然是基地址。\n    * **必须** 指定 **除第一维之外** 的所有维度的大小。\n    * 示例：`void FindAverages(const int stateHighs[][NUM_MONTHS], ...)`。\n* **`typedef` 与数组:**\n    * 可以使用 `typedef` 来定义数组类型，使函数原型更简洁明了。\n    * 示例：`typedef int SalesType[3][12][5];` `SalesType sales;`。\n","source":"_posts/c-languange-midterm.md","raw":"---\ntitle: 程序设计期中复习\ndate: 2025-11-16 15:49:51\ncategories : 大学学习笔记\ncover: /images/note_cover.jpg\n---\n我发现好久好久没写博客了。  \n懒狗是这样的。  \n先传一点笔记吧。  \n\n---\n\n### 📚 知识点大纲\n\n1.  **第1章：程序设计与问题解决概述**\n    * 1.1 程序与程序设计\n    * 1.2 问题解决的阶段\n    * 1.3 编程语言的层次\n    * 1.4 程序的编译与执行\n    * 1.5 基本控制结构\n    * 1.6 计算机基本组成\n2.  **第2章：C语言基础：类型、变量、常量与运算符**\n    * 2.1 标识符、变量与常量\n    * 2.2 数据类型\n    * 2.3 运算符与表达式\n3.  **第3章：控制结构**\n    * 3.1 选择结构\n    * 3.2 循环结构\n4.  **第4章：函数与程序结构**\n    * 4.1 函数基础\n    * 4.2 参数传递\n    * 4.3 作用域、生命周期与存储类型\n    * 4.4 递归\n    * 4.5 C预处理器\n5.  **第5章：数组**\n    * 5.1 一维数组\n    * 5.2 数组与函数\n    * 5.3 数组算法：排序与搜索\n    * 5.4 多维数组\n\n---\n\n### 📖 详细知识点\n\n## 第1章：程序设计与问题解决概述\n\n### 1.1 程序与程序设计\n* **程序 (Program):** 由计算机执行的一系列指令。\n* **程序设计 (Programming):** 为计算机规划一系列执行步骤的过程。\n\n### 1.2 问题解决的阶段\n1.  **问题解决阶段:**\n    * 需求分析与规范。\n    * **算法设计 (Algorithm):** 在有限的时间内逐步解决问题的过程。\n2.  **实现阶段:**\n    * **编码 (Coding):** 将算法翻译成编程语言。\n    * 调试与测试。\n3.  **维护阶段:**\n    * 使用、修正错误、改进功能。\n\n### 1.3 编程语言的层次\n* **机器语言 (Machine Language):**\n    * 由0和1组成的二进制编码指令。\n    * 计算机唯一可以直接理解和执行的语言。\n    * 不可移植，可读性差。\n* **汇编语言 (Assembly Language):**\n    * 使用助记符（如 `LOAD`, `ADD`）来表示机器指令。\n    * 需要汇编器(Assembler)进行翻译。\n* **高级语言 (High-level Language):**\n    * 语言类似自然语言，易于读、写和理解。\n    * 可移植性好。\n    * 示例：C, C++, Java, Python。\n\n### 1.4 程序的编译与执行\n* **编译器 (Compiler):**\n    * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。\n    * 编译型语言执行速度通常更快，源码是私有的。\n    * 缺点是不跨平台（C, C++）。\n* **解释器 (Interpreter):**\n    * 逐行解释并执行源代码。\n    * 解释型语言通常跨平台，易于调试。\n    * 缺点是执行速度较慢，源码是公开的（Python, PHP）。\n* **C语言的编译执行流程:**\n    1.  **源文件 (Source):** 程序员编写的 `.c` 文件（如 `myprog.c`）。\n    2.  **编译器 (Compiler):** 将源文件翻译成机器语言的 **目标文件 (Object)**（如 `myprog.o`）。\n    3.  **链接器 (Linker):** 将目标文件与库函数等其他代码组合起来，生成 **可执行文件 (Executable)**（如 `myprog.exe`）。\n\n### 1.5 基本控制结构\n程序由四种基本的控制结构组成：\n1.  **顺序结构 (Sequence):** 语句按顺序一条接一条地执行。\n2.  **选择结构 (Selection / Branch):** 根据特定条件执行不同的语句（如 `if`, `switch`）。\n3.  **循环结构 (Loop / Repetition):** 在满足特定条件时重复执行某些语句（如 `while`, `for`）。\n4.  **子程序 (Subprogram / Function):** 将程序分解为更小的单元（函数）。\n\n### 1.6 计算机基本组成\n* **硬件 (Hardware):**\n    * **中央处理单元 (CPU):**\n        * **算术逻辑单元 (ALU):** 执行算术运算和逻辑比较。\n        * **控制单元 (Control Unit):** 控制程序指令的执行顺序。\n    * **内存单元 (Memory Unit):**\n        * 有序的存储单元序列，每个单元有唯一地址。\n        * 用于存放数据和程序指令。\n    * **外围设备 (Peripherals):**\n        * 输入设备（如键盘、鼠标）。\n        * 输出设备（如显示器、打印机）。\n        * 辅助存储设备（如硬盘、CD-ROM）。\n* **软件 (Software):**\n    * **系统软件 (System Software):** 如操作系统（OS），用于管理计算机资源。\n    * **应用软件 (Application):** 用户执行特定任务的程序。\n\n## 第2章：C语言基础：类型、变量、常量与运算符\n\n### 2.1 标识符、变量与常量\n* **变量 (Variable):**\n    * 程序中用于存放数据的容器（存储区域）。\n    * 变量名是内存位置的符号表示。\n    * 声明变量时必须指定其名称和数据类型。\n* **标识符 (Identifier):** (即变量名、函数名等)\n    * **命名规则:**\n        1.  只能包含字母（大小写）、数字和下划线 `_`。\n        2.  必须以字母或下划线 `_` 开头（不能是数字）。\n        3.  长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。\n    * **命名注意事项:**\n        1.  应使用有意义的名称（如 `firstName` 而不是 `fn`）。\n        2.  **区分大小写** (如 `name` 和 `Name` 是不同的)。\n        3.  **不能** 使用C语言的 **关键字** (Reserved words) 作为标识符。\n* **常量 (Constant):**\n    * **字面值常量 (Literal value):** 直接写在代码中的值，如 `100`, `3.14`, `'A'`。\n    * **命名常量 (Named constant):**\n        1.  使用 `const` 修饰符：`const int VOTING_AGE = 18;`。\n        2.  使用 `#define` 预处理指令：`#define VOTING_AGE 18`。\n    * 命名常量的值在程序执行期间不能被更改。\n* **声明与赋值:**\n    * **声明 (Declaration):** 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。\n    * **赋值 (Assignment):** 使用赋值运算符 `=` 来给变量一个值。\n        * 赋值语句的左侧必须是变量，右侧是值或表达式。\n\n### 2.2 数据类型\n* **数据类型 (Data Type):**\n    * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。\n    * 每种数据类型需要不同大小的内存。\n    * C语言数据类型分为：简单类型、结构类型和地址类型。\n* **`sizeof` 运算符:**\n    * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。\n    * 示例：`sizeof(int)`, `sizeof(age)`。\n    * C语言保证的最小大小：`sizeof(char)` 为 1，`short` 至少16位，`long` 至少32位。\n* **整型 (Integral Types):**\n    * 用于表示整数，包括 `char`, `short`, `int`, `long`。\n    * **`char`:** 字符类型，用于表示单个字符。\n        * 字符在内存中以其 **ASCII** 码值（整数）存储。\n        * 字符常量用单引号 `' '` 括起来，如 `'B'`, `'4'`。\n        * **转义字符 (Escape character):** 特殊字符，如 `\\n` (换行), `\\t` (制表符), `\\\\` (反斜杠), `\\\"` (双引号)。\n    * **整型字面值:**\n        * 十进制 (Decimal): 正常书写，如 `16`, `498`。\n        * 八进制 (Octal): 以 `0` 开头，如 `022`。\n        * 十六进制 (Hexadecimal): 以 `0x` 或 `0X` 开头，如 `0xFF`。\n* **浮点型 (Floating Types):**\n    * 用于表示带小数点的实数，包括 `float`, `double`, `long double`。\n    * **科学计数法:** 使用 `E` 或 `e` 表示，如 `1.84E1` (即 1.84 x 10¹)。\n    * **默认类型:** 没有后缀的浮点常量（如 `94.6`）默认为 `double` 类型。\n    * **后缀:** `F` 或 `f` 表示 `float` (如 `94.6F`)；`L` 或 `l` 表示 `long double`。\n    * **精度:** 计算机不能精确表示所有浮点数。`double` 的精度高于或等于 `float`。\n* **布尔型 (`bool`):**\n    * C99标准引入，需要包含头文件 `<stdbool.h>`。\n    * 值只有 `true` (1) 或 `false` (0)。\n* **字符串型 (String):**\n    * 用双引号 `\" \"` 括起来的字符序列，如 `\"Hello\"`。\n    * **不是C的内置类型**，它本质上是一个 **字符数组 (char array)**。\n    * 以空字符 `\\0` 作为结尾标记。\n    * 字符串操作函数（如 `strlen`）定义在 `<string.h>` 头文件中。\n    * `\"a\"` (字符串) 与 `'a'` (字符) 是不同的。\n\n### 2.3 运算符与表达式\n* **表达式 (Expression):** 变量、常量和运算符的有效组合，可被求值以计算出一个值。\n* **算术运算符 (Arithmetic):**\n    * 一元：`+` (正), `-` (负)。\n    * 二元：`+`, `-`, `*`。\n    * **`/` (除法):**\n        * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。\n        * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。\n    * **`%` (模/取余):**\n        * 操作数 **只能是整数**。\n        * 结果是整数除法后的余数。\n        * 结果的符号由左操作数决定 (C语言中)。\n* **自增/自减运算符:**\n    * `++` (自增) 和 `--` (自减)。\n    * **前缀 (Prefix):** `++a`。先改变（加1或减1），再使用新值参与表达式运算。\n    * **后缀 (Postfix):** `a++`。先使用原值参与表达式运算，然后再改变（加1或减1）。\n* **赋值运算符 (Assignment):**\n    * `=` (赋值)。\n    * **复合赋值:** `+=`, `-=`, `*=`, `/=`。例如 `age += 3;` 等同于 `age = age + 3;`。\n* **关系运算符 (Relational):**\n    * `>`, `<`, `>=`, `<=`, `==` (等于), `!=` (不等于)。\n    * 结果为 `true` (非0) 或 `false` (0)。\n    * 注意：`=` (赋值) 和 `==` (等于) 是不同的。\n* **逻辑运算符 (Logical):**\n    * `!` (非), `&&` (与), `||` (或)。\n    * **短路求值 (Short-Circuit):**\n        * 对于 `&&`：如果左侧为 `false` (0)，则不再计算右侧。\n        * 对于 `||`：如果左侧为 `true` (非0)，则不再计算右侧。\n* **条件运算符 (Ternary):**\n    * C语言中唯一的三元运算符：`Expression1 ? Expression2 : Expression3`。\n    * 如果 `Expression1` 为 `true`，则整个表达式的值为 `Expression2`；否则为 `Expression3`。\n* **位运算符 (Bitwise):**\n    * 对操作数的二进制位进行操作。\n    * `&` (按位与), `|` (按位或), `^` (按位异或), `~` (按位非/取反)。\n    * `<<` (左移), `>>` (右移)。\n* **逗号运算符 (Comma):**\n    * `expression1, expression2`。\n    * 从左到右依次求值，整个表达式的值等于最后一个表达式 (`expression2`) 的值。\n    * 优先级是所有运算符中最低的。\n* **优先级 (Precedence) 与 结合性 (Associativity):**\n    * **优先级** 决定了哪个运算符先执行（如 `*` / `/` 优先于 `+` / `-`）。\n    * **结合性** 决定了同优先级运算符的执行顺序（如 `* / % + -` 都是左结合，从左到右）。\n    * 一元运算符、条件运算符、赋值运算符是 **右结合**（从右到左）。\n    * 可以使用 **圆括号 `()`** 来强制改变运算顺序。\n* **类型转换 (Type Conversion):**\n    * **隐式转换 (Coercion):** 编译器自动进行的类型转换。\n        * 发生在赋值时（如 `int i = 4.8;` i 变为 4）。\n        * 发生在混合类型表达式中。\n    * **类型提升 (Promotion):** 在表达式中，`char` 和 `short` 类型的值会自动提升为 `int`。\n    * **混合运算:** 较低类型会临时提升为较高类型（int -> long -> float -> double）。\n    * **显式转换 (Casting):** 程序员强制进行的类型转换。\n        * 语法：`(typename) expression`。\n        * 示例：`celsius = (5.0/9.0) * (fahr-32);`（对比 `5/9` 结果为0）。\n        * 浮点数转整数时，C99规定向0取整（截断小数）。\n\n## 第3章：控制结构\n\n### 3.1 选择结构\n* **`if` 语句 (单路选择):**\n    * 语法：`if ( Expression ) Statement`。\n    * 如果 `Expression` 为 `true` (非0)，则执行 `Statement`。\n* **`if-else` 语句 (双路选择):**\n    * 语法：`if ( Expression ) StatementA else StatementB`。\n    * 如果 `Expression` 为 `true`，执行 `StatementA`；否则执行 `StatementB`。\n* **`{}` 块的使用:**\n    * `if` 或 `else` 后面如果需要执行多条语句，必须使用花括号 `{}` 将它们括起来形成一个语句块。\n    * 如果省略 `{}`，`else` 会与最近的未配对的 `if` 结合（**悬垂else问题**）。\n* **`if-else if-else` 结构 (多路选择):**\n    * 用于实现多路分支。\n    * 按顺序测试每个 `Expression`，一旦找到为 `true` 的，就执行其后的 `Statement`，然后跳出整个结构。\n    * 如果所有 `if` 都不为 `true`，则执行最后的 `else` 块（如果存在）。\n* **`switch` 语句 (多路选择):**\n    * 语法：`switch ( IntegralExpression ) { ... }`。\n    * `IntegralExpression` 必须是整型（`char`, `int`, `long`, `enum`）。\n    * `case Constant:`：`Constant` 必须是常量表达式。\n    * **`break`:**\n        * 用于跳出 `switch` 语句。\n        * 如果省略 `break`，程序会 **穿透 (fall-through)** 并继续执行下一个 `case` 的语句。\n    * **`default`:**\n        * 可选。如果没有任何 `case` 匹配，则执行 `default` 块。\n* **测试:**\n    * 测试选择结构时，应确保每个分支至少被执行一次（**最小完全覆盖**）。\n\n### 3.2 循环结构\n* **循环 (Loop):** 一种重复执行某个语句块的控制结构。\n* **`while` 循环 (当型循环):**\n    * 语法：`while ( Expression ) { ...body... }`。\n    * **先测试 (Pre-test):** 在每次迭代 *之前* 检查 `Expression`。\n    * 如果 `Expression` 为 `false`，循环体可能一次也不执行。\n* **`do-while` 循环 (直到型循环):**\n    * 语法：`do { ...body... } while ( Expression );`。\n    * **后测试 (Post-test):** 在每次迭代 *之后* 检查 `Expression`。\n    * 循环体 **至少执行一次**。\n* **`for` 循环:**\n    * 语法：`for ( initialization ; test_expression ; update ) { ...body... }`。\n    * `initialization`：循环开始前执行一次（通常用于初始化循环变量）。\n    * `test_expression`：每次迭代前检查，若为 `false` 则退出循环。\n    * `update`：每次迭代 *之后* 执行（通常用于更新循环变量）。\n* **循环控制:**\n    * **`break`:** 立即 **跳出** 并终止其所在的最内层循环（或 `switch`）。\n    * **`continue`:** 立即 **跳过** 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 `for` 循环，会先执行 `update`）。\n    * **`goto` 和 `label`:**\n        * 提供从 `goto` 到同一函数内 `label` 的无条件跳转。\n        * 不推荐使用，但可用于跳出深度嵌套的结构。\n* **嵌套循环 (Nested Loop):**\n    * 一个循环体内包含另一个循环。\n    * `break` 或 `continue` 只影响最内层的循环。\n\n## 第4章：函数与程序结构\n\n### 4.1 函数基础\n* **函数 (Function):** 用于实现特定功能的一段程序代码。\n* **使用原因:** 避免代码重复、使程序结构化、提高可读性。\n* **函数声明 (Declaration / Prototype):**\n    * 告知编译器函数的返回类型、名称和参数类型。\n    * 语法：`type function_name(type arg1, type arg2, ...);`。\n    * 必须在使用函数前进行声明（通常放在 `main` 函数之前）。\n* **函数定义 (Definition):**\n    * 提供函数的具体实现（函数头 + 函数体）。\n    * **函数头 (Head):** `type function_name(type arg1, type arg2, ...)`。\n    * **函数体 (Body):** `{ ... your code ... }`。\n* **`return` 语句:**\n    * 用于从函数返回一个值。\n    * 函数最多只能返回 **1个** 值，该值的类型必须与声明的返回类型匹配。\n    * **`void` 函数:**\n        * 表示函数不返回值。\n        * 可以使用 `return;` 语句立即退出函数。\n* **函数调用 (Function Call):**\n    * 通过函数名和参数列表来执行函数。\n    * 程序控制权临时从调用函数转移到被调用函数。\n    * 被调用函数执行完毕后，控制权返回到调用点。\n\n### 4.2 参数传递\n* **形参 (Parameter / Formal Parameter):** 在函数 **定义** 或声明中指定的变量。\n* **实参 (Argument / Actual Parameter):** 在函数 **调用** 时传递给函数的具体值或变量。\n* **传递方式:**\n    1.  **值传递 (Pass by Value):**\n        * C语言的默认方式。\n        * 将实参的 **值复制** 一份传递给形参。\n        * 在函数内部修改形参 **不会** 影响到函数外部的实参。\n    2.  **地址/指针传递 (Pass by Address):**\n        * 将实参的 **地址** 传递给形参。\n        * 形参必须是 **指针类型** (如 `int *x`)。\n        * 实参必须是地址（如 `&a`）。\n        * 在函数内部通过指针修改形参所指向的内存，**会** 影响到函数外部的实参。\n    3.  **引用传递 (Pass by Reference):**\n        * 这是 C++ 的特性，**C语言不支持**。\n        * 形参是实参的别名（如 `int &x`）。\n\n### 4.3 作用域、生命周期与存储类型\n* **作用域 (Scope):** 标识符（变量或函数名）在程序中可以被合法使用的区域。\n    * **局部作用域 (Local Scope):** 标识符在块（`{}`内）或函数内部声明，其作用域从声明点到块或函数结束。\n    * **全局作用域 (Global Scope):** 标识符在所有函数之外声明，其作用域从声明点到文件结尾。\n    * **名称优先级:** 局部变量会“隐藏”同名的全局变量。\n* **生命周期 (Lifetime):** 程序执行期间，标识符实际拥有内存分配的时间。\n* **存储类型:**\n    * **自动变量 (Automatic):**\n        * 默认的局部变量存储类型（可省略 `auto` 关键字）。\n        * 存储在 **栈** 中。\n        * **生命周期:** 函数调用时创建，函数退出时销毁。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n    * **外部变量 (External):**\n        * 即全局变量，定义在所有函数之外。\n        * 使用 `extern` 关键字在其他文件中 **声明** （非定义），表示引用一个已在别处定义的全局变量。\n        * **生命周期:** 整个程序运行期间。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **静态变量 (Static):**\n        * 使用 `static` 关键字声明。\n        * **静态全局变量:** 作用域被限制在声明它的文件内部，其他文件不可访问。\n        * **静态局部变量:**\n            * 作用域仍是局部的（函数内）。\n            * **生命周期:** 整个程序运行期间。\n            * 只在 **第一次** 调用函数时初始化一次。\n            * 在函数多次调用之间 **保持其值**。\n        * **初始化:** 若不显式初始化，**默认为 0**。\n    * **寄存器变量 (Register):**\n        * 使用 `register` 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。\n        * **初始化:** 若不显式初始化，其值为未定义的（垃圾值）。\n\n### 4.4 递归\n* **递归 (Recursion):** 一个函数调用其自身的过程。\n* **递归的两个要素:**\n    1.  **基本情况 (Base Case):** 递归的停止条件，一个无需递归即可解决的简单情况。\n    2.  **递归步骤 (Recursive Step):** 将问题分解为更小的、同类的问题，并通过递归调用来解决。\n* **递归 vs. 迭代 (Iteration):**\n    * 任何递归都可以用迭代（循环）和栈来代替。\n    * 迭代（循环）在执行速度和空间占用上通常 **优于** 递归。\n\n### 4.5 C预处理器\n* 在编译之前对源代码进行处理的程序。\n* **文件包含 (`#include`):**\n    * `#include <filename>`: 在标准库目录或系统路径中查找文件。\n    * `#include \"filename\"`: 从源程序当前目录开始搜索（通常用于自定义头文件）。\n* **宏替换 (`#define`):**\n    * 定义一个宏（一个名称和一段替换文本）。\n    * 预处理器会在编译前进行 **原样文本替换**。\n    * **带参数的宏:** `define max(A,B) ((A) > (B) ? (A) : (B))`。\n    * **宏的陷阱:**\n        * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。\n        * 注意带副作用的参数，如 `max(i++, j++)`，会导致 `i` 或 `j` 被自增多次。\n* **条件包含 (`#if`...):**\n    * 允许根据预处理时的条件来选择性地编译某段代码。\n    * 指令包括：`#if`, `#elif`, `#else`, `#endif`。\n    * `#ifndef`: \"if not defined\"，常用于防止头文件被重复包含。\n\n## 第5章：数组\n\n### 5.1 一维数组\n* **数组 (Array):** 存储 **相同数据类型** 的元素的集合，这些元素在内存中 **连续存放**。\n* **数组声明:**\n    * 语法：`DataType ArrayName [ConstIntExpression];`。\n    * `ConstIntExpression` 必须是 **常量表达式**，指定数组的大小（元素个数）。\n    * 数组大小一旦固定，不可更改。\n* **数组元素访问:**\n    * 通过 **下标 (Index / Subscript)** 访问，下标从 **0** 开始。\n    * `temps[0]` 是第一个元素，`temps[4]` 是第五个元素（对于大小为5的数组）。\n* **数组名:**\n    * 数组名（如 `temps`）本身是一个 **指针**，其值是数组的 **基地址**（即第一个元素 `temps[0]` 的内存地址）。\n* **数组初始化:**\n    * 可以在声明时初始化：`int ages[5] = {40, 13, 20, 19, 36};`。\n    * 可以省略大小，编译器会自动计算：`int ages[] = {40, 13, 20};`。\n    * **部分初始化:** `int a[5] = { 2 };` 第一个元素为2，其余所有元素自动初始化为 0。\n* **数组的限制:**\n    * **无边界检查 (No Bound Checking):** C语言不检查数组下标是否越界。访问 `myList[-1]` 或 `myList[11]`（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。\n    * **无聚合操作 (No Aggregate Operations):** 不能将一个数组整体赋值给另一个数组（如 `x = y;` 是错误的）。\n    * 数组复制必须通过循环逐个元素进行。\n\n### 5.2 数组与函数\n* **数组作为函数参数:**\n    * 当数组作为参数传递时，传递的是数组的 **基地址**。\n    * 因此，函数参数传递总是 **地址传递**。\n    * 在函数内部对形参数组的修改 **会** 影响到主调函数中的实参数组。\n    * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。\n* **形参声明:**\n    * `float FindMax(float arr[], int n)`\n    * `float FindMax(float *arr, int n)` (等价)\n* **`const` 保护数组参数:**\n    * 如果不希望函数修改数组内容，应在形参声明中使用 `const` 关键字。\n    * 示例：`float FindMax(const float arr[], int n)`。\n\n### 5.3 数组算法：排序与搜索\n* **选择排序 (Selection Sort):**\n    * **算法思想:**\n        1.  从头（`passCount = 0`）开始。\n        2.  在 `data[passCount ... length-1]` 范围内找到 **最小** 元素的索引 `minIndx`。\n        3.  将 `data[minIndx]` 与 `data[passCount]` 交换。\n        4.  `passCount` 增加1，重复该过程，直到 `passCount` 达到 `length - 2`。\n* **线性搜索 (Linear / Sequential Search):**\n    * 适用于 **未排序** 的数组。\n    * 从头到尾（`i=0` 到 `n-1`）逐个检查元素，看是否等于目标值 `x`。\n    * 找到则返回索引 `i`，遍历完未找到则返回 `-1`。\n* **二分搜索 (Binary Search):**\n  C* **必须** 适用于 **已排序** 的数组。\n    * **算法思想:**\n        1.  设 `first = 0`, `last = arraySize - 1`。\n        2.  当 `last >= first` 时循环：\n        3.  计算中间索引 `mid = (first + last) / 2`。\n        4.  如果 `key == list[mid]`，则找到，返回 `mid`。\n        5.  如果 `key < list[mid]`，则目标在左半边，令 `last = mid - 1`。\n        6.  如果 `key > list[mid]`，则目标在右半边，令 `first = mid + 1`。\n        7.  循环结束仍未找到，返回 `-1`。\n\n### 5.4 多维数组\n* **二维数组 (Two-Dimensional Array):**\n    * 按行和列组织的同类型元素集合。\n    * **声明:** `DataType ArrayName [Rows] [Cols];`。\n    * **访问:** `stateHighs[2][7]` (访问第3行第8列的元素)。\n    * **内存存储:** 在内存中按 **行优先 (Row Order)** 连续存储（第一行所有元素，接着是第二行所有元素...）。\n* **多维数组作为函数参数:**\n    * 传递的仍然是基地址。\n    * **必须** 指定 **除第一维之外** 的所有维度的大小。\n    * 示例：`void FindAverages(const int stateHighs[][NUM_MONTHS], ...)`。\n* **`typedef` 与数组:**\n    * 可以使用 `typedef` 来定义数组类型，使函数原型更简洁明了。\n    * 示例：`typedef int SalesType[3][12][5];` `SalesType sales;`。\n","slug":"c-languange-midterm","published":1,"updated":"2025-11-16T07:59:14.085Z","comments":1,"layout":"post","photos":[],"_id":"cuidfgvHOb3Na05UtcubsSuW_","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>我发现好久好久没写博客了。<br>懒狗是这样的。<br>先传一点笔记吧。  </p>\n<hr>\n<h3><span id=\"%F0%9F%93%9A-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2\">📚 知识点大纲</span></h3><ol>\n<li><strong>第1章：程序设计与问题解决概述</strong><ul>\n<li>1.1 程序与程序设计</li>\n<li>1.2 问题解决的阶段</li>\n<li>1.3 编程语言的层次</li>\n<li>1.4 程序的编译与执行</li>\n<li>1.5 基本控制结构</li>\n<li>1.6 计算机基本组成</li>\n</ul>\n</li>\n<li><strong>第2章：C语言基础：类型、变量、常量与运算符</strong><ul>\n<li>2.1 标识符、变量与常量</li>\n<li>2.2 数据类型</li>\n<li>2.3 运算符与表达式</li>\n</ul>\n</li>\n<li><strong>第3章：控制结构</strong><ul>\n<li>3.1 选择结构</li>\n<li>3.2 循环结构</li>\n</ul>\n</li>\n<li><strong>第4章：函数与程序结构</strong><ul>\n<li>4.1 函数基础</li>\n<li>4.2 参数传递</li>\n<li>4.3 作用域、生命周期与存储类型</li>\n<li>4.4 递归</li>\n<li>4.5 C预处理器</li>\n</ul>\n</li>\n<li><strong>第5章：数组</strong><ul>\n<li>5.1 一维数组</li>\n<li>5.2 数组与函数</li>\n<li>5.3 数组算法：排序与搜索</li>\n<li>5.4 多维数组</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><span id=\"%F0%9F%93%96-%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86%E7%82%B9\">📖 详细知识点</span></h3><h2><span id=\"%E7%AC%AC1%E7%AB%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%A6%82%E8%BF%B0\">第1章：程序设计与问题解决概述</span></h2><h3><span id=\"11-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\">1.1 程序与程序设计</span></h3><ul>\n<li><strong>程序 (Program):</strong> 由计算机执行的一系列指令。</li>\n<li><strong>程序设计 (Programming):</strong> 为计算机规划一系列执行步骤的过程。</li>\n</ul>\n<h3><span id=\"12-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%9A%84%E9%98%B6%E6%AE%B5\">1.2 问题解决的阶段</span></h3><ol>\n<li>&nbsp;<strong>问题解决阶段:</strong><br>&nbsp; &nbsp; * 需求分析与规范。<br>&nbsp; &nbsp; * <strong>算法设计 (Algorithm):</strong> 在有限的时间内逐步解决问题的过程。</li>\n<li>&nbsp;<strong>实现阶段:</strong><br>&nbsp; &nbsp; * <strong>编码 (Coding):</strong> 将算法翻译成编程语言。<br>&nbsp; &nbsp; * 调试与测试。</li>\n<li>&nbsp;<strong>维护阶段:</strong><br>&nbsp; &nbsp; * 使用、修正错误、改进功能。</li>\n</ol>\n<h3><span id=\"13-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B1%82%E6%AC%A1\">1.3 编程语言的层次</span></h3><ul>\n<li><strong>机器语言 (Machine Language):</strong><br>&nbsp; &nbsp; * 由0和1组成的二进制编码指令。<br>&nbsp; &nbsp; * 计算机唯一可以直接理解和执行的语言。<br>&nbsp; &nbsp; * 不可移植，可读性差。</li>\n<li><strong>汇编语言 (Assembly Language):</strong><br>&nbsp; &nbsp; * 使用助记符（如 <code>LOAD</code>, <code>ADD</code>）来表示机器指令。<br>&nbsp; &nbsp; * 需要汇编器(Assembler)进行翻译。</li>\n<li><strong>高级语言 (High-level Language):</strong><br>&nbsp; &nbsp; * 语言类似自然语言，易于读、写和理解。<br>&nbsp; &nbsp; * 可移植性好。<br>&nbsp; &nbsp; * 示例：C, C++, Java, Python。</li>\n</ul>\n<h3><span id=\"14-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C\">1.4 程序的编译与执行</span></h3><ul>\n<li><strong>编译器 (Compiler):</strong><br>&nbsp; &nbsp; * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。<br>&nbsp; &nbsp; * 编译型语言执行速度通常更快，源码是私有的。<br>&nbsp; &nbsp; * 缺点是不跨平台（C, C++）。</li>\n<li><strong>解释器 (Interpreter):</strong><br>&nbsp; &nbsp; * 逐行解释并执行源代码。<br>&nbsp; &nbsp; * 解释型语言通常跨平台，易于调试。<br>&nbsp; &nbsp; * 缺点是执行速度较慢，源码是公开的（Python, PHP）。</li>\n<li><strong>C语言的编译执行流程:</strong><br>&nbsp; &nbsp; 1. &nbsp;<strong>源文件 (Source):</strong> 程序员编写的 <code>.c</code> 文件（如 <code>myprog.c</code>）。<br>&nbsp; &nbsp; 2. &nbsp;<strong>编译器 (Compiler):</strong> 将源文件翻译成机器语言的 <strong>目标文件 (Object)</strong>（如 <code>myprog.o</code>）。<br>&nbsp; &nbsp; 3. &nbsp;<strong>链接器 (Linker):</strong> 将目标文件与库函数等其他代码组合起来，生成 <strong>可执行文件 (Executable)</strong>（如 <code>myprog.exe</code>）。</li>\n</ul>\n<h3><span id=\"15-%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\">1.5 基本控制结构</span></h3><p>程序由四种基本的控制结构组成：</p>\n<ol>\n<li>&nbsp;<strong>顺序结构 (Sequence):</strong> 语句按顺序一条接一条地执行。</li>\n<li>&nbsp;<strong>选择结构 (Selection / Branch):</strong> 根据特定条件执行不同的语句（如 <code>if</code>, <code>switch</code>）。</li>\n<li>&nbsp;<strong>循环结构 (Loop / Repetition):</strong> 在满足特定条件时重复执行某些语句（如 <code>while</code>, <code>for</code>）。</li>\n<li>&nbsp;<strong>子程序 (Subprogram / Function):</strong> 将程序分解为更小的单元（函数）。</li>\n</ol>\n<h3><span id=\"16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90\">1.6 计算机基本组成</span></h3><ul>\n<li><strong>硬件 (Hardware):</strong><br>&nbsp; &nbsp; * <strong>中央处理单元 (CPU):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>算术逻辑单元 (ALU):</strong> 执行算术运算和逻辑比较。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>控制单元 (Control Unit):</strong> 控制程序指令的执行顺序。<br>&nbsp; &nbsp; * <strong>内存单元 (Memory Unit):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 有序的存储单元序列，每个单元有唯一地址。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 用于存放数据和程序指令。<br>&nbsp; &nbsp; * <strong>外围设备 (Peripherals):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 输入设备（如键盘、鼠标）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 输出设备（如显示器、打印机）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 辅助存储设备（如硬盘、CD-ROM）。</li>\n<li><strong>软件 (Software):</strong><br>&nbsp; &nbsp; * <strong>系统软件 (System Software):</strong> 如操作系统（OS），用于管理计算机资源。<br>&nbsp; &nbsp; * <strong>应用软件 (Application):</strong> 用户执行特定任务的程序。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC2%E7%AB%A0c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6\">第2章：C语言基础：类型、变量、常量与运算符</span></h2><h3><span id=\"21-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F\">2.1 标识符、变量与常量</span></h3><ul>\n<li><strong>变量 (Variable):</strong><br>&nbsp; &nbsp; * 程序中用于存放数据的容器（存储区域）。<br>&nbsp; &nbsp; * 变量名是内存位置的符号表示。<br>&nbsp; &nbsp; * 声明变量时必须指定其名称和数据类型。</li>\n<li><strong>标识符 (Identifier):</strong> (即变量名、函数名等)<br>&nbsp; &nbsp; * <strong>命名规则:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;只能包含字母（大小写）、数字和下划线 <code>_</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;必须以字母或下划线 <code>_</code> 开头（不能是数字）。<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。<br>&nbsp; &nbsp; * <strong>命名注意事项:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;应使用有意义的名称（如 <code>firstName</code> 而不是 <code>fn</code>）。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;<strong>区分大小写</strong> (如 <code>name</code> 和 <code>Name</code> 是不同的)。<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;<strong>不能</strong> 使用C语言的 <strong>关键字</strong> (Reserved words) 作为标识符。</li>\n<li><strong>常量 (Constant):</strong><br>&nbsp; &nbsp; * <strong>字面值常量 (Literal value):</strong> 直接写在代码中的值，如 <code>100</code>, <code>3.14</code>, <code>'A'</code>。<br>&nbsp; &nbsp; * <strong>命名常量 (Named constant):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;使用 <code>const</code> 修饰符：<code>const int VOTING_AGE = 18;</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;使用 <code>#define</code> 预处理指令：<code>#define VOTING_AGE 18</code>。<br>&nbsp; &nbsp; * 命名常量的值在程序执行期间不能被更改。</li>\n<li><strong>声明与赋值:</strong><br>&nbsp; &nbsp; * <strong>声明 (Declaration):</strong> 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。<br>&nbsp; &nbsp; * <strong>赋值 (Assignment):</strong> 使用赋值运算符 <code>=</code> 来给变量一个值。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 赋值语句的左侧必须是变量，右侧是值或表达式。</li>\n</ul>\n<h3><span id=\"22-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">2.2 数据类型</span></h3><ul>\n<li><strong>数据类型 (Data Type):</strong><br>&nbsp; &nbsp; * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。<br>&nbsp; &nbsp; * 每种数据类型需要不同大小的内存。<br>&nbsp; &nbsp; * C语言数据类型分为：简单类型、结构类型和地址类型。</li>\n<li><strong><code>sizeof</code> 运算符:</strong><br>&nbsp; &nbsp; * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。<br>&nbsp; &nbsp; * 示例：<code>sizeof(int)</code>, <code>sizeof(age)</code>。<br>&nbsp; &nbsp; * C语言保证的最小大小：<code>sizeof(char)</code> 为 1，<code>short</code> 至少16位，<code>long</code> 至少32位。</li>\n<li><strong>整型 (Integral Types):</strong><br>&nbsp; &nbsp; * 用于表示整数，包括 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>。<br>&nbsp; &nbsp; * <strong><code>char</code>:</strong> 字符类型，用于表示单个字符。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 字符在内存中以其 <strong>ASCII</strong> 码值（整数）存储。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 字符常量用单引号 <code>' '</code> 括起来，如 <code>'B'</code>, <code>'4'</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>转义字符 (Escape character):</strong> 特殊字符，如 <code>\\n</code> (换行), <code>\\t</code> (制表符), <code>\\\\</code> (反斜杠), <code>\\\"</code> (双引号)。<br>&nbsp; &nbsp; * <strong>整型字面值:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 十进制 (Decimal): 正常书写，如 <code>16</code>, <code>498</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 八进制 (Octal): 以 <code>0</code> 开头，如 <code>022</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 十六进制 (Hexadecimal): 以 <code>0x</code> 或 <code>0X</code> 开头，如 <code>0xFF</code>。</li>\n<li><strong>浮点型 (Floating Types):</strong><br>&nbsp; &nbsp; * 用于表示带小数点的实数，包括 <code>float</code>, <code>double</code>, <code>long double</code>。<br>&nbsp; &nbsp; * <strong>科学计数法:</strong> 使用 <code>E</code> 或 <code>e</code> 表示，如 <code>1.84E1</code> (即 1.84 x 10¹)。<br>&nbsp; &nbsp; * <strong>默认类型:</strong> 没有后缀的浮点常量（如 <code>94.6</code>）默认为 <code>double</code> 类型。<br>&nbsp; &nbsp; * <strong>后缀:</strong> <code>F</code> 或 <code>f</code> 表示 <code>float</code> (如 <code>94.6F</code>)；<code>L</code> 或 <code>l</code> 表示 <code>long double</code>。<br>&nbsp; &nbsp; * <strong>精度:</strong> 计算机不能精确表示所有浮点数。<code>double</code> 的精度高于或等于 <code>float</code>。</li>\n<li><strong>布尔型 (<code>bool</code>):</strong><br>&nbsp; &nbsp; * C99标准引入，需要包含头文件 <code>&lt;stdbool.h&gt;</code>。<br>&nbsp; &nbsp; * 值只有 <code>true</code> (1) 或 <code>false</code> (0)。</li>\n<li><strong>字符串型 (String):</strong><br>&nbsp; &nbsp; * 用双引号 <code>\" \"</code> 括起来的字符序列，如 <code>\"Hello\"</code>。<br>&nbsp; &nbsp; * <strong>不是C的内置类型</strong>，它本质上是一个 <strong>字符数组 (char array)</strong>。<br>&nbsp; &nbsp; * 以空字符 <code>\\0</code> 作为结尾标记。<br>&nbsp; &nbsp; * 字符串操作函数（如 <code>strlen</code>）定义在 <code>&lt;string.h&gt;</code> 头文件中。<br>&nbsp; &nbsp; * <code>\"a\"</code> (字符串) 与 <code>'a'</code> (字符) 是不同的。</li>\n</ul>\n<h3><span id=\"23-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\">2.3 运算符与表达式</span></h3><ul>\n<li><strong>表达式 (Expression):</strong> 变量、常量和运算符的有效组合，可被求值以计算出一个值。</li>\n<li><strong>算术运算符 (Arithmetic):</strong><br>&nbsp; &nbsp; * 一元：<code>+</code> (正), <code>-</code> (负)。<br>&nbsp; &nbsp; * 二元：<code>+</code>, <code>-</code>, <code>*</code>。<br>&nbsp; &nbsp; * <strong><code>/</code> (除法):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。<br>&nbsp; &nbsp; * <strong><code>%</code> (模/取余):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 操作数 <strong>只能是整数</strong>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 结果是整数除法后的余数。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 结果的符号由左操作数决定 (C语言中)。</li>\n<li><strong>自增/自减运算符:</strong><br>&nbsp; &nbsp; * <code>++</code> (自增) 和 <code>--</code> (自减)。<br>&nbsp; &nbsp; * <strong>前缀 (Prefix):</strong> <code>++a</code>。先改变（加1或减1），再使用新值参与表达式运算。<br>&nbsp; &nbsp; * <strong>后缀 (Postfix):</strong> <code>a++</code>。先使用原值参与表达式运算，然后再改变（加1或减1）。</li>\n<li><strong>赋值运算符 (Assignment):</strong><br>&nbsp; &nbsp; * <code>=</code> (赋值)。<br>&nbsp; &nbsp; * <strong>复合赋值:</strong> <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>。例如 <code>age += 3;</code> 等同于 <code>age = age + 3;</code>。</li>\n<li><strong>关系运算符 (Relational):</strong><br>&nbsp; &nbsp; * <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code> (等于), <code>!=</code> (不等于)。<br>&nbsp; &nbsp; * 结果为 <code>true</code> (非0) 或 <code>false</code> (0)。<br>&nbsp; &nbsp; * 注意：<code>=</code> (赋值) 和 <code>==</code> (等于) 是不同的。</li>\n<li><strong>逻辑运算符 (Logical):</strong><br>&nbsp; &nbsp; * <code>!</code> (非), <code>&amp;&amp;</code> (与), <code>||</code> (或)。<br>&nbsp; &nbsp; * <strong>短路求值 (Short-Circuit):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 对于 <code>&amp;&amp;</code>：如果左侧为 <code>false</code> (0)，则不再计算右侧。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 对于 <code>||</code>：如果左侧为 <code>true</code> (非0)，则不再计算右侧。</li>\n<li><strong>条件运算符 (Ternary):</strong><br>&nbsp; &nbsp; * C语言中唯一的三元运算符：<code>Expression1 ? Expression2 : Expression3</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression1</code> 为 <code>true</code>，则整个表达式的值为 <code>Expression2</code>；否则为 <code>Expression3</code>。</li>\n<li><strong>位运算符 (Bitwise):</strong><br>&nbsp; &nbsp; * 对操作数的二进制位进行操作。<br>&nbsp; &nbsp; * <code>&amp;</code> (按位与), <code>|</code> (按位或), <code>^</code> (按位异或), <code>~</code> (按位非/取反)。<br>&nbsp; &nbsp; * <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)。</li>\n<li><strong>逗号运算符 (Comma):</strong><br>&nbsp; &nbsp; * <code>expression1, expression2</code>。<br>&nbsp; &nbsp; * 从左到右依次求值，整个表达式的值等于最后一个表达式 (<code>expression2</code>) 的值。<br>&nbsp; &nbsp; * 优先级是所有运算符中最低的。</li>\n<li><strong>优先级 (Precedence) 与 结合性 (Associativity):</strong><br>&nbsp; &nbsp; * <strong>优先级</strong> 决定了哪个运算符先执行（如 <code>*</code> / <code>/</code> 优先于 <code>+</code> / <code>-</code>）。<br>&nbsp; &nbsp; * <strong>结合性</strong> 决定了同优先级运算符的执行顺序（如 <code>* / % + -</code> 都是左结合，从左到右）。<br>&nbsp; &nbsp; * 一元运算符、条件运算符、赋值运算符是 <strong>右结合</strong>（从右到左）。<br>&nbsp; &nbsp; * 可以使用 <strong>圆括号 <code>()</code></strong> 来强制改变运算顺序。</li>\n<li><strong>类型转换 (Type Conversion):</strong><br>&nbsp; &nbsp; * <strong>隐式转换 (Coercion):</strong> 编译器自动进行的类型转换。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 发生在赋值时（如 <code>int i = 4.8;</code> i 变为 4）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 发生在混合类型表达式中。<br>&nbsp; &nbsp; * <strong>类型提升 (Promotion):</strong> 在表达式中，<code>char</code> 和 <code>short</code> 类型的值会自动提升为 <code>int</code>。<br>&nbsp; &nbsp; * <strong>混合运算:</strong> 较低类型会临时提升为较高类型（int -&gt; long -&gt; float -&gt; double）。<br>&nbsp; &nbsp; * <strong>显式转换 (Casting):</strong> 程序员强制进行的类型转换。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 语法：<code>(typename) expression</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 示例：<code>celsius = (5.0/9.0) * (fahr-32);</code>（对比 <code>5/9</code> 结果为0）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 浮点数转整数时，C99规定向0取整（截断小数）。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC3%E7%AB%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84\">第3章：控制结构</span></h2><h3><span id=\"31-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84\">3.1 选择结构</span></h3><ul>\n<li><strong><code>if</code> 语句 (单路选择):</strong><br>&nbsp; &nbsp; * 语法：<code>if ( Expression ) Statement</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression</code> 为 <code>true</code> (非0)，则执行 <code>Statement</code>。</li>\n<li><strong><code>if-else</code> 语句 (双路选择):</strong><br>&nbsp; &nbsp; * 语法：<code>if ( Expression ) StatementA else StatementB</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression</code> 为 <code>true</code>，执行 <code>StatementA</code>；否则执行 <code>StatementB</code>。</li>\n<li><strong><code>{}</code> 块的使用:</strong><br>&nbsp; &nbsp; * <code>if</code> 或 <code>else</code> 后面如果需要执行多条语句，必须使用花括号 <code>{}</code> 将它们括起来形成一个语句块。<br>&nbsp; &nbsp; * 如果省略 <code>{}</code>，<code>else</code> 会与最近的未配对的 <code>if</code> 结合（<strong>悬垂else问题</strong>）。</li>\n<li><strong><code>if-else if-else</code> 结构 (多路选择):</strong><br>&nbsp; &nbsp; * 用于实现多路分支。<br>&nbsp; &nbsp; * 按顺序测试每个 <code>Expression</code>，一旦找到为 <code>true</code> 的，就执行其后的 <code>Statement</code>，然后跳出整个结构。<br>&nbsp; &nbsp; * 如果所有 <code>if</code> 都不为 <code>true</code>，则执行最后的 <code>else</code> 块（如果存在）。</li>\n<li><strong><code>switch</code> 语句 (多路选择):</strong><br>&nbsp; &nbsp; * 语法：<code>switch ( IntegralExpression ) { ... }</code>。<br>&nbsp; &nbsp; * <code>IntegralExpression</code> 必须是整型（<code>char</code>, <code>int</code>, <code>long</code>, <code>enum</code>）。<br>&nbsp; &nbsp; * <code>case Constant:</code>：<code>Constant</code> 必须是常量表达式。<br>&nbsp; &nbsp; * <strong><code>break</code>:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 用于跳出 <code>switch</code> 语句。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 如果省略 <code>break</code>，程序会 <strong>穿透 (fall-through)</strong> 并继续执行下一个 <code>case</code> 的语句。<br>&nbsp; &nbsp; * <strong><code>default</code>:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 可选。如果没有任何 <code>case</code> 匹配，则执行 <code>default</code> 块。</li>\n<li><strong>测试:</strong><br>&nbsp; &nbsp; * 测试选择结构时，应确保每个分支至少被执行一次（<strong>最小完全覆盖</strong>）。</li>\n</ul>\n<h3><span id=\"32-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84\">3.2 循环结构</span></h3><ul>\n<li><strong>循环 (Loop):</strong> 一种重复执行某个语句块的控制结构。</li>\n<li><strong><code>while</code> 循环 (当型循环):</strong><br>&nbsp; &nbsp; * 语法：<code>while ( Expression ) { ...body... }</code>。<br>&nbsp; &nbsp; * <strong>先测试 (Pre-test):</strong> 在每次迭代 <em>之前</em> 检查 <code>Expression</code>。<br>&nbsp; &nbsp; * 如果 <code>Expression</code> 为 <code>false</code>，循环体可能一次也不执行。</li>\n<li><strong><code>do-while</code> 循环 (直到型循环):</strong><br>&nbsp; &nbsp; * 语法：<code>do { ...body... } while ( Expression );</code>。<br>&nbsp; &nbsp; * <strong>后测试 (Post-test):</strong> 在每次迭代 <em>之后</em> 检查 <code>Expression</code>。<br>&nbsp; &nbsp; * 循环体 <strong>至少执行一次</strong>。</li>\n<li><strong><code>for</code> 循环:</strong><br>&nbsp; &nbsp; * 语法：<code>for ( initialization ; test_expression ; update ) { ...body... }</code>。<br>&nbsp; &nbsp; * <code>initialization</code>：循环开始前执行一次（通常用于初始化循环变量）。<br>&nbsp; &nbsp; * <code>test_expression</code>：每次迭代前检查，若为 <code>false</code> 则退出循环。<br>&nbsp; &nbsp; * <code>update</code>：每次迭代 <em>之后</em> 执行（通常用于更新循环变量）。</li>\n<li><strong>循环控制:</strong><br>&nbsp; &nbsp; * <strong><code>break</code>:</strong> 立即 <strong>跳出</strong> 并终止其所在的最内层循环（或 <code>switch</code>）。<br>&nbsp; &nbsp; * <strong><code>continue</code>:</strong> 立即 <strong>跳过</strong> 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 <code>for</code> 循环，会先执行 <code>update</code>）。<br>&nbsp; &nbsp; * <strong><code>goto</code> 和 <code>label</code>:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 提供从 <code>goto</code> 到同一函数内 <code>label</code> 的无条件跳转。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 不推荐使用，但可用于跳出深度嵌套的结构。</li>\n<li><strong>嵌套循环 (Nested Loop):</strong><br>&nbsp; &nbsp; * 一个循环体内包含另一个循环。<br>&nbsp; &nbsp; * <code>break</code> 或 <code>continue</code> 只影响最内层的循环。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC4%E7%AB%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84\">第4章：函数与程序结构</span></h2><h3><span id=\"41-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80\">4.1 函数基础</span></h3><ul>\n<li><strong>函数 (Function):</strong> 用于实现特定功能的一段程序代码。</li>\n<li><strong>使用原因:</strong> 避免代码重复、使程序结构化、提高可读性。</li>\n<li><strong>函数声明 (Declaration / Prototype):</strong><br>&nbsp; &nbsp; * 告知编译器函数的返回类型、名称和参数类型。<br>&nbsp; &nbsp; * 语法：<code>type function_name(type arg1, type arg2, ...);</code>。<br>&nbsp; &nbsp; * 必须在使用函数前进行声明（通常放在 <code>main</code> 函数之前）。</li>\n<li><strong>函数定义 (Definition):</strong><br>&nbsp; &nbsp; * 提供函数的具体实现（函数头 + 函数体）。<br>&nbsp; &nbsp; * <strong>函数头 (Head):</strong> <code>type function_name(type arg1, type arg2, ...)</code>。<br>&nbsp; &nbsp; * <strong>函数体 (Body):</strong> <code>{ ... your code ... }</code>。</li>\n<li><strong><code>return</code> 语句:</strong><br>&nbsp; &nbsp; * 用于从函数返回一个值。<br>&nbsp; &nbsp; * 函数最多只能返回 <strong>1个</strong> 值，该值的类型必须与声明的返回类型匹配。<br>&nbsp; &nbsp; * <strong><code>void</code> 函数:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 表示函数不返回值。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 可以使用 <code>return;</code> 语句立即退出函数。</li>\n<li><strong>函数调用 (Function Call):</strong><br>&nbsp; &nbsp; * 通过函数名和参数列表来执行函数。<br>&nbsp; &nbsp; * 程序控制权临时从调用函数转移到被调用函数。<br>&nbsp; &nbsp; * 被调用函数执行完毕后，控制权返回到调用点。</li>\n</ul>\n<h3><span id=\"42-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\">4.2 参数传递</span></h3><ul>\n<li><strong>形参 (Parameter / Formal Parameter):</strong> 在函数 <strong>定义</strong> 或声明中指定的变量。</li>\n<li><strong>实参 (Argument / Actual Parameter):</strong> 在函数 <strong>调用</strong> 时传递给函数的具体值或变量。</li>\n<li><strong>传递方式:</strong><br>&nbsp; &nbsp; 1. &nbsp;<strong>值传递 (Pass by Value):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * C语言的默认方式。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 将实参的 <strong>值复制</strong> 一份传递给形参。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 在函数内部修改形参 <strong>不会</strong> 影响到函数外部的实参。<br>&nbsp; &nbsp; 2. &nbsp;<strong>地址/指针传递 (Pass by Address):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 将实参的 <strong>地址</strong> 传递给形参。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 形参必须是 <strong>指针类型</strong> (如 <code>int *x</code>)。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 实参必须是地址（如 <code>&amp;a</code>）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 在函数内部通过指针修改形参所指向的内存，<strong>会</strong> 影响到函数外部的实参。<br>&nbsp; &nbsp; 3. &nbsp;<strong>引用传递 (Pass by Reference):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 这是 C++ 的特性，<strong>C语言不支持</strong>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 形参是实参的别名（如 <code>int &amp;x</code>）。</li>\n</ul>\n<h3><span id=\"43-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B\">4.3 作用域、生命周期与存储类型</span></h3><ul>\n<li><strong>作用域 (Scope):</strong> 标识符（变量或函数名）在程序中可以被合法使用的区域。<br>&nbsp; &nbsp; * <strong>局部作用域 (Local Scope):</strong> 标识符在块（<code>{}</code>内）或函数内部声明，其作用域从声明点到块或函数结束。<br>&nbsp; &nbsp; * <strong>全局作用域 (Global Scope):</strong> 标识符在所有函数之外声明，其作用域从声明点到文件结尾。<br>&nbsp; &nbsp; * <strong>名称优先级:</strong> 局部变量会“隐藏”同名的全局变量。</li>\n<li><strong>生命周期 (Lifetime):</strong> 程序执行期间，标识符实际拥有内存分配的时间。</li>\n<li><strong>存储类型:</strong><br>&nbsp; &nbsp; * <strong>自动变量 (Automatic):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 默认的局部变量存储类型（可省略 <code>auto</code> 关键字）。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 存储在 <strong>栈</strong> 中。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>生命周期:</strong> 函数调用时创建，函数退出时销毁。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。<br>&nbsp; &nbsp; * <strong>外部变量 (External):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 即全局变量，定义在所有函数之外。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 使用 <code>extern</code> 关键字在其他文件中 <strong>声明</strong> （非定义），表示引用一个已在别处定义的全局变量。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>生命周期:</strong> 整个程序运行期间。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>&nbsp; &nbsp; * <strong>静态变量 (Static):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 使用 <code>static</code> 关键字声明。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>静态全局变量:</strong> 作用域被限制在声明它的文件内部，其他文件不可访问。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>静态局部变量:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 作用域仍是局部的（函数内）。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * <strong>生命周期:</strong> 整个程序运行期间。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 只在 <strong>第一次</strong> 调用函数时初始化一次。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 在函数多次调用之间 <strong>保持其值</strong>。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>&nbsp; &nbsp; * <strong>寄存器变量 (Register):</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 使用 <code>register</code> 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。<br>&nbsp; &nbsp; &nbsp; &nbsp; * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。</li>\n</ul>\n<h3><span id=\"44-%E9%80%92%E5%BD%92\">4.4 递归</span></h3><ul>\n<li><strong>递归 (Recursion):</strong> 一个函数调用其自身的过程。</li>\n<li><strong>递归的两个要素:</strong><br>&nbsp; &nbsp; 1. &nbsp;<strong>基本情况 (Base Case):</strong> 递归的停止条件，一个无需递归即可解决的简单情况。<br>&nbsp; &nbsp; 2. &nbsp;<strong>递归步骤 (Recursive Step):</strong> 将问题分解为更小的、同类的问题，并通过递归调用来解决。</li>\n<li><strong>递归 vs. 迭代 (Iteration):</strong><br>&nbsp; &nbsp; * 任何递归都可以用迭代（循环）和栈来代替。<br>&nbsp; &nbsp; * 迭代（循环）在执行速度和空间占用上通常 <strong>优于</strong> 递归。</li>\n</ul>\n<h3><span id=\"45-c%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\">4.5 C预处理器</span></h3><ul>\n<li>在编译之前对源代码进行处理的程序。</li>\n<li><strong>文件包含 (<code>#include</code>):</strong><br>&nbsp; &nbsp; * <code>#include &lt;filename&gt;</code>: 在标准库目录或系统路径中查找文件。<br>&nbsp; &nbsp; * <code>#include \"filename\"</code>: 从源程序当前目录开始搜索（通常用于自定义头文件）。</li>\n<li><strong>宏替换 (<code>#define</code>):</strong><br>&nbsp; &nbsp; * 定义一个宏（一个名称和一段替换文本）。<br>&nbsp; &nbsp; * 预处理器会在编译前进行 <strong>原样文本替换</strong>。<br>&nbsp; &nbsp; * <strong>带参数的宏:</strong> <code>define max(A,B) ((A) &gt; (B) ? (A) : (B))</code>。<br>&nbsp; &nbsp; * <strong>宏的陷阱:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。<br>&nbsp; &nbsp; &nbsp; &nbsp; * 注意带副作用的参数，如 <code>max(i++, j++)</code>，会导致 <code>i</code> 或 <code>j</code> 被自增多次。</li>\n<li><strong>条件包含 (<code>#if</code>…):</strong><br>&nbsp; &nbsp; * 允许根据预处理时的条件来选择性地编译某段代码。<br>&nbsp; &nbsp; * 指令包括：<code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>。<br>&nbsp; &nbsp; * <code>#ifndef</code>: “if not defined”，常用于防止头文件被重复包含。</li>\n</ul>\n<h2><span id=\"%E7%AC%AC5%E7%AB%A0%E6%95%B0%E7%BB%84\">第5章：数组</span></h2><h3><span id=\"51-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84\">5.1 一维数组</span></h3><ul>\n<li><strong>数组 (Array):</strong> 存储 <strong>相同数据类型</strong> 的元素的集合，这些元素在内存中 <strong>连续存放</strong>。</li>\n<li><strong>数组声明:</strong><br>&nbsp; &nbsp; * 语法：<code>DataType ArrayName [ConstIntExpression];</code>。<br>&nbsp; &nbsp; * <code>ConstIntExpression</code> 必须是 <strong>常量表达式</strong>，指定数组的大小（元素个数）。<br>&nbsp; &nbsp; * 数组大小一旦固定，不可更改。</li>\n<li><strong>数组元素访问:</strong><br>&nbsp; &nbsp; * 通过 <strong>下标 (Index / Subscript)</strong> 访问，下标从 <strong>0</strong> 开始。<br>&nbsp; &nbsp; * <code>temps[0]</code> 是第一个元素，<code>temps[4]</code> 是第五个元素（对于大小为5的数组）。</li>\n<li><strong>数组名:</strong><br>&nbsp; &nbsp; * 数组名（如 <code>temps</code>）本身是一个 <strong>指针</strong>，其值是数组的 <strong>基地址</strong>（即第一个元素 <code>temps[0]</code> 的内存地址）。</li>\n<li><strong>数组初始化:</strong><br>&nbsp; &nbsp; * 可以在声明时初始化：<code>int ages[5] = {40, 13, 20, 19, 36};</code>。<br>&nbsp; &nbsp; * 可以省略大小，编译器会自动计算：<code>int ages[] = {40, 13, 20};</code>。<br>&nbsp; &nbsp; * <strong>部分初始化:</strong> <code>int a[5] = { 2 };</code> 第一个元素为2，其余所有元素自动初始化为 0。</li>\n<li><strong>数组的限制:</strong><br>&nbsp; &nbsp; * <strong>无边界检查 (No Bound Checking):</strong> C语言不检查数组下标是否越界。访问 <code>myList[-1]</code> 或 <code>myList[11]</code>（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。<br>&nbsp; &nbsp; * <strong>无聚合操作 (No Aggregate Operations):</strong> 不能将一个数组整体赋值给另一个数组（如 <code>x = y;</code> 是错误的）。<br>&nbsp; &nbsp; * 数组复制必须通过循环逐个元素进行。</li>\n</ul>\n<h3><span id=\"52-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0\">5.2 数组与函数</span></h3><ul>\n<li><strong>数组作为函数参数:</strong><br>&nbsp; &nbsp; * 当数组作为参数传递时，传递的是数组的 <strong>基地址</strong>。<br>&nbsp; &nbsp; * 因此，函数参数传递总是 <strong>地址传递</strong>。<br>&nbsp; &nbsp; * 在函数内部对形参数组的修改 <strong>会</strong> 影响到主调函数中的实参数组。<br>&nbsp; &nbsp; * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。</li>\n<li><strong>形参声明:</strong><br>&nbsp; &nbsp; * <code>float FindMax(float arr[], int n)</code><br>&nbsp; &nbsp; * <code>float FindMax(float *arr, int n)</code> (等价)</li>\n<li><strong><code>const</code> 保护数组参数:</strong><br>&nbsp; &nbsp; * 如果不希望函数修改数组内容，应在形参声明中使用 <code>const</code> 关键字。<br>&nbsp; &nbsp; * 示例：<code>float FindMax(const float arr[], int n)</code>。</li>\n</ul>\n<h3><span id=\"53-%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2\">5.3 数组算法：排序与搜索</span></h3><ul>\n<li><strong>选择排序 (Selection Sort):</strong><br>&nbsp; &nbsp; * <strong>算法思想:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;从头（<code>passCount = 0</code>）开始。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;在 <code>data[passCount ... length-1]</code> 范围内找到 <strong>最小</strong> 元素的索引 <code>minIndx</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;将 <code>data[minIndx]</code> 与 <code>data[passCount]</code> 交换。<br>&nbsp; &nbsp; &nbsp; &nbsp; 4. &nbsp;<code>passCount</code> 增加1，重复该过程，直到 <code>passCount</code> 达到 <code>length - 2</code>。</li>\n<li><strong>线性搜索 (Linear / Sequential Search):</strong><br>&nbsp; &nbsp; * 适用于 <strong>未排序</strong> 的数组。<br>&nbsp; &nbsp; * 从头到尾（<code>i=0</code> 到 <code>n-1</code>）逐个检查元素，看是否等于目标值 <code>x</code>。<br>&nbsp; &nbsp; * 找到则返回索引 <code>i</code>，遍历完未找到则返回 <code>-1</code>。</li>\n<li><strong>二分搜索 (Binary Search):</strong><br>&nbsp; C* <strong>必须</strong> 适用于 <strong>已排序</strong> 的数组。<br>&nbsp; &nbsp; * <strong>算法思想:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;设 <code>first = 0</code>, <code>last = arraySize - 1</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 2. &nbsp;当 <code>last &gt;= first</code> 时循环：<br>&nbsp; &nbsp; &nbsp; &nbsp; 3. &nbsp;计算中间索引 <code>mid = (first + last) / 2</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 4. &nbsp;如果 <code>key == list[mid]</code>，则找到，返回 <code>mid</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 5. &nbsp;如果 <code>key &lt; list[mid]</code>，则目标在左半边，令 <code>last = mid - 1</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 6. &nbsp;如果 <code>key &gt; list[mid]</code>，则目标在右半边，令 <code>first = mid + 1</code>。<br>&nbsp; &nbsp; &nbsp; &nbsp; 7. &nbsp;循环结束仍未找到，返回 <code>-1</code>。</li>\n</ul>\n<h3><span id=\"54-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">5.4 多维数组</span></h3><ul>\n<li><strong>二维数组 (Two-Dimensional Array):</strong><br>&nbsp; &nbsp; * 按行和列组织的同类型元素集合。<br>&nbsp; &nbsp; * <strong>声明:</strong> <code>DataType ArrayName [Rows] [Cols];</code>。<br>&nbsp; &nbsp; * <strong>访问:</strong> <code>stateHighs[2][7]</code> (访问第3行第8列的元素)。<br>&nbsp; &nbsp; * <strong>内存存储:</strong> 在内存中按 <strong>行优先 (Row Order)</strong> 连续存储（第一行所有元素，接着是第二行所有元素…）。</li>\n<li><strong>多维数组作为函数参数:</strong><br>&nbsp; &nbsp; * 传递的仍然是基地址。<br>&nbsp; &nbsp; * <strong>必须</strong> 指定 <strong>除第一维之外</strong> 的所有维度的大小。<br>&nbsp; &nbsp; * 示例：<code>void FindAverages(const int stateHighs[][NUM_MONTHS], ...)</code>。</li>\n<li><strong><code>typedef</code> 与数组:</strong><br>&nbsp; &nbsp; * 可以使用 <code>typedef</code> 来定义数组类型，使函数原型更简洁明了。<br>&nbsp; &nbsp; * 示例：<code>typedef int SalesType[3][12][5];</code> <code>SalesType sales;</code>。</li>\n</ul>\n</body></html>","excerpt":"","more":"<p>我发现好久好久没写博客了。<br>懒狗是这样的。<br>先传一点笔记吧。  </p>\n<hr>\n<h3 id=\"📚-知识点大纲\"><a href=\"#📚-知识点大纲\" class=\"headerlink\" title=\"📚 知识点大纲\"></a>📚 知识点大纲</h3><ol>\n<li><strong>第1章：程序设计与问题解决概述</strong><ul>\n<li>1.1 程序与程序设计</li>\n<li>1.2 问题解决的阶段</li>\n<li>1.3 编程语言的层次</li>\n<li>1.4 程序的编译与执行</li>\n<li>1.5 基本控制结构</li>\n<li>1.6 计算机基本组成</li>\n</ul>\n</li>\n<li><strong>第2章：C语言基础：类型、变量、常量与运算符</strong><ul>\n<li>2.1 标识符、变量与常量</li>\n<li>2.2 数据类型</li>\n<li>2.3 运算符与表达式</li>\n</ul>\n</li>\n<li><strong>第3章：控制结构</strong><ul>\n<li>3.1 选择结构</li>\n<li>3.2 循环结构</li>\n</ul>\n</li>\n<li><strong>第4章：函数与程序结构</strong><ul>\n<li>4.1 函数基础</li>\n<li>4.2 参数传递</li>\n<li>4.3 作用域、生命周期与存储类型</li>\n<li>4.4 递归</li>\n<li>4.5 C预处理器</li>\n</ul>\n</li>\n<li><strong>第5章：数组</strong><ul>\n<li>5.1 一维数组</li>\n<li>5.2 数组与函数</li>\n<li>5.3 数组算法：排序与搜索</li>\n<li>5.4 多维数组</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"📖-详细知识点\"><a href=\"#📖-详细知识点\" class=\"headerlink\" title=\"📖 详细知识点\"></a>📖 详细知识点</h3><h2 id=\"第1章：程序设计与问题解决概述\"><a href=\"#第1章：程序设计与问题解决概述\" class=\"headerlink\" title=\"第1章：程序设计与问题解决概述\"></a>第1章：程序设计与问题解决概述</h2><h3 id=\"1-1-程序与程序设计\"><a href=\"#1-1-程序与程序设计\" class=\"headerlink\" title=\"1.1 程序与程序设计\"></a>1.1 程序与程序设计</h3><ul>\n<li><strong>程序 (Program):</strong> 由计算机执行的一系列指令。</li>\n<li><strong>程序设计 (Programming):</strong> 为计算机规划一系列执行步骤的过程。</li>\n</ul>\n<h3 id=\"1-2-问题解决的阶段\"><a href=\"#1-2-问题解决的阶段\" class=\"headerlink\" title=\"1.2 问题解决的阶段\"></a>1.2 问题解决的阶段</h3><ol>\n<li> <strong>问题解决阶段:</strong><br>    * 需求分析与规范。<br>    * <strong>算法设计 (Algorithm):</strong> 在有限的时间内逐步解决问题的过程。</li>\n<li> <strong>实现阶段:</strong><br>    * <strong>编码 (Coding):</strong> 将算法翻译成编程语言。<br>    * 调试与测试。</li>\n<li> <strong>维护阶段:</strong><br>    * 使用、修正错误、改进功能。</li>\n</ol>\n<h3 id=\"1-3-编程语言的层次\"><a href=\"#1-3-编程语言的层次\" class=\"headerlink\" title=\"1.3 编程语言的层次\"></a>1.3 编程语言的层次</h3><ul>\n<li><strong>机器语言 (Machine Language):</strong><br>    * 由0和1组成的二进制编码指令。<br>    * 计算机唯一可以直接理解和执行的语言。<br>    * 不可移植，可读性差。</li>\n<li><strong>汇编语言 (Assembly Language):</strong><br>    * 使用助记符（如 <code>LOAD</code>, <code>ADD</code>）来表示机器指令。<br>    * 需要汇编器(Assembler)进行翻译。</li>\n<li><strong>高级语言 (High-level Language):</strong><br>    * 语言类似自然语言，易于读、写和理解。<br>    * 可移植性好。<br>    * 示例：C, C++, Java, Python。</li>\n</ul>\n<h3 id=\"1-4-程序的编译与执行\"><a href=\"#1-4-程序的编译与执行\" class=\"headerlink\" title=\"1.4 程序的编译与执行\"></a>1.4 程序的编译与执行</h3><ul>\n<li><strong>编译器 (Compiler):</strong><br>    * 将高级语言（源码）一次性翻译成机器语言（目标文件）的程序。<br>    * 编译型语言执行速度通常更快，源码是私有的。<br>    * 缺点是不跨平台（C, C++）。</li>\n<li><strong>解释器 (Interpreter):</strong><br>    * 逐行解释并执行源代码。<br>    * 解释型语言通常跨平台，易于调试。<br>    * 缺点是执行速度较慢，源码是公开的（Python, PHP）。</li>\n<li><strong>C语言的编译执行流程:</strong><br>    1.  <strong>源文件 (Source):</strong> 程序员编写的 <code>.c</code> 文件（如 <code>myprog.c</code>）。<br>    2.  <strong>编译器 (Compiler):</strong> 将源文件翻译成机器语言的 <strong>目标文件 (Object)</strong>（如 <code>myprog.o</code>）。<br>    3.  <strong>链接器 (Linker):</strong> 将目标文件与库函数等其他代码组合起来，生成 <strong>可执行文件 (Executable)</strong>（如 <code>myprog.exe</code>）。</li>\n</ul>\n<h3 id=\"1-5-基本控制结构\"><a href=\"#1-5-基本控制结构\" class=\"headerlink\" title=\"1.5 基本控制结构\"></a>1.5 基本控制结构</h3><p>程序由四种基本的控制结构组成：</p>\n<ol>\n<li> <strong>顺序结构 (Sequence):</strong> 语句按顺序一条接一条地执行。</li>\n<li> <strong>选择结构 (Selection &#x2F; Branch):</strong> 根据特定条件执行不同的语句（如 <code>if</code>, <code>switch</code>）。</li>\n<li> <strong>循环结构 (Loop &#x2F; Repetition):</strong> 在满足特定条件时重复执行某些语句（如 <code>while</code>, <code>for</code>）。</li>\n<li> <strong>子程序 (Subprogram &#x2F; Function):</strong> 将程序分解为更小的单元（函数）。</li>\n</ol>\n<h3 id=\"1-6-计算机基本组成\"><a href=\"#1-6-计算机基本组成\" class=\"headerlink\" title=\"1.6 计算机基本组成\"></a>1.6 计算机基本组成</h3><ul>\n<li><strong>硬件 (Hardware):</strong><br>    * <strong>中央处理单元 (CPU):</strong><br>        * <strong>算术逻辑单元 (ALU):</strong> 执行算术运算和逻辑比较。<br>        * <strong>控制单元 (Control Unit):</strong> 控制程序指令的执行顺序。<br>    * <strong>内存单元 (Memory Unit):</strong><br>        * 有序的存储单元序列，每个单元有唯一地址。<br>        * 用于存放数据和程序指令。<br>    * <strong>外围设备 (Peripherals):</strong><br>        * 输入设备（如键盘、鼠标）。<br>        * 输出设备（如显示器、打印机）。<br>        * 辅助存储设备（如硬盘、CD-ROM）。</li>\n<li><strong>软件 (Software):</strong><br>    * <strong>系统软件 (System Software):</strong> 如操作系统（OS），用于管理计算机资源。<br>    * <strong>应用软件 (Application):</strong> 用户执行特定任务的程序。</li>\n</ul>\n<h2 id=\"第2章：C语言基础：类型、变量、常量与运算符\"><a href=\"#第2章：C语言基础：类型、变量、常量与运算符\" class=\"headerlink\" title=\"第2章：C语言基础：类型、变量、常量与运算符\"></a>第2章：C语言基础：类型、变量、常量与运算符</h2><h3 id=\"2-1-标识符、变量与常量\"><a href=\"#2-1-标识符、变量与常量\" class=\"headerlink\" title=\"2.1 标识符、变量与常量\"></a>2.1 标识符、变量与常量</h3><ul>\n<li><strong>变量 (Variable):</strong><br>    * 程序中用于存放数据的容器（存储区域）。<br>    * 变量名是内存位置的符号表示。<br>    * 声明变量时必须指定其名称和数据类型。</li>\n<li><strong>标识符 (Identifier):</strong> (即变量名、函数名等)<br>    * <strong>命名规则:</strong><br>        1.  只能包含字母（大小写）、数字和下划线 <code>_</code>。<br>        2.  必须以字母或下划线 <code>_</code> 开头（不能是数字）。<br>        3.  长度：理论上无限制，但某些编译器可能对超过31个字符的名称报错。<br>    * <strong>命名注意事项:</strong><br>        1.  应使用有意义的名称（如 <code>firstName</code> 而不是 <code>fn</code>）。<br>        2.  <strong>区分大小写</strong> (如 <code>name</code> 和 <code>Name</code> 是不同的)。<br>        3.  <strong>不能</strong> 使用C语言的 <strong>关键字</strong> (Reserved words) 作为标识符。</li>\n<li><strong>常量 (Constant):</strong><br>    * <strong>字面值常量 (Literal value):</strong> 直接写在代码中的值，如 <code>100</code>, <code>3.14</code>, <code>&#39;A&#39;</code>。<br>    * <strong>命名常量 (Named constant):</strong><br>        1.  使用 <code>const</code> 修饰符：<code>const int VOTING_AGE = 18;</code>。<br>        2.  使用 <code>#define</code> 预处理指令：<code>#define VOTING_AGE 18</code>。<br>    * 命名常量的值在程序执行期间不能被更改。</li>\n<li><strong>声明与赋值:</strong><br>    * <strong>声明 (Declaration):</strong> 将标识符与数据对象（如变量）关联起来。所有标识符在使用前必须声明。<br>    * <strong>赋值 (Assignment):</strong> 使用赋值运算符 <code>=</code> 来给变量一个值。<br>        * 赋值语句的左侧必须是变量，右侧是值或表达式。</li>\n</ul>\n<h3 id=\"2-2-数据类型\"><a href=\"#2-2-数据类型\" class=\"headerlink\" title=\"2.2 数据类型\"></a>2.2 数据类型</h3><ul>\n<li><strong>数据类型 (Data Type):</strong><br>    * 指定了变量可以存储的数据类型（如整数、浮点数、字符等）。<br>    * 每种数据类型需要不同大小的内存。<br>    * C语言数据类型分为：简单类型、结构类型和地址类型。</li>\n<li><strong><code>sizeof</code> 运算符:</strong><br>    * 一个一元运算符，用于获取其操作数（变量或类型）所占用的内存字节大小。<br>    * 示例：<code>sizeof(int)</code>, <code>sizeof(age)</code>。<br>    * C语言保证的最小大小：<code>sizeof(char)</code> 为 1，<code>short</code> 至少16位，<code>long</code> 至少32位。</li>\n<li><strong>整型 (Integral Types):</strong><br>    * 用于表示整数，包括 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>。<br>    * <strong><code>char</code>:</strong> 字符类型，用于表示单个字符。<br>        * 字符在内存中以其 <strong>ASCII</strong> 码值（整数）存储。<br>        * 字符常量用单引号 <code>&#39; &#39;</code> 括起来，如 <code>&#39;B&#39;</code>, <code>&#39;4&#39;</code>。<br>        * <strong>转义字符 (Escape character):</strong> 特殊字符，如 <code>\\n</code> (换行), <code>\\t</code> (制表符), <code>\\\\</code> (反斜杠), <code>\\&quot;</code> (双引号)。<br>    * <strong>整型字面值:</strong><br>        * 十进制 (Decimal): 正常书写，如 <code>16</code>, <code>498</code>。<br>        * 八进制 (Octal): 以 <code>0</code> 开头，如 <code>022</code>。<br>        * 十六进制 (Hexadecimal): 以 <code>0x</code> 或 <code>0X</code> 开头，如 <code>0xFF</code>。</li>\n<li><strong>浮点型 (Floating Types):</strong><br>    * 用于表示带小数点的实数，包括 <code>float</code>, <code>double</code>, <code>long double</code>。<br>    * <strong>科学计数法:</strong> 使用 <code>E</code> 或 <code>e</code> 表示，如 <code>1.84E1</code> (即 1.84 x 10¹)。<br>    * <strong>默认类型:</strong> 没有后缀的浮点常量（如 <code>94.6</code>）默认为 <code>double</code> 类型。<br>    * <strong>后缀:</strong> <code>F</code> 或 <code>f</code> 表示 <code>float</code> (如 <code>94.6F</code>)；<code>L</code> 或 <code>l</code> 表示 <code>long double</code>。<br>    * <strong>精度:</strong> 计算机不能精确表示所有浮点数。<code>double</code> 的精度高于或等于 <code>float</code>。</li>\n<li><strong>布尔型 (<code>bool</code>):</strong><br>    * C99标准引入，需要包含头文件 <code>&lt;stdbool.h&gt;</code>。<br>    * 值只有 <code>true</code> (1) 或 <code>false</code> (0)。</li>\n<li><strong>字符串型 (String):</strong><br>    * 用双引号 <code>&quot; &quot;</code> 括起来的字符序列，如 <code>&quot;Hello&quot;</code>。<br>    * <strong>不是C的内置类型</strong>，它本质上是一个 <strong>字符数组 (char array)</strong>。<br>    * 以空字符 <code>\\0</code> 作为结尾标记。<br>    * 字符串操作函数（如 <code>strlen</code>）定义在 <code>&lt;string.h&gt;</code> 头文件中。<br>    * <code>&quot;a&quot;</code> (字符串) 与 <code>&#39;a&#39;</code> (字符) 是不同的。</li>\n</ul>\n<h3 id=\"2-3-运算符与表达式\"><a href=\"#2-3-运算符与表达式\" class=\"headerlink\" title=\"2.3 运算符与表达式\"></a>2.3 运算符与表达式</h3><ul>\n<li><strong>表达式 (Expression):</strong> 变量、常量和运算符的有效组合，可被求值以计算出一个值。</li>\n<li><strong>算术运算符 (Arithmetic):</strong><br>    * 一元：<code>+</code> (正), <code>-</code> (负)。<br>    * 二元：<code>+</code>, <code>-</code>, <code>*</code>。<br>    * <strong><code>/</code> (除法):</strong><br>        * 若两个操作数都为整数，则执行整数除法（结果为整数，小数部分被截断）。<br>        * 若任一操作数为浮点数，则执行浮点除法（结果为浮点数）。<br>    * <strong><code>%</code> (模&#x2F;取余):</strong><br>        * 操作数 <strong>只能是整数</strong>。<br>        * 结果是整数除法后的余数。<br>        * 结果的符号由左操作数决定 (C语言中)。</li>\n<li><strong>自增&#x2F;自减运算符:</strong><br>    * <code>++</code> (自增) 和 <code>--</code> (自减)。<br>    * <strong>前缀 (Prefix):</strong> <code>++a</code>。先改变（加1或减1），再使用新值参与表达式运算。<br>    * <strong>后缀 (Postfix):</strong> <code>a++</code>。先使用原值参与表达式运算，然后再改变（加1或减1）。</li>\n<li><strong>赋值运算符 (Assignment):</strong><br>    * <code>=</code> (赋值)。<br>    * <strong>复合赋值:</strong> <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>。例如 <code>age += 3;</code> 等同于 <code>age = age + 3;</code>。</li>\n<li><strong>关系运算符 (Relational):</strong><br>    * <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code> (等于), <code>!=</code> (不等于)。<br>    * 结果为 <code>true</code> (非0) 或 <code>false</code> (0)。<br>    * 注意：<code>=</code> (赋值) 和 <code>==</code> (等于) 是不同的。</li>\n<li><strong>逻辑运算符 (Logical):</strong><br>    * <code>!</code> (非), <code>&amp;&amp;</code> (与), <code>||</code> (或)。<br>    * <strong>短路求值 (Short-Circuit):</strong><br>        * 对于 <code>&amp;&amp;</code>：如果左侧为 <code>false</code> (0)，则不再计算右侧。<br>        * 对于 <code>||</code>：如果左侧为 <code>true</code> (非0)，则不再计算右侧。</li>\n<li><strong>条件运算符 (Ternary):</strong><br>    * C语言中唯一的三元运算符：<code>Expression1 ? Expression2 : Expression3</code>。<br>    * 如果 <code>Expression1</code> 为 <code>true</code>，则整个表达式的值为 <code>Expression2</code>；否则为 <code>Expression3</code>。</li>\n<li><strong>位运算符 (Bitwise):</strong><br>    * 对操作数的二进制位进行操作。<br>    * <code>&amp;</code> (按位与), <code>|</code> (按位或), <code>^</code> (按位异或), <code>~</code> (按位非&#x2F;取反)。<br>    * <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)。</li>\n<li><strong>逗号运算符 (Comma):</strong><br>    * <code>expression1, expression2</code>。<br>    * 从左到右依次求值，整个表达式的值等于最后一个表达式 (<code>expression2</code>) 的值。<br>    * 优先级是所有运算符中最低的。</li>\n<li><strong>优先级 (Precedence) 与 结合性 (Associativity):</strong><br>    * <strong>优先级</strong> 决定了哪个运算符先执行（如 <code>*</code> &#x2F; <code>/</code> 优先于 <code>+</code> &#x2F; <code>-</code>）。<br>    * <strong>结合性</strong> 决定了同优先级运算符的执行顺序（如 <code>* / % + -</code> 都是左结合，从左到右）。<br>    * 一元运算符、条件运算符、赋值运算符是 <strong>右结合</strong>（从右到左）。<br>    * 可以使用 <strong>圆括号 <code>()</code></strong> 来强制改变运算顺序。</li>\n<li><strong>类型转换 (Type Conversion):</strong><br>    * <strong>隐式转换 (Coercion):</strong> 编译器自动进行的类型转换。<br>        * 发生在赋值时（如 <code>int i = 4.8;</code> i 变为 4）。<br>        * 发生在混合类型表达式中。<br>    * <strong>类型提升 (Promotion):</strong> 在表达式中，<code>char</code> 和 <code>short</code> 类型的值会自动提升为 <code>int</code>。<br>    * <strong>混合运算:</strong> 较低类型会临时提升为较高类型（int -&gt; long -&gt; float -&gt; double）。<br>    * <strong>显式转换 (Casting):</strong> 程序员强制进行的类型转换。<br>        * 语法：<code>(typename) expression</code>。<br>        * 示例：<code>celsius = (5.0/9.0) * (fahr-32);</code>（对比 <code>5/9</code> 结果为0）。<br>        * 浮点数转整数时，C99规定向0取整（截断小数）。</li>\n</ul>\n<h2 id=\"第3章：控制结构\"><a href=\"#第3章：控制结构\" class=\"headerlink\" title=\"第3章：控制结构\"></a>第3章：控制结构</h2><h3 id=\"3-1-选择结构\"><a href=\"#3-1-选择结构\" class=\"headerlink\" title=\"3.1 选择结构\"></a>3.1 选择结构</h3><ul>\n<li><strong><code>if</code> 语句 (单路选择):</strong><br>    * 语法：<code>if ( Expression ) Statement</code>。<br>    * 如果 <code>Expression</code> 为 <code>true</code> (非0)，则执行 <code>Statement</code>。</li>\n<li><strong><code>if-else</code> 语句 (双路选择):</strong><br>    * 语法：<code>if ( Expression ) StatementA else StatementB</code>。<br>    * 如果 <code>Expression</code> 为 <code>true</code>，执行 <code>StatementA</code>；否则执行 <code>StatementB</code>。</li>\n<li><strong><code>{}</code> 块的使用:</strong><br>    * <code>if</code> 或 <code>else</code> 后面如果需要执行多条语句，必须使用花括号 <code>{}</code> 将它们括起来形成一个语句块。<br>    * 如果省略 <code>{}</code>，<code>else</code> 会与最近的未配对的 <code>if</code> 结合（<strong>悬垂else问题</strong>）。</li>\n<li><strong><code>if-else if-else</code> 结构 (多路选择):</strong><br>    * 用于实现多路分支。<br>    * 按顺序测试每个 <code>Expression</code>，一旦找到为 <code>true</code> 的，就执行其后的 <code>Statement</code>，然后跳出整个结构。<br>    * 如果所有 <code>if</code> 都不为 <code>true</code>，则执行最后的 <code>else</code> 块（如果存在）。</li>\n<li><strong><code>switch</code> 语句 (多路选择):</strong><br>    * 语法：<code>switch ( IntegralExpression ) { ... }</code>。<br>    * <code>IntegralExpression</code> 必须是整型（<code>char</code>, <code>int</code>, <code>long</code>, <code>enum</code>）。<br>    * <code>case Constant:</code>：<code>Constant</code> 必须是常量表达式。<br>    * <strong><code>break</code>:</strong><br>        * 用于跳出 <code>switch</code> 语句。<br>        * 如果省略 <code>break</code>，程序会 <strong>穿透 (fall-through)</strong> 并继续执行下一个 <code>case</code> 的语句。<br>    * <strong><code>default</code>:</strong><br>        * 可选。如果没有任何 <code>case</code> 匹配，则执行 <code>default</code> 块。</li>\n<li><strong>测试:</strong><br>    * 测试选择结构时，应确保每个分支至少被执行一次（<strong>最小完全覆盖</strong>）。</li>\n</ul>\n<h3 id=\"3-2-循环结构\"><a href=\"#3-2-循环结构\" class=\"headerlink\" title=\"3.2 循环结构\"></a>3.2 循环结构</h3><ul>\n<li><strong>循环 (Loop):</strong> 一种重复执行某个语句块的控制结构。</li>\n<li><strong><code>while</code> 循环 (当型循环):</strong><br>    * 语法：<code>while ( Expression ) { ...body... }</code>。<br>    * <strong>先测试 (Pre-test):</strong> 在每次迭代 <em>之前</em> 检查 <code>Expression</code>。<br>    * 如果 <code>Expression</code> 为 <code>false</code>，循环体可能一次也不执行。</li>\n<li><strong><code>do-while</code> 循环 (直到型循环):</strong><br>    * 语法：<code>do { ...body... } while ( Expression );</code>。<br>    * <strong>后测试 (Post-test):</strong> 在每次迭代 <em>之后</em> 检查 <code>Expression</code>。<br>    * 循环体 <strong>至少执行一次</strong>。</li>\n<li><strong><code>for</code> 循环:</strong><br>    * 语法：<code>for ( initialization ; test_expression ; update ) { ...body... }</code>。<br>    * <code>initialization</code>：循环开始前执行一次（通常用于初始化循环变量）。<br>    * <code>test_expression</code>：每次迭代前检查，若为 <code>false</code> 则退出循环。<br>    * <code>update</code>：每次迭代 <em>之后</em> 执行（通常用于更新循环变量）。</li>\n<li><strong>循环控制:</strong><br>    * <strong><code>break</code>:</strong> 立即 <strong>跳出</strong> 并终止其所在的最内层循环（或 <code>switch</code>）。<br>    * <strong><code>continue</code>:</strong> 立即 <strong>跳过</strong> 当前迭代中剩余的语句，直接进入下一次循环的测试（对于 <code>for</code> 循环，会先执行 <code>update</code>）。<br>    * <strong><code>goto</code> 和 <code>label</code>:</strong><br>        * 提供从 <code>goto</code> 到同一函数内 <code>label</code> 的无条件跳转。<br>        * 不推荐使用，但可用于跳出深度嵌套的结构。</li>\n<li><strong>嵌套循环 (Nested Loop):</strong><br>    * 一个循环体内包含另一个循环。<br>    * <code>break</code> 或 <code>continue</code> 只影响最内层的循环。</li>\n</ul>\n<h2 id=\"第4章：函数与程序结构\"><a href=\"#第4章：函数与程序结构\" class=\"headerlink\" title=\"第4章：函数与程序结构\"></a>第4章：函数与程序结构</h2><h3 id=\"4-1-函数基础\"><a href=\"#4-1-函数基础\" class=\"headerlink\" title=\"4.1 函数基础\"></a>4.1 函数基础</h3><ul>\n<li><strong>函数 (Function):</strong> 用于实现特定功能的一段程序代码。</li>\n<li><strong>使用原因:</strong> 避免代码重复、使程序结构化、提高可读性。</li>\n<li><strong>函数声明 (Declaration &#x2F; Prototype):</strong><br>    * 告知编译器函数的返回类型、名称和参数类型。<br>    * 语法：<code>type function_name(type arg1, type arg2, ...);</code>。<br>    * 必须在使用函数前进行声明（通常放在 <code>main</code> 函数之前）。</li>\n<li><strong>函数定义 (Definition):</strong><br>    * 提供函数的具体实现（函数头 + 函数体）。<br>    * <strong>函数头 (Head):</strong> <code>type function_name(type arg1, type arg2, ...)</code>。<br>    * <strong>函数体 (Body):</strong> <code>{ ... your code ... }</code>。</li>\n<li><strong><code>return</code> 语句:</strong><br>    * 用于从函数返回一个值。<br>    * 函数最多只能返回 <strong>1个</strong> 值，该值的类型必须与声明的返回类型匹配。<br>    * <strong><code>void</code> 函数:</strong><br>        * 表示函数不返回值。<br>        * 可以使用 <code>return;</code> 语句立即退出函数。</li>\n<li><strong>函数调用 (Function Call):</strong><br>    * 通过函数名和参数列表来执行函数。<br>    * 程序控制权临时从调用函数转移到被调用函数。<br>    * 被调用函数执行完毕后，控制权返回到调用点。</li>\n</ul>\n<h3 id=\"4-2-参数传递\"><a href=\"#4-2-参数传递\" class=\"headerlink\" title=\"4.2 参数传递\"></a>4.2 参数传递</h3><ul>\n<li><strong>形参 (Parameter &#x2F; Formal Parameter):</strong> 在函数 <strong>定义</strong> 或声明中指定的变量。</li>\n<li><strong>实参 (Argument &#x2F; Actual Parameter):</strong> 在函数 <strong>调用</strong> 时传递给函数的具体值或变量。</li>\n<li><strong>传递方式:</strong><br>    1.  <strong>值传递 (Pass by Value):</strong><br>        * C语言的默认方式。<br>        * 将实参的 <strong>值复制</strong> 一份传递给形参。<br>        * 在函数内部修改形参 <strong>不会</strong> 影响到函数外部的实参。<br>    2.  <strong>地址&#x2F;指针传递 (Pass by Address):</strong><br>        * 将实参的 <strong>地址</strong> 传递给形参。<br>        * 形参必须是 <strong>指针类型</strong> (如 <code>int *x</code>)。<br>        * 实参必须是地址（如 <code>&amp;a</code>）。<br>        * 在函数内部通过指针修改形参所指向的内存，<strong>会</strong> 影响到函数外部的实参。<br>    3.  <strong>引用传递 (Pass by Reference):</strong><br>        * 这是 C++ 的特性，<strong>C语言不支持</strong>。<br>        * 形参是实参的别名（如 <code>int &amp;x</code>）。</li>\n</ul>\n<h3 id=\"4-3-作用域、生命周期与存储类型\"><a href=\"#4-3-作用域、生命周期与存储类型\" class=\"headerlink\" title=\"4.3 作用域、生命周期与存储类型\"></a>4.3 作用域、生命周期与存储类型</h3><ul>\n<li><strong>作用域 (Scope):</strong> 标识符（变量或函数名）在程序中可以被合法使用的区域。<br>    * <strong>局部作用域 (Local Scope):</strong> 标识符在块（<code>{}</code>内）或函数内部声明，其作用域从声明点到块或函数结束。<br>    * <strong>全局作用域 (Global Scope):</strong> 标识符在所有函数之外声明，其作用域从声明点到文件结尾。<br>    * <strong>名称优先级:</strong> 局部变量会“隐藏”同名的全局变量。</li>\n<li><strong>生命周期 (Lifetime):</strong> 程序执行期间，标识符实际拥有内存分配的时间。</li>\n<li><strong>存储类型:</strong><br>    * <strong>自动变量 (Automatic):</strong><br>        * 默认的局部变量存储类型（可省略 <code>auto</code> 关键字）。<br>        * 存储在 <strong>栈</strong> 中。<br>        * <strong>生命周期:</strong> 函数调用时创建，函数退出时销毁。<br>        * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。<br>    * <strong>外部变量 (External):</strong><br>        * 即全局变量，定义在所有函数之外。<br>        * 使用 <code>extern</code> 关键字在其他文件中 <strong>声明</strong> （非定义），表示引用一个已在别处定义的全局变量。<br>        * <strong>生命周期:</strong> 整个程序运行期间。<br>        * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>    * <strong>静态变量 (Static):</strong><br>        * 使用 <code>static</code> 关键字声明。<br>        * <strong>静态全局变量:</strong> 作用域被限制在声明它的文件内部，其他文件不可访问。<br>        * <strong>静态局部变量:</strong><br>            * 作用域仍是局部的（函数内）。<br>            * <strong>生命周期:</strong> 整个程序运行期间。<br>            * 只在 <strong>第一次</strong> 调用函数时初始化一次。<br>            * 在函数多次调用之间 <strong>保持其值</strong>。<br>        * <strong>初始化:</strong> 若不显式初始化，<strong>默认为 0</strong>。<br>    * <strong>寄存器变量 (Register):</strong><br>        * 使用 <code>register</code> 关键字，建议编译器将变量存储在CPU寄存器中以提高效率。<br>        * <strong>初始化:</strong> 若不显式初始化，其值为未定义的（垃圾值）。</li>\n</ul>\n<h3 id=\"4-4-递归\"><a href=\"#4-4-递归\" class=\"headerlink\" title=\"4.4 递归\"></a>4.4 递归</h3><ul>\n<li><strong>递归 (Recursion):</strong> 一个函数调用其自身的过程。</li>\n<li><strong>递归的两个要素:</strong><br>    1.  <strong>基本情况 (Base Case):</strong> 递归的停止条件，一个无需递归即可解决的简单情况。<br>    2.  <strong>递归步骤 (Recursive Step):</strong> 将问题分解为更小的、同类的问题，并通过递归调用来解决。</li>\n<li><strong>递归 vs. 迭代 (Iteration):</strong><br>    * 任何递归都可以用迭代（循环）和栈来代替。<br>    * 迭代（循环）在执行速度和空间占用上通常 <strong>优于</strong> 递归。</li>\n</ul>\n<h3 id=\"4-5-C预处理器\"><a href=\"#4-5-C预处理器\" class=\"headerlink\" title=\"4.5 C预处理器\"></a>4.5 C预处理器</h3><ul>\n<li>在编译之前对源代码进行处理的程序。</li>\n<li><strong>文件包含 (<code>#include</code>):</strong><br>    * <code>#include &lt;filename&gt;</code>: 在标准库目录或系统路径中查找文件。<br>    * <code>#include &quot;filename&quot;</code>: 从源程序当前目录开始搜索（通常用于自定义头文件）。</li>\n<li><strong>宏替换 (<code>#define</code>):</strong><br>    * 定义一个宏（一个名称和一段替换文本）。<br>    * 预处理器会在编译前进行 <strong>原样文本替换</strong>。<br>    * <strong>带参数的宏:</strong> <code>define max(A,B) ((A) &gt; (B) ? (A) : (B))</code>。<br>    * <strong>宏的陷阱:</strong><br>        * 宏是纯文本替换，要注意运算符优先级，因此宏定义中应多用括号。<br>        * 注意带副作用的参数，如 <code>max(i++, j++)</code>，会导致 <code>i</code> 或 <code>j</code> 被自增多次。</li>\n<li><strong>条件包含 (<code>#if</code>…):</strong><br>    * 允许根据预处理时的条件来选择性地编译某段代码。<br>    * 指令包括：<code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>。<br>    * <code>#ifndef</code>: “if not defined”，常用于防止头文件被重复包含。</li>\n</ul>\n<h2 id=\"第5章：数组\"><a href=\"#第5章：数组\" class=\"headerlink\" title=\"第5章：数组\"></a>第5章：数组</h2><h3 id=\"5-1-一维数组\"><a href=\"#5-1-一维数组\" class=\"headerlink\" title=\"5.1 一维数组\"></a>5.1 一维数组</h3><ul>\n<li><strong>数组 (Array):</strong> 存储 <strong>相同数据类型</strong> 的元素的集合，这些元素在内存中 <strong>连续存放</strong>。</li>\n<li><strong>数组声明:</strong><br>    * 语法：<code>DataType ArrayName [ConstIntExpression];</code>。<br>    * <code>ConstIntExpression</code> 必须是 <strong>常量表达式</strong>，指定数组的大小（元素个数）。<br>    * 数组大小一旦固定，不可更改。</li>\n<li><strong>数组元素访问:</strong><br>    * 通过 <strong>下标 (Index &#x2F; Subscript)</strong> 访问，下标从 <strong>0</strong> 开始。<br>    * <code>temps[0]</code> 是第一个元素，<code>temps[4]</code> 是第五个元素（对于大小为5的数组）。</li>\n<li><strong>数组名:</strong><br>    * 数组名（如 <code>temps</code>）本身是一个 <strong>指针</strong>，其值是数组的 <strong>基地址</strong>（即第一个元素 <code>temps[0]</code> 的内存地址）。</li>\n<li><strong>数组初始化:</strong><br>    * 可以在声明时初始化：<code>int ages[5] = {40, 13, 20, 19, 36};</code>。<br>    * 可以省略大小，编译器会自动计算：<code>int ages[] = {40, 13, 20};</code>。<br>    * <strong>部分初始化:</strong> <code>int a[5] = { 2 };</code> 第一个元素为2，其余所有元素自动初始化为 0。</li>\n<li><strong>数组的限制:</strong><br>    * <strong>无边界检查 (No Bound Checking):</strong> C语言不检查数组下标是否越界。访问 <code>myList[-1]</code> 或 <code>myList[11]</code>（假设大小为4）不会产生编译错误，但会导致运行时错误或未定义行为。<br>    * <strong>无聚合操作 (No Aggregate Operations):</strong> 不能将一个数组整体赋值给另一个数组（如 <code>x = y;</code> 是错误的）。<br>    * 数组复制必须通过循环逐个元素进行。</li>\n</ul>\n<h3 id=\"5-2-数组与函数\"><a href=\"#5-2-数组与函数\" class=\"headerlink\" title=\"5.2 数组与函数\"></a>5.2 数组与函数</h3><ul>\n<li><strong>数组作为函数参数:</strong><br>    * 当数组作为参数传递时，传递的是数组的 <strong>基地址</strong>。<br>    * 因此，函数参数传递总是 <strong>地址传递</strong>。<br>    * 在函数内部对形参数组的修改 <strong>会</strong> 影响到主调函数中的实参数组。<br>    * 通常需要传递两个参数：数组的基地址（数组名）和数组中要处理的元素个数（大小）。</li>\n<li><strong>形参声明:</strong><br>    * <code>float FindMax(float arr[], int n)</code><br>    * <code>float FindMax(float *arr, int n)</code> (等价)</li>\n<li><strong><code>const</code> 保护数组参数:</strong><br>    * 如果不希望函数修改数组内容，应在形参声明中使用 <code>const</code> 关键字。<br>    * 示例：<code>float FindMax(const float arr[], int n)</code>。</li>\n</ul>\n<h3 id=\"5-3-数组算法：排序与搜索\"><a href=\"#5-3-数组算法：排序与搜索\" class=\"headerlink\" title=\"5.3 数组算法：排序与搜索\"></a>5.3 数组算法：排序与搜索</h3><ul>\n<li><strong>选择排序 (Selection Sort):</strong><br>    * <strong>算法思想:</strong><br>        1.  从头（<code>passCount = 0</code>）开始。<br>        2.  在 <code>data[passCount ... length-1]</code> 范围内找到 <strong>最小</strong> 元素的索引 <code>minIndx</code>。<br>        3.  将 <code>data[minIndx]</code> 与 <code>data[passCount]</code> 交换。<br>        4.  <code>passCount</code> 增加1，重复该过程，直到 <code>passCount</code> 达到 <code>length - 2</code>。</li>\n<li><strong>线性搜索 (Linear &#x2F; Sequential Search):</strong><br>    * 适用于 <strong>未排序</strong> 的数组。<br>    * 从头到尾（<code>i=0</code> 到 <code>n-1</code>）逐个检查元素，看是否等于目标值 <code>x</code>。<br>    * 找到则返回索引 <code>i</code>，遍历完未找到则返回 <code>-1</code>。</li>\n<li><strong>二分搜索 (Binary Search):</strong><br>  C* <strong>必须</strong> 适用于 <strong>已排序</strong> 的数组。<br>    * <strong>算法思想:</strong><br>        1.  设 <code>first = 0</code>, <code>last = arraySize - 1</code>。<br>        2.  当 <code>last &gt;= first</code> 时循环：<br>        3.  计算中间索引 <code>mid = (first + last) / 2</code>。<br>        4.  如果 <code>key == list[mid]</code>，则找到，返回 <code>mid</code>。<br>        5.  如果 <code>key &lt; list[mid]</code>，则目标在左半边，令 <code>last = mid - 1</code>。<br>        6.  如果 <code>key &gt; list[mid]</code>，则目标在右半边，令 <code>first = mid + 1</code>。<br>        7.  循环结束仍未找到，返回 <code>-1</code>。</li>\n</ul>\n<h3 id=\"5-4-多维数组\"><a href=\"#5-4-多维数组\" class=\"headerlink\" title=\"5.4 多维数组\"></a>5.4 多维数组</h3><ul>\n<li><strong>二维数组 (Two-Dimensional Array):</strong><br>    * 按行和列组织的同类型元素集合。<br>    * <strong>声明:</strong> <code>DataType ArrayName [Rows] [Cols];</code>。<br>    * <strong>访问:</strong> <code>stateHighs[2][7]</code> (访问第3行第8列的元素)。<br>    * <strong>内存存储:</strong> 在内存中按 <strong>行优先 (Row Order)</strong> 连续存储（第一行所有元素，接着是第二行所有元素…）。</li>\n<li><strong>多维数组作为函数参数:</strong><br>    * 传递的仍然是基地址。<br>    * <strong>必须</strong> 指定 <strong>除第一维之外</strong> 的所有维度的大小。<br>    * 示例：<code>void FindAverages(const int stateHighs[][NUM_MONTHS], ...)</code>。</li>\n<li><strong><code>typedef</code> 与数组:</strong><br>    * 可以使用 <code>typedef</code> 来定义数组类型，使函数原型更简洁明了。<br>    * 示例：<code>typedef int SalesType[3][12][5];</code> <code>SalesType sales;</code>。</li>\n</ul>\n"},{"title":"高精度&排序","date":"2025-11-05T07:28:03.000Z","cover":"/images/oi_cover.jpg","_content":"## 高精度\n在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。\n\n高精度加法比较简单，将数组反转处理，将进位临时储存，*需注意算法结束后还要验证最后进位是否为0*。\n\n---\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nstring add(string a, string b)\n{\n    int len = max(a.size(), b.size()), jw = 0;\n    string c = \"\";\n    while (a.size() < len) a = '0' + a;\n    while (b.size() < len) b = '0' + b;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        int t1 = a[i] - '0', t2 = b[i] - '0';\n        int t = t1 + t2 + jw;\n        jw = t / 10;\n        t %= 10;\n        char ch = t + '0';\n        c = ch + c;\n    }\n    if (jw != 0) return '1' + c;\n    return c;\n}\nsigned main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tcout << add(s1, s2);\n    return 0;\n}\n```\n\n---\n发现自己高精度乘法解释不清楚，这个[高精度乘法](https://www.luogu.com.cn/article/pxfpoeoi)题解写的很好，可以参考下。\n\n---\n然后我发现[p1009](https://www.luogu.com.cn/problem/P1009)不会做。  \n不是这高精算法怎么这么智障。  \n~~于是我决定跳过，之后再看。~~  \n还是看完了，其实并不难，题解写的很傻逼。\n需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n//高精度加法s1 s2 result均为倒叙储存\nvector<int> add(vector<int> &s1,vector<int> &s2)\n{\n    vector<int> c;\n    int len = max(s1.size(),s2.size());\n    int temp=0;\n    for (int i=0;i<len;i++)\n    {\n        int a,b;\n        a=(i<s1.size())?s1[i] : 0;\n        b=(i<s2.size())?s2[i] : 0;\n        c.push_back((a+b+temp)%10);\n        temp=(a+b+temp)/10;\n    }\n    if (temp>0) c.push_back(temp);\n    return c;\n}\n//高精度乘以低精度乘法\nvector<int> mul(vector<int>& a, int b) {\n    vector<int> c;\n    int temp = 0;\n    for (int i = 0; i < a.size(); i++) {\n        temp += a[i] * b;      \n        c.push_back(temp % 10); \n        temp /= 10;            \n    }\n    while (temp) {\n        c.push_back(temp % 10);\n        temp /= 10;\n    }\n    if (c.empty()) {\n        c.push_back(0);\n    }\n    return c;\n}\n\n//主函数调用\nint main ()\n{\n    int n;\n    cin>>n;\n    vector<int> sum = {0}; \n    vector<int> term = {1};\n    for(int i=1;i<=n;i++)\n    {\n        term = mul(term,i);\n        sum = add(sum,term);\n    }\n    for (int i = sum.size() - 1; i >= 0; i--) {\n        cout << sum[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n第一版代码编译错误。  \n***我是不是有病***  \n错误在s1.[i]，和结构体搞混了。  \n改好了就过了\n\n\n好我们开始学习排序；\n\n---\n\n## 排序\n\n### 计数排序\n\n[P1271 【深基9.例1】选举学生会](https://www.luogu.com.cn/problem/P1271)，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  \n\n计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  \n\n~~比较简单，且时间复杂度很高，感觉没什么用，下一个。~~  \n\n[oiwiki](https://oi-wiki.org/basic/counting-sort/)上写了要计算前缀和，我并不太理解，接下来是gemini的解释：\n\n---\n> 这是一个非常好的问题！“前缀和”这一步是计数排序**从一个简单的“计数”算法变成一个强大的“排序”算法**的关键。\n>\n> 简单来说，前缀和的核心作用是：**把“计数”转变为“最终位置”**。\n>\n> 它解决了两个问题：\n> 1.  **定位问题**：知道有3个“5”，但我该把它们放在输出数组的哪个**具体索引**上？\n> 2.  **稳定性问题**：如果原始数组中有两个“5”（比如一个是 `(5, 'a')`，一个是 `(5, 'b')`），如何保证排序后它们的相对顺序不变？\n>\n> ### 1. 如果没有前缀和（朴素想法）\n>\n> 我们先看看，如果**只有**第一步“计算每个数出现了几次”，我们会怎么做。\n>\n> 假设待排序数组 `A = {1, 4, 1, 2, 4, 3, 1}`\n>\n> **步骤 1：计数**\n> 我们得到一个“计数数组” `C`：\n> * `C[1] = 3` (有 3 个 '1')\n> * `C[2] = 1` (有 1 个 '2')\n> * `C[3] = 1` (有 1 个 '3')\n> * `C[4] = 2` (有 2 个 '4')\n>\n> **朴素的“排序”：**\n> 我们可以遍历 `C` 数组，然后直接重写 `A`：\n> * 看到 `C[1] = 3`，就在 `A` 里写 3 个 '1'：`A = {1, 1, 1, ...}`\n> * 看到 `C[2] = 1`，接着写 1 个 '2'：`A = {1, 1, 1, 2, ...}`\n> * ...\n> * 最终得到 `A = {1, 1, 1, 2, 3, 4, 4}`\n>\n> **问题所在：**\n> 这确实排序了。但是，如果我们的 `A` 数组存的不是简单的数字，而是**对象**呢？\n> 比如 `A = {(1, 'a'), (4, 'b'), (1, 'c'), (4, 'd'), (1, 'e')}`\n> 我们的 `C` 数组还是一样：`C[1]=3`，`C[4]=2`。\n> 如果用朴素方法，我们只会得到 `{1, 1, 1, 4, 4}`。我们完全**丢失了 'a', 'b', 'c', 'd', 'e' 这些附加信息**。\n>\n> 我们需要的不是“覆盖”原数组，而是把原数组中的**每一个元素**，**“搬运”** 到一个新数组（或最终位置）的正确索引上。\n>\n> ### 2. 前缀和的作用：计算“位置边界”\n>\n> 前缀和就是用来计算这个“搬运”目标的。\n>\n> 我们换一个例子：`A = {2, 5, 3, 0, 2, 3, 0, 3}`\n>\n> **步骤 1：计数**\n> `C` 数组 (索引 0 到 5):\n> * `C[0] = 2` (2 个 '0')\n> * `C[1] = 0` (0 个 '1')\n> * `C[2] = 2` (2 个 '2')\n> * `C[3] = 3` (3 个 '3')\n> * `C[4] = 0` (0 个 '4')\n> * `C[5] = 1` (1 个 '5')\n> * 数组 `C`：`{2, 0, 2, 3, 0, 1}`\n>\n> **步骤 2：计算前缀和**\n> 我们对 `C` 数组进行累加：\n> * `C[0] = 2`\n> * `C[1] = C[1] + C[0] = 0 + 2 = 2`\n> * `C[2] = C[2] + C[1] = 2 + 2 = 4`\n> * `C[3] = C[3] + C[2] = 3 + 4 = 7`\n> * `C[4] = C[4] + C[3] = 0 + 7 = 7`\n> * `C[5] = C[5] + C[4] = 1 + 7 = 8`\n> * 数组 `C`（前缀和）：`{2, 2, 4, 7, 7, 8}`\n>\n> **现在，这个前缀和数组 `C` 的含义**变得非常重要：\n> `C[i]` 的值 = 原始数组中 **小于或等于 `i`** 的元素总个数。\n>\n> * `C[0] = 2`：有 2 个元素 $\\le 0$。\n> * `C[2] = 4`：有 4 个元素 $\\le 2$ (即 '0' 和 '2')。\n> * `C[3] = 7`：有 7 个元素 $\\le 3$ (即 '0', '2' 和 '3')。\n> * `C[5] = 8`：有 8 个元素 $\\le 5$ (即所有元素)。\n>\n> **这就是关键点！**\n> > 如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 '2' 应该放在**第 4 位**。\n> >\n> > 如果有 7 个元素小于或等于 3，那么最后一个 '3' 应该放在**第 7 位**。\n>\n> **`C[i]` 现在直接告诉了我们：值 `i` 的元素在排序后，最后一个应该放的“坑位”是第 `C[i]` 个。**\n>\n> ### 3. 步骤 3：利用前缀和（从后往前）放置元素\n>\n> 我们准备一个和 `A` 一样大的空数组 `B` (大小为 8)。\n> 我们**从右至左**（从后往前）遍历原始数组 `A`。\n>\n> `A = {2, 5, 3, 0, 2, 3, 0, 3}`\n> `C = {2, 2, 4, 7, 7, 8}` (前缀和)\n> `B = {_, _, _, _, _, _, _, _}`\n>\n> 1.  **遍历 `A[7] = 3`**\n>     * 查找 `C[3]`，值为 `7`。\n>     * 这告诉我们：'3' 应该放在第 7 个位置（即 0-based 索引的 `7-1 = 6`）。\n>     * `B[6] = 3`。\n>     * **重要**：我们用掉了一个 '3' 的位置，所以 `C[3]` 减 1。`C[3]` 变为 `6`。\n>     * `B`：`{_, _, _, _, _, _, 3, _}`\n>\n> 2.  **遍历 `A[6] = 0`**\n>     * 查找 `C[0]`，值为 `2`。\n>     * 位置：`2-1 = 1`。\n>     * `B[1] = 0`。\n>     * `C[0]` 减 1，变为 `1`。\n>     * `B`：`{_, 0, _, _, _, _, 3, _}`\n>\n> 3.  **遍历 `A[5] = 3`** (这是第二个 '3')\n>     * 查找 `C[3]`，值现在是 `6` (上次用过 '3' 后减 1 了)。\n>     * 位置：`6-1 = 5`。\n>     * `B[5] = 3`。\n>     * `C[3]` 减 1，变为 `5`。\n>     * `B`：`{_, 0, _, _, _, 3, 3, _}`\n>\n> 4.  **遍历 `A[4] = 2`**\n>     * 查找 `C[2]`，值为 `4`。\n>     * 位置：`4-1 = 3`。\n>     * `B[3] = 2`。\n>     * `C[2]` 减 1，变为 `3`。\n>     * `B`：`{_, 0, _, 2, _, 3, 3, _}`\n>\n> ... 以此类推，直到 `A[0]`。\n>\n> 5.  **遍历 `A[2] = 3`** (这是第一个 '3')\n>     * 查找 `C[3]`，值现在是 `5`。\n>     * 位置：`5-1 = 4`。\n>     * `B[4] = 3`。\n>     * `C[3]` 减 1，变为 `4`。\n>     * `B`：`{_, 0, _, 2, 3, 3, 3, _}`\n>\n> 最后我们会得到 `B = {0, 0, 2, 2, 3, 3, 3, 5}`，排序完成。\n>\n> ### 总结\n>\n> 前缀和是计数排序的灵魂，它完成了两个核心任务：\n>\n> 1.  **精确**\n>     **定位**：`C[i]` 从“`i` 的个数”转变成了“小于等于 `i` 的总数”，这个总数**直接映射**到了排序后数组的**索引（位置）**。\n> 2.  **保证稳定性**：通过**从后往前**遍历原数组 `A`，并结合 `C[i]--` 操作，我们确保了：\n>     * 原数组中**靠后**的重复元素，会先被放入新数组中**靠后**的“坑位”。\n>     * 原数组中**靠前**的重复元素，会后被放入新数组中**靠前**的“坑位”。\n>     * 从而保持了它们的相对顺序不变（即“稳定性”）。\n---\n我理解了什么意思了，但是怎么这么繁琐。。。  \n我可能之后还是不记得这个**前缀和**怎么用，不过至少了解了，先写个代码熟悉一下。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> count_sort(vector<int> &s1,int n)//需要输入的数组，里面的最大数（默认从0开始排序）\n{   \n    vector<int> c (n+1,0);//初始化计数数组；\n    //遍历计数\n    int leng=s1.size();\n    for (int i=0;i<leng;i++) c[s1[i]]++;\n    //计算前缀和；\n    for (int i=1;i<n+1;i++) c[i]+=c[i-1];\n    //将c数组里的每一个数替换成前缀和\n    \n    //定义输出数组\n    vector<int> result(leng);\n    //利用前缀和（从后往前）放置元素\n    for (int i = leng-1;i>=0;--i)\n    {\n        int num = s1[i];//查找第i元素\n        int postion=c[num]-1;//查找这个元素应该放在第几个位置\n        /*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个\n        那么这个数减一就是应该放在结果数组的位置\n        */\n        result[postion]=num;\n        c[num]--;//用掉了一个数，应该减一\n\n    }\n    return result;\n\n}\n```\n\n\n### 选择排序\n\n[oi wiki的选择排序](https://oi-wiki.org/basic/selection-sort/)解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  \n\n```cpp\n#include <utility>\n\nvoid selection_sort(int* a, int n) {\n  for (int i = 1; i < n; ++i) {\n    int ith = i;\n    for (int j = i + 1; j <= n; ++j) {\n      if (a[j] < a[ith]) {\n        ith = j;\n      }\n    }\n    std::swap(a[i], a[ith]);\n  }\n}\n```\n如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。\n本质上是打擂台，找到最小的数字，排在最前面。\n\n### 冒泡排序\n这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。  \n当不再发生交换的时候，排序完成。 \n```cpp\nvoid bubble_sort (int *a,int n)\n{\n    bool switched = true;//switched表示上一轮是否交换\n    /*这是个断终止的方法，只要上一轮没有交换说明排序结束*/\n    while (switched)\n    {\n        switched = false;\n        for(int i=0;i<n-1;++i)//注意数组越界问题，应当要再减一\n        {\n            if (a[i] > a[i + 1]) \n            {\n                switched = true;\n                swap(a[i],a[i+1]);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。\n>可数组的插入不是很复杂的吗？？\n\n代码实现如下\n\n```cpp\nvoid insertion_sort(int arr[], int len) {\n  for (int i = 1; i < len; ++i) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n}\n```\n这是gemini的解释，我觉得很形象\n\n---\n> 它的核心思想是模拟我们**玩扑克牌时整理手牌**的动作。\n>\n> ### 🃏 插入排序的核心比喻 (整理手牌)\n>\n> 想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（`key`）。\n>\n> 你会怎么做？\n>\n> 1.  你从左手中**最右边**的牌（`j`）开始，和你的新牌（`key`）比较。\n> 2.  如果左手的牌（`arr[j]`）比你的新牌（`key`）大，你就把这张牌**往右移一个位置**（`arr[j + 1] = arr[j]`），腾出它原来的空位。\n> 3.  你继续看左手边下一张牌（`j--`），重复这个比较。\n> 4.  直到你找到一张比新牌（`key`）小的牌，或者你已经比较完了所有手里的牌 ( `j < 0` )。\n> 5.  这时，你找到了正确的位置，把你手里的新牌（`key`）**插入**到刚刚腾出来的那个空位上（`arr[j + 1] = key`）。\n---\n如果基本有序，就可以使用这个插入算法。  \n\n>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。\n\n***至少下一个排序很有用***\n\n## 快速排序\n[洛谷P1177](https://www.luogu.com.cn/problem/P1177)就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  \n\n不行了这个gemini讲的太好了,我直接复制就行\n\n---\n\n\n您可以把快速排序想象成一个“**不断找人站队**”的过程。\n\n\n### 快速排序的核心思想\n\n正如您资料中提到的，它的核心是 **“分治”（Divide and Conquer）**。\n\n简单来说，就是：\n\n1.  **找一个“基准” (Pivot)：** 在队伍里（数组中）随便挑一个人（一个数）当“基准”。\n2.  **站队 (Partition)：** 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。\n3.  **分而治之 (Recurse)：** 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别**重复**第1步和第2步。\n4.  **完成：** 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。\n\n-----\n\n### 详细解释您提供的 C++ 代码\n\n您提供的代码是实现这个过程的经典方法。我们一步一步来看：\n\n#### 1\\. `Partition` 函数（最关键的“站队”过程）\n\n这个函数的目标是：**选定一个基准，并完成“站队”**。\n\n```c++\ntemplate <typename T>\nint Partition(T A[], int low, int high) {//这里low是排序的第一个指针， high是最后一个指针\n  int pivot = A[low]; // 1. 选择基准：就选第一个元素当基准 (pivot)\n                      //    此时 A[low] 这个位置可以看成一个“坑”\n\n  while (low < high) { // 2. 只要左右指针没相遇，就继续\n    \n    // 3. 从右往左找“小”的\n    while (low < high && pivot <= A[high]) --high; \n    A[low] = A[high]; // 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”\n\n    // 5. 从左往右找“大”的\n    while (low < high && A[low] <= pivot) ++low; \n    A[high] = A[low]; // 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”\n  }\n  \n  // 7. 循环结束，low 和 high 相遇了\n  A[low] = pivot; // 8. 把一开始存的基准值，放回这个最后的“坑”\n  return low;     // 9. 返回基准最后站的位置\n}\n```\n\n**用一个例子来模拟 `Partition`：**\n假设数组是 `[5, 2, 8, 1, 9, 4]`，`low = 0`, `high = 5`。\n\n1.  `pivot = A[low]`，`pivot` 存了 **5**。 `A[0]` 现在是“坑”。\n    数组：`[坑, 2, 8, 1, 9, 4]`\n2.  **从右往左**（`high` 从 5 开始）找比 5 小的。\n      * `A[5]` 是 4。比 5 小。\n3.  把 4 扔到左边的“坑” (`A[low]` 即 `A[0]`)。`A[5]` 变成新“坑”。\n    数组：`[4, 2, 8, 1, 9, 坑]`\n4.  **从左往右**（`low` 从 0 开始）找比 5 大的。\n      * `A[0]` 是 4。\n      * `A[1]` 是 2。\n      * `A[2]` 是 8。比 5 大。\n5.  把 8 扔到右边的“坑” (`A[high]` 即 `A[5]`)。`A[2]` 变成新“坑”。\n    数组：`[4, 2, 坑, 1, 9, 8]`\n6.  **从右往左**（`high` 从 5 开始）...\n      * ... `A[4]` 是 9。\n      * `A[3]` 是 1。比 5 小。\n7.  把 1 扔到左边的“坑” (`A[low]` 即 `A[2]`)。`A[3]` 变成新“坑”。\n    数组：`[4, 2, 1, 坑, 9, 8]`\n8.  **从左往右**（`low` 从 2 开始）...\n      * `A[2]` 是 1。\n      * `A[3]`... `low` 和 `high` 在 3 这个位置相遇了。循环 `while (low < high)` 结束。\n9.  把 `pivot` (存的 **5**) 放到 `A[low]` (即 `A[3]`)。\n    数组：`[4, 2, 1, 5, 9, 8]`\n10. 返回 `low` (即 3)。\n\n**看，现在数组变成了 `[4, 2, 1]` （都比5小） | `5` | `[9, 8]` （都比5大）。** 这就是“站队”！\n\n-----\n\n#### 2\\. `QuickSort` 函数（“分而治之”的递归）\n\n这个函数是“分治”思想的体现，它来“指挥”`Partition`。\n\n```c++\ntemplate <typename T>\nvoid QuickSort(T A[], int low, int high) {\n  if (low < high) { // 如果队伍里至少有2个人\n    // 1. 先站队，并拿到基准最后的位置\n    int pivot_pos = Partition(A, low, high); \n    \n    // 2. 指挥“左队”去递归排序\n    QuickSort(A, low, pivot_pos - 1); \n    \n    // 3. 指挥“右队”去递归排序\n    QuickSort(A, pivot + 1, high); \n  }\n  // 如果 low >= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。\n}\n```\n\n### 总结\n\n1.  `QuickSort` 函数是**宏观管理者**：它负责“分”，决定对哪一段（从 `low` 到 `high`）进行排序。\n2.  `Partition` 函数是**具体执行者**：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。\n3.  通过**递归**，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。\n\n您提供的资料中提到“不用合并”，就是因为 `Partition` 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。\n\n---\n后面还有[优化算法](https://oi-wiki.org/basic/quick-sort/)，我真不想看了，之后有空再看。\n\n## 归并排序\n我草怎么还有。。。\n直接放[归并](https://oi-wiki.org/basic/merge-sort/)的链接吧\n\n\n## 总结\n其实还有sort函数，要写一个函数作为排序的算法。  \n我感觉我这样学习效率很低，应该做题，不会的再去查概念。  \n先去吃个饭，等下学递归的时候改一下学习方法。","source":"_posts/paixu1.md","raw":"---\ntitle: 高精度&排序\ndate: 2025-11-05 15:28:03\ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n## 高精度\n在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。\n\n高精度加法比较简单，将数组反转处理，将进位临时储存，*需注意算法结束后还要验证最后进位是否为0*。\n\n---\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nstring add(string a, string b)\n{\n    int len = max(a.size(), b.size()), jw = 0;\n    string c = \"\";\n    while (a.size() < len) a = '0' + a;\n    while (b.size() < len) b = '0' + b;\n    for (int i = len - 1; i >= 0; i--)\n    {\n        int t1 = a[i] - '0', t2 = b[i] - '0';\n        int t = t1 + t2 + jw;\n        jw = t / 10;\n        t %= 10;\n        char ch = t + '0';\n        c = ch + c;\n    }\n    if (jw != 0) return '1' + c;\n    return c;\n}\nsigned main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tcout << add(s1, s2);\n    return 0;\n}\n```\n\n---\n发现自己高精度乘法解释不清楚，这个[高精度乘法](https://www.luogu.com.cn/article/pxfpoeoi)题解写的很好，可以参考下。\n\n---\n然后我发现[p1009](https://www.luogu.com.cn/problem/P1009)不会做。  \n不是这高精算法怎么这么智障。  \n~~于是我决定跳过，之后再看。~~  \n还是看完了，其实并不难，题解写的很傻逼。\n需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n//高精度加法s1 s2 result均为倒叙储存\nvector<int> add(vector<int> &s1,vector<int> &s2)\n{\n    vector<int> c;\n    int len = max(s1.size(),s2.size());\n    int temp=0;\n    for (int i=0;i<len;i++)\n    {\n        int a,b;\n        a=(i<s1.size())?s1[i] : 0;\n        b=(i<s2.size())?s2[i] : 0;\n        c.push_back((a+b+temp)%10);\n        temp=(a+b+temp)/10;\n    }\n    if (temp>0) c.push_back(temp);\n    return c;\n}\n//高精度乘以低精度乘法\nvector<int> mul(vector<int>& a, int b) {\n    vector<int> c;\n    int temp = 0;\n    for (int i = 0; i < a.size(); i++) {\n        temp += a[i] * b;      \n        c.push_back(temp % 10); \n        temp /= 10;            \n    }\n    while (temp) {\n        c.push_back(temp % 10);\n        temp /= 10;\n    }\n    if (c.empty()) {\n        c.push_back(0);\n    }\n    return c;\n}\n\n//主函数调用\nint main ()\n{\n    int n;\n    cin>>n;\n    vector<int> sum = {0}; \n    vector<int> term = {1};\n    for(int i=1;i<=n;i++)\n    {\n        term = mul(term,i);\n        sum = add(sum,term);\n    }\n    for (int i = sum.size() - 1; i >= 0; i--) {\n        cout << sum[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n第一版代码编译错误。  \n***我是不是有病***  \n错误在s1.[i]，和结构体搞混了。  \n改好了就过了\n\n\n好我们开始学习排序；\n\n---\n\n## 排序\n\n### 计数排序\n\n[P1271 【深基9.例1】选举学生会](https://www.luogu.com.cn/problem/P1271)，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  \n\n计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  \n\n~~比较简单，且时间复杂度很高，感觉没什么用，下一个。~~  \n\n[oiwiki](https://oi-wiki.org/basic/counting-sort/)上写了要计算前缀和，我并不太理解，接下来是gemini的解释：\n\n---\n> 这是一个非常好的问题！“前缀和”这一步是计数排序**从一个简单的“计数”算法变成一个强大的“排序”算法**的关键。\n>\n> 简单来说，前缀和的核心作用是：**把“计数”转变为“最终位置”**。\n>\n> 它解决了两个问题：\n> 1.  **定位问题**：知道有3个“5”，但我该把它们放在输出数组的哪个**具体索引**上？\n> 2.  **稳定性问题**：如果原始数组中有两个“5”（比如一个是 `(5, 'a')`，一个是 `(5, 'b')`），如何保证排序后它们的相对顺序不变？\n>\n> ### 1. 如果没有前缀和（朴素想法）\n>\n> 我们先看看，如果**只有**第一步“计算每个数出现了几次”，我们会怎么做。\n>\n> 假设待排序数组 `A = {1, 4, 1, 2, 4, 3, 1}`\n>\n> **步骤 1：计数**\n> 我们得到一个“计数数组” `C`：\n> * `C[1] = 3` (有 3 个 '1')\n> * `C[2] = 1` (有 1 个 '2')\n> * `C[3] = 1` (有 1 个 '3')\n> * `C[4] = 2` (有 2 个 '4')\n>\n> **朴素的“排序”：**\n> 我们可以遍历 `C` 数组，然后直接重写 `A`：\n> * 看到 `C[1] = 3`，就在 `A` 里写 3 个 '1'：`A = {1, 1, 1, ...}`\n> * 看到 `C[2] = 1`，接着写 1 个 '2'：`A = {1, 1, 1, 2, ...}`\n> * ...\n> * 最终得到 `A = {1, 1, 1, 2, 3, 4, 4}`\n>\n> **问题所在：**\n> 这确实排序了。但是，如果我们的 `A` 数组存的不是简单的数字，而是**对象**呢？\n> 比如 `A = {(1, 'a'), (4, 'b'), (1, 'c'), (4, 'd'), (1, 'e')}`\n> 我们的 `C` 数组还是一样：`C[1]=3`，`C[4]=2`。\n> 如果用朴素方法，我们只会得到 `{1, 1, 1, 4, 4}`。我们完全**丢失了 'a', 'b', 'c', 'd', 'e' 这些附加信息**。\n>\n> 我们需要的不是“覆盖”原数组，而是把原数组中的**每一个元素**，**“搬运”** 到一个新数组（或最终位置）的正确索引上。\n>\n> ### 2. 前缀和的作用：计算“位置边界”\n>\n> 前缀和就是用来计算这个“搬运”目标的。\n>\n> 我们换一个例子：`A = {2, 5, 3, 0, 2, 3, 0, 3}`\n>\n> **步骤 1：计数**\n> `C` 数组 (索引 0 到 5):\n> * `C[0] = 2` (2 个 '0')\n> * `C[1] = 0` (0 个 '1')\n> * `C[2] = 2` (2 个 '2')\n> * `C[3] = 3` (3 个 '3')\n> * `C[4] = 0` (0 个 '4')\n> * `C[5] = 1` (1 个 '5')\n> * 数组 `C`：`{2, 0, 2, 3, 0, 1}`\n>\n> **步骤 2：计算前缀和**\n> 我们对 `C` 数组进行累加：\n> * `C[0] = 2`\n> * `C[1] = C[1] + C[0] = 0 + 2 = 2`\n> * `C[2] = C[2] + C[1] = 2 + 2 = 4`\n> * `C[3] = C[3] + C[2] = 3 + 4 = 7`\n> * `C[4] = C[4] + C[3] = 0 + 7 = 7`\n> * `C[5] = C[5] + C[4] = 1 + 7 = 8`\n> * 数组 `C`（前缀和）：`{2, 2, 4, 7, 7, 8}`\n>\n> **现在，这个前缀和数组 `C` 的含义**变得非常重要：\n> `C[i]` 的值 = 原始数组中 **小于或等于 `i`** 的元素总个数。\n>\n> * `C[0] = 2`：有 2 个元素 $\\le 0$。\n> * `C[2] = 4`：有 4 个元素 $\\le 2$ (即 '0' 和 '2')。\n> * `C[3] = 7`：有 7 个元素 $\\le 3$ (即 '0', '2' 和 '3')。\n> * `C[5] = 8`：有 8 个元素 $\\le 5$ (即所有元素)。\n>\n> **这就是关键点！**\n> > 如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 '2' 应该放在**第 4 位**。\n> >\n> > 如果有 7 个元素小于或等于 3，那么最后一个 '3' 应该放在**第 7 位**。\n>\n> **`C[i]` 现在直接告诉了我们：值 `i` 的元素在排序后，最后一个应该放的“坑位”是第 `C[i]` 个。**\n>\n> ### 3. 步骤 3：利用前缀和（从后往前）放置元素\n>\n> 我们准备一个和 `A` 一样大的空数组 `B` (大小为 8)。\n> 我们**从右至左**（从后往前）遍历原始数组 `A`。\n>\n> `A = {2, 5, 3, 0, 2, 3, 0, 3}`\n> `C = {2, 2, 4, 7, 7, 8}` (前缀和)\n> `B = {_, _, _, _, _, _, _, _}`\n>\n> 1.  **遍历 `A[7] = 3`**\n>     * 查找 `C[3]`，值为 `7`。\n>     * 这告诉我们：'3' 应该放在第 7 个位置（即 0-based 索引的 `7-1 = 6`）。\n>     * `B[6] = 3`。\n>     * **重要**：我们用掉了一个 '3' 的位置，所以 `C[3]` 减 1。`C[3]` 变为 `6`。\n>     * `B`：`{_, _, _, _, _, _, 3, _}`\n>\n> 2.  **遍历 `A[6] = 0`**\n>     * 查找 `C[0]`，值为 `2`。\n>     * 位置：`2-1 = 1`。\n>     * `B[1] = 0`。\n>     * `C[0]` 减 1，变为 `1`。\n>     * `B`：`{_, 0, _, _, _, _, 3, _}`\n>\n> 3.  **遍历 `A[5] = 3`** (这是第二个 '3')\n>     * 查找 `C[3]`，值现在是 `6` (上次用过 '3' 后减 1 了)。\n>     * 位置：`6-1 = 5`。\n>     * `B[5] = 3`。\n>     * `C[3]` 减 1，变为 `5`。\n>     * `B`：`{_, 0, _, _, _, 3, 3, _}`\n>\n> 4.  **遍历 `A[4] = 2`**\n>     * 查找 `C[2]`，值为 `4`。\n>     * 位置：`4-1 = 3`。\n>     * `B[3] = 2`。\n>     * `C[2]` 减 1，变为 `3`。\n>     * `B`：`{_, 0, _, 2, _, 3, 3, _}`\n>\n> ... 以此类推，直到 `A[0]`。\n>\n> 5.  **遍历 `A[2] = 3`** (这是第一个 '3')\n>     * 查找 `C[3]`，值现在是 `5`。\n>     * 位置：`5-1 = 4`。\n>     * `B[4] = 3`。\n>     * `C[3]` 减 1，变为 `4`。\n>     * `B`：`{_, 0, _, 2, 3, 3, 3, _}`\n>\n> 最后我们会得到 `B = {0, 0, 2, 2, 3, 3, 3, 5}`，排序完成。\n>\n> ### 总结\n>\n> 前缀和是计数排序的灵魂，它完成了两个核心任务：\n>\n> 1.  **精确**\n>     **定位**：`C[i]` 从“`i` 的个数”转变成了“小于等于 `i` 的总数”，这个总数**直接映射**到了排序后数组的**索引（位置）**。\n> 2.  **保证稳定性**：通过**从后往前**遍历原数组 `A`，并结合 `C[i]--` 操作，我们确保了：\n>     * 原数组中**靠后**的重复元素，会先被放入新数组中**靠后**的“坑位”。\n>     * 原数组中**靠前**的重复元素，会后被放入新数组中**靠前**的“坑位”。\n>     * 从而保持了它们的相对顺序不变（即“稳定性”）。\n---\n我理解了什么意思了，但是怎么这么繁琐。。。  \n我可能之后还是不记得这个**前缀和**怎么用，不过至少了解了，先写个代码熟悉一下。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> count_sort(vector<int> &s1,int n)//需要输入的数组，里面的最大数（默认从0开始排序）\n{   \n    vector<int> c (n+1,0);//初始化计数数组；\n    //遍历计数\n    int leng=s1.size();\n    for (int i=0;i<leng;i++) c[s1[i]]++;\n    //计算前缀和；\n    for (int i=1;i<n+1;i++) c[i]+=c[i-1];\n    //将c数组里的每一个数替换成前缀和\n    \n    //定义输出数组\n    vector<int> result(leng);\n    //利用前缀和（从后往前）放置元素\n    for (int i = leng-1;i>=0;--i)\n    {\n        int num = s1[i];//查找第i元素\n        int postion=c[num]-1;//查找这个元素应该放在第几个位置\n        /*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个\n        那么这个数减一就是应该放在结果数组的位置\n        */\n        result[postion]=num;\n        c[num]--;//用掉了一个数，应该减一\n\n    }\n    return result;\n\n}\n```\n\n\n### 选择排序\n\n[oi wiki的选择排序](https://oi-wiki.org/basic/selection-sort/)解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  \n\n```cpp\n#include <utility>\n\nvoid selection_sort(int* a, int n) {\n  for (int i = 1; i < n; ++i) {\n    int ith = i;\n    for (int j = i + 1; j <= n; ++j) {\n      if (a[j] < a[ith]) {\n        ith = j;\n      }\n    }\n    std::swap(a[i], a[ith]);\n  }\n}\n```\n如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。\n本质上是打擂台，找到最小的数字，排在最前面。\n\n### 冒泡排序\n这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。  \n当不再发生交换的时候，排序完成。 \n```cpp\nvoid bubble_sort (int *a,int n)\n{\n    bool switched = true;//switched表示上一轮是否交换\n    /*这是个断终止的方法，只要上一轮没有交换说明排序结束*/\n    while (switched)\n    {\n        switched = false;\n        for(int i=0;i<n-1;++i)//注意数组越界问题，应当要再减一\n        {\n            if (a[i] > a[i + 1]) \n            {\n                switched = true;\n                swap(a[i],a[i+1]);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。\n>可数组的插入不是很复杂的吗？？\n\n代码实现如下\n\n```cpp\nvoid insertion_sort(int arr[], int len) {\n  for (int i = 1; i < len; ++i) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n}\n```\n这是gemini的解释，我觉得很形象\n\n---\n> 它的核心思想是模拟我们**玩扑克牌时整理手牌**的动作。\n>\n> ### 🃏 插入排序的核心比喻 (整理手牌)\n>\n> 想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（`key`）。\n>\n> 你会怎么做？\n>\n> 1.  你从左手中**最右边**的牌（`j`）开始，和你的新牌（`key`）比较。\n> 2.  如果左手的牌（`arr[j]`）比你的新牌（`key`）大，你就把这张牌**往右移一个位置**（`arr[j + 1] = arr[j]`），腾出它原来的空位。\n> 3.  你继续看左手边下一张牌（`j--`），重复这个比较。\n> 4.  直到你找到一张比新牌（`key`）小的牌，或者你已经比较完了所有手里的牌 ( `j < 0` )。\n> 5.  这时，你找到了正确的位置，把你手里的新牌（`key`）**插入**到刚刚腾出来的那个空位上（`arr[j + 1] = key`）。\n---\n如果基本有序，就可以使用这个插入算法。  \n\n>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。\n\n***至少下一个排序很有用***\n\n## 快速排序\n[洛谷P1177](https://www.luogu.com.cn/problem/P1177)就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  \n\n不行了这个gemini讲的太好了,我直接复制就行\n\n---\n\n\n您可以把快速排序想象成一个“**不断找人站队**”的过程。\n\n\n### 快速排序的核心思想\n\n正如您资料中提到的，它的核心是 **“分治”（Divide and Conquer）**。\n\n简单来说，就是：\n\n1.  **找一个“基准” (Pivot)：** 在队伍里（数组中）随便挑一个人（一个数）当“基准”。\n2.  **站队 (Partition)：** 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。\n3.  **分而治之 (Recurse)：** 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别**重复**第1步和第2步。\n4.  **完成：** 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。\n\n-----\n\n### 详细解释您提供的 C++ 代码\n\n您提供的代码是实现这个过程的经典方法。我们一步一步来看：\n\n#### 1\\. `Partition` 函数（最关键的“站队”过程）\n\n这个函数的目标是：**选定一个基准，并完成“站队”**。\n\n```c++\ntemplate <typename T>\nint Partition(T A[], int low, int high) {//这里low是排序的第一个指针， high是最后一个指针\n  int pivot = A[low]; // 1. 选择基准：就选第一个元素当基准 (pivot)\n                      //    此时 A[low] 这个位置可以看成一个“坑”\n\n  while (low < high) { // 2. 只要左右指针没相遇，就继续\n    \n    // 3. 从右往左找“小”的\n    while (low < high && pivot <= A[high]) --high; \n    A[low] = A[high]; // 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”\n\n    // 5. 从左往右找“大”的\n    while (low < high && A[low] <= pivot) ++low; \n    A[high] = A[low]; // 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”\n  }\n  \n  // 7. 循环结束，low 和 high 相遇了\n  A[low] = pivot; // 8. 把一开始存的基准值，放回这个最后的“坑”\n  return low;     // 9. 返回基准最后站的位置\n}\n```\n\n**用一个例子来模拟 `Partition`：**\n假设数组是 `[5, 2, 8, 1, 9, 4]`，`low = 0`, `high = 5`。\n\n1.  `pivot = A[low]`，`pivot` 存了 **5**。 `A[0]` 现在是“坑”。\n    数组：`[坑, 2, 8, 1, 9, 4]`\n2.  **从右往左**（`high` 从 5 开始）找比 5 小的。\n      * `A[5]` 是 4。比 5 小。\n3.  把 4 扔到左边的“坑” (`A[low]` 即 `A[0]`)。`A[5]` 变成新“坑”。\n    数组：`[4, 2, 8, 1, 9, 坑]`\n4.  **从左往右**（`low` 从 0 开始）找比 5 大的。\n      * `A[0]` 是 4。\n      * `A[1]` 是 2。\n      * `A[2]` 是 8。比 5 大。\n5.  把 8 扔到右边的“坑” (`A[high]` 即 `A[5]`)。`A[2]` 变成新“坑”。\n    数组：`[4, 2, 坑, 1, 9, 8]`\n6.  **从右往左**（`high` 从 5 开始）...\n      * ... `A[4]` 是 9。\n      * `A[3]` 是 1。比 5 小。\n7.  把 1 扔到左边的“坑” (`A[low]` 即 `A[2]`)。`A[3]` 变成新“坑”。\n    数组：`[4, 2, 1, 坑, 9, 8]`\n8.  **从左往右**（`low` 从 2 开始）...\n      * `A[2]` 是 1。\n      * `A[3]`... `low` 和 `high` 在 3 这个位置相遇了。循环 `while (low < high)` 结束。\n9.  把 `pivot` (存的 **5**) 放到 `A[low]` (即 `A[3]`)。\n    数组：`[4, 2, 1, 5, 9, 8]`\n10. 返回 `low` (即 3)。\n\n**看，现在数组变成了 `[4, 2, 1]` （都比5小） | `5` | `[9, 8]` （都比5大）。** 这就是“站队”！\n\n-----\n\n#### 2\\. `QuickSort` 函数（“分而治之”的递归）\n\n这个函数是“分治”思想的体现，它来“指挥”`Partition`。\n\n```c++\ntemplate <typename T>\nvoid QuickSort(T A[], int low, int high) {\n  if (low < high) { // 如果队伍里至少有2个人\n    // 1. 先站队，并拿到基准最后的位置\n    int pivot_pos = Partition(A, low, high); \n    \n    // 2. 指挥“左队”去递归排序\n    QuickSort(A, low, pivot_pos - 1); \n    \n    // 3. 指挥“右队”去递归排序\n    QuickSort(A, pivot + 1, high); \n  }\n  // 如果 low >= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。\n}\n```\n\n### 总结\n\n1.  `QuickSort` 函数是**宏观管理者**：它负责“分”，决定对哪一段（从 `low` 到 `high`）进行排序。\n2.  `Partition` 函数是**具体执行者**：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。\n3.  通过**递归**，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。\n\n您提供的资料中提到“不用合并”，就是因为 `Partition` 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。\n\n---\n后面还有[优化算法](https://oi-wiki.org/basic/quick-sort/)，我真不想看了，之后有空再看。\n\n## 归并排序\n我草怎么还有。。。\n直接放[归并](https://oi-wiki.org/basic/merge-sort/)的链接吧\n\n\n## 总结\n其实还有sort函数，要写一个函数作为排序的算法。  \n我感觉我这样学习效率很低，应该做题，不会的再去查概念。  \n先去吃个饭，等下学递归的时候改一下学习方法。","slug":"paixu1","published":1,"updated":"2025-11-08T09:45:22.483Z","comments":1,"layout":"post","photos":[],"_id":"cuidoc7fHOuUUflH1gUXX7YW8","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"%E9%AB%98%E7%B2%BE%E5%BA%A6\">高精度</span></h2><p>在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。</p>\n<p>高精度加法比较简单，将数组反转处理，将进位临时储存，<em>需注意算法结束后还要验证最后进位是否为0</em>。</p>\n<hr>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> int long long</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(a.<span class=\"hljs-built_in\">size</span>(), b.<span class=\"hljs-built_in\">size</span>()), jw = <span class=\"hljs-number\">0</span>;<br>    string c = <span class=\"hljs-string\">\"\"</span>;<br>    <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-built_in\">size</span>() &lt; len) a = <span class=\"hljs-string\">'0'</span> + a;<br>    <span class=\"hljs-keyword\">while</span> (b.<span class=\"hljs-built_in\">size</span>() &lt; len) b = <span class=\"hljs-string\">'0'</span> + b;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = len - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>    {<br>        <span class=\"hljs-type\">int</span> t1 = a[i] - <span class=\"hljs-string\">'0'</span>, t2 = b[i] - <span class=\"hljs-string\">'0'</span>;<br>        <span class=\"hljs-type\">int</span> t = t1 + t2 + jw;<br>        jw = t / <span class=\"hljs-number\">10</span>;<br>        t %= <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">char</span> ch = t + <span class=\"hljs-string\">'0'</span>;<br>        c = ch + c;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (jw != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'1'</span> + c;<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">signed</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>\tios::<span class=\"hljs-built_in\">sync_with_stdio</span>(<span class=\"hljs-number\">0</span>);<br>\tcin.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tcout.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tstring s1, s2;<br>\tcin &gt;&gt; s1 &gt;&gt; s2;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">add</span>(s1, s2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<hr>\n<p>发现自己高精度乘法解释不清楚，这个<a href=\"https://www.luogu.com.cn/article/pxfpoeoi\">高精度乘法</a>题解写的很好，可以参考下。</p>\n<hr>\n<p>然后我发现<a href=\"https://www.luogu.com.cn/problem/P1009\">p1009</a>不会做。<br>不是这高精算法怎么这么智障。<br><del>于是我决定跳过，之后再看。</del><br>还是看完了，其实并不难，题解写的很傻逼。<br>需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  </p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//高精度加法s1 s2 result均为倒叙储存</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s2)</span></span><br><span class=\"hljs-function\"></span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>(),s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>());<br>    <span class=\"hljs-type\">int</span> temp=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++)<br>    {<br>        <span class=\"hljs-type\">int</span> a,b;<br>        a=(i&lt;s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>())?s1[i] : <span class=\"hljs-number\">0</span>;<br>        b=(i&lt;s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>())?s2[i] : <span class=\"hljs-number\">0</span>;<br>        c.<span class=\"hljs-built_in\">push_back</span>((a+b+temp)%<span class=\"hljs-number\">10</span>);<br>        temp=(a+b+temp)/<span class=\"hljs-number\">10</span>;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (temp&gt;<span class=\"hljs-number\">0</span>) c.<span class=\"hljs-built_in\">push_back</span>(temp);<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><span class=\"hljs-comment\">//高精度乘以低精度乘法</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">mul</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; a, <span class=\"hljs-type\">int</span> b)</span> </span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.<span class=\"hljs-built_in\">size</span>(); i++) {<br>        temp += a[i] * b;      <br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>); <br>        temp /= <span class=\"hljs-number\">10</span>;            <br>    }<br>    <span class=\"hljs-keyword\">while</span> (temp) {<br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>);<br>        temp /= <span class=\"hljs-number\">10</span>;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (c.<span class=\"hljs-built_in\">empty</span>()) {<br>        c.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>    }<br>    <span class=\"hljs-keyword\">return</span> c;<br>}<br><br><span class=\"hljs-comment\">//主函数调用</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; sum = {<span class=\"hljs-number\">0</span>}; <br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; term = {<span class=\"hljs-number\">1</span>};<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<br>    {<br>        term = <span class=\"hljs-built_in\">mul</span>(term,i);<br>        sum = <span class=\"hljs-built_in\">add</span>(sum,term);<br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = sum.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {<br>        cout &lt;&lt; sum[i];<br>    }<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>第一版代码编译错误。<br><em><strong>我是不是有病</strong></em><br>错误在s1.[i]，和结构体搞混了。<br>改好了就过了</p>\n<p>好我们开始学习排序；</p>\n<hr>\n<h2><span id=\"%E6%8E%92%E5%BA%8F\">排序</span></h2><h3><span id=\"%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\">计数排序</span></h3><p><a href=\"https://www.luogu.com.cn/problem/P1271\">P1271 【深基9.例1】选举学生会</a>，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  </p>\n<p>计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  </p>\n<p><del>比较简单，且时间复杂度很高，感觉没什么用，下一个。</del>  </p>\n<p><a href=\"https://oi-wiki.org/basic/counting-sort/\">oiwiki</a>上写了要计算前缀和，我并不太理解，接下来是gemini的解释：</p>\n<hr>\n<blockquote>\n<p>这是一个非常好的问题！“前缀和”这一步是计数排序<strong>从一个简单的“计数”算法变成一个强大的“排序”算法</strong>的关键。</p>\n<p>简单来说，前缀和的核心作用是：<strong>把“计数”转变为“最终位置”</strong>。</p>\n<p>它解决了两个问题：</p>\n<ol>\n<li><strong>定位问题</strong>：知道有3个“5”，但我该把它们放在输出数组的哪个<strong>具体索引</strong>上？</li>\n<li><strong>稳定性问题</strong>：如果原始数组中有两个“5”（比如一个是 <code>(5, 'a')</code>，一个是 <code>(5, 'b')</code>），如何保证排序后它们的相对顺序不变？</li>\n</ol>\n<h3><span id=\"1-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%9C%B4%E7%B4%A0%E6%83%B3%E6%B3%95\">1. 如果没有前缀和（朴素想法）</span></h3><p>我们先看看，如果<strong>只有</strong>第一步“计算每个数出现了几次”，我们会怎么做。</p>\n<p>假设待排序数组 <code>A = {1, 4, 1, 2, 4, 3, 1}</code></p>\n<p><strong>步骤 1：计数</strong><br>我们得到一个“计数数组” <code>C</code>：</p>\n<ul>\n<li><code>C[1] = 3</code> (有 3 个 ‘1’)</li>\n<li><code>C[2] = 1</code> (有 1 个 ‘2’)</li>\n<li><code>C[3] = 1</code> (有 1 个 ‘3’)</li>\n<li><code>C[4] = 2</code> (有 2 个 ‘4’)</li>\n</ul>\n<p><strong>朴素的“排序”：</strong><br>我们可以遍历 <code>C</code> 数组，然后直接重写 <code>A</code>：</p>\n<ul>\n<li>看到 <code>C[1] = 3</code>，就在 <code>A</code> 里写 3 个 ‘1’：<code>A = {1, 1, 1, ...}</code></li>\n<li>看到 <code>C[2] = 1</code>，接着写 1 个 ‘2’：<code>A = {1, 1, 1, 2, ...}</code></li>\n<li>…</li>\n<li>最终得到 <code>A = {1, 1, 1, 2, 3, 4, 4}</code></li>\n</ul>\n<p><strong>问题所在：</strong><br>这确实排序了。但是，如果我们的 <code>A</code> 数组存的不是简单的数字，而是<strong>对象</strong>呢？<br>比如 <code>A = {(1, 'a'), (4, 'b'), (1, 'c'), (4, 'd'), (1, 'e')}</code><br>我们的 <code>C</code> 数组还是一样：<code>C[1]=3</code>，<code>C[4]=2</code>。<br>如果用朴素方法，我们只会得到 <code>{1, 1, 1, 4, 4}</code>。我们完全<strong>丢失了 ‘a’, ‘b’, ‘c’, ‘d’, ‘e’ 这些附加信息</strong>。</p>\n<p>我们需要的不是“覆盖”原数组，而是把原数组中的<strong>每一个元素</strong>，<strong>“搬运”</strong> 到一个新数组（或最终位置）的正确索引上。</p>\n<h3><span id=\"2-%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AE%A1%E7%AE%97%E4%BD%8D%E7%BD%AE%E8%BE%B9%E7%95%8C\">2. 前缀和的作用：计算“位置边界”</span></h3><p>前缀和就是用来计算这个“搬运”目标的。</p>\n<p>我们换一个例子：<code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code></p>\n<p><strong>步骤 1：计数</strong><br><code>C</code> 数组 (索引 0 到 5):</p>\n<ul>\n<li><code>C[0] = 2</code> (2 个 ‘0’)</li>\n<li><code>C[1] = 0</code> (0 个 ‘1’)</li>\n<li><code>C[2] = 2</code> (2 个 ‘2’)</li>\n<li><code>C[3] = 3</code> (3 个 ‘3’)</li>\n<li><code>C[4] = 0</code> (0 个 ‘4’)</li>\n<li><code>C[5] = 1</code> (1 个 ‘5’)</li>\n<li>数组 <code>C</code>：<code>{2, 0, 2, 3, 0, 1}</code></li>\n</ul>\n<p><strong>步骤 2：计算前缀和</strong><br>我们对 <code>C</code> 数组进行累加：</p>\n<ul>\n<li><code>C[0] = 2</code></li>\n<li><code>C[1] = C[1] + C[0] = 0 + 2 = 2</code></li>\n<li><code>C[2] = C[2] + C[1] = 2 + 2 = 4</code></li>\n<li><code>C[3] = C[3] + C[2] = 3 + 4 = 7</code></li>\n<li><code>C[4] = C[4] + C[3] = 0 + 7 = 7</code></li>\n<li><code>C[5] = C[5] + C[4] = 1 + 7 = 8</code></li>\n<li>数组 <code>C</code>（前缀和）：<code>{2, 2, 4, 7, 7, 8}</code></li>\n</ul>\n<p><strong>现在，这个前缀和数组 <code>C</code> 的含义</strong>变得非常重要：<br><code>C[i]</code> 的值 = 原始数组中 <strong>小于或等于 <code>i</code></strong> 的元素总个数。</p>\n<ul>\n<li><code>C[0] = 2</code>：有 2 个元素 $\\le 0$。</li>\n<li><code>C[2] = 4</code>：有 4 个元素 $\\le 2$ (即 ‘0’ 和 ‘2’)。</li>\n<li><code>C[3] = 7</code>：有 7 个元素 $\\le 3$ (即 ‘0’, ‘2’ 和 ‘3’)。</li>\n<li><code>C[5] = 8</code>：有 8 个元素 $\\le 5$ (即所有元素)。</li>\n</ul>\n<p><strong>这就是关键点！</strong></p>\n<blockquote>\n<p>如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 ‘2’ 应该放在<strong>第 4 位</strong>。</p>\n<p>如果有 7 个元素小于或等于 3，那么最后一个 ‘3’ 应该放在<strong>第 7 位</strong>。</p>\n</blockquote>\n<p><strong><code>C[i]</code> 现在直接告诉了我们：值 <code>i</code> 的元素在排序后，最后一个应该放的“坑位”是第 <code>C[i]</code> 个。</strong></p>\n<h3><span id=\"3-%E6%AD%A5%E9%AA%A4-3%E5%88%A9%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E6%94%BE%E7%BD%AE%E5%85%83%E7%B4%A0\">3. 步骤 3：利用前缀和（从后往前）放置元素</span></h3><p>我们准备一个和 <code>A</code> 一样大的空数组 <code>B</code> (大小为 8)。<br>我们<strong>从右至左</strong>（从后往前）遍历原始数组 <code>A</code>。</p>\n<p><code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code><br><code>C = {2, 2, 4, 7, 7, 8}</code> (前缀和)<br><code>B = {_, _, _, _, _, _, _, _}</code></p>\n<ol>\n<li><p><strong>遍历 <code>A[7] = 3</code></strong></p>\n<ul>\n<li>查找 <code>C[3]</code>，值为 <code>7</code>。</li>\n<li>这告诉我们：’3’ 应该放在第 7 个位置（即 0-based 索引的 <code>7-1 = 6</code>）。</li>\n<li><code>B[6] = 3</code>。</li>\n<li><strong>重要</strong>：我们用掉了一个 ‘3’ 的位置，所以 <code>C[3]</code> 减 1。<code>C[3]</code> 变为 <code>6</code>。</li>\n<li><code>B</code>：<code>{_, _, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[6] = 0</code></strong></p>\n<ul>\n<li>查找 <code>C[0]</code>，值为 <code>2</code>。</li>\n<li>位置：<code>2-1 = 1</code>。</li>\n<li><code>B[1] = 0</code>。</li>\n<li><code>C[0]</code> 减 1，变为 <code>1</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[5] = 3</code></strong> (这是第二个 ‘3’)</p>\n<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>6</code> (上次用过 ‘3’ 后减 1 了)。</li>\n<li>位置：<code>6-1 = 5</code>。</li>\n<li><code>B[5] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>5</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, 3, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[4] = 2</code></strong></p>\n<ul>\n<li>查找 <code>C[2]</code>，值为 <code>4</code>。</li>\n<li>位置：<code>4-1 = 3</code>。</li>\n<li><code>B[3] = 2</code>。</li>\n<li><code>C[2]</code> 减 1，变为 <code>3</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, _, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>… 以此类推，直到 <code>A[0]</code>。</p>\n<ol start=\"5\">\n<li><strong>遍历 <code>A[2] = 3</code></strong> (这是第一个 ‘3’)<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>5</code>。</li>\n<li>位置：<code>5-1 = 4</code>。</li>\n<li><code>B[4] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>4</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, 3, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>最后我们会得到 <code>B = {0, 0, 2, 2, 3, 3, 3, 5}</code>，排序完成。</p>\n<h3><span id=\"%E6%80%BB%E7%BB%93\">总结</span></h3><p>前缀和是计数排序的灵魂，它完成了两个核心任务：</p>\n<ol>\n<li><strong>精确</strong><br><strong>定位</strong>：<code>C[i]</code> 从“<code>i</code> 的个数”转变成了“小于等于 <code>i</code> 的总数”，这个总数<strong>直接映射</strong>到了排序后数组的<strong>索引（位置）</strong>。</li>\n<li><strong>保证稳定性</strong>：通过<strong>从后往前</strong>遍历原数组 <code>A</code>，并结合 <code>C[i]--</code> 操作，我们确保了：<ul>\n<li>原数组中<strong>靠后</strong>的重复元素，会先被放入新数组中<strong>靠后</strong>的“坑位”。</li>\n<li>原数组中<strong>靠前</strong>的重复元素，会后被放入新数组中<strong>靠前</strong>的“坑位”。</li>\n<li>从而保持了它们的相对顺序不变（即“稳定性”）。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<hr>\n<p>我理解了什么意思了，但是怎么这么繁琐。。。<br>我可能之后还是不记得这个<strong>前缀和</strong>怎么用，不过至少了解了，先写个代码熟悉一下。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">count_sort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,<span class=\"hljs-type\">int</span> n)</span><span class=\"hljs-comment\">//需要输入的数组，里面的最大数（默认从0开始排序）</span></span><br><span class=\"hljs-function\"></span>{   <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">c</span> <span class=\"hljs-params\">(n<span class=\"hljs-number\">+1</span>,<span class=\"hljs-number\">0</span>)</span></span>;<span class=\"hljs-comment\">//初始化计数数组；</span><br>    <span class=\"hljs-comment\">//遍历计数</span><br>    <span class=\"hljs-type\">int</span> leng=s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;leng;i++) c[s1[i]]++;<br>    <span class=\"hljs-comment\">//计算前缀和；</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">+1</span>;i++) c[i]+=c[i<span class=\"hljs-number\">-1</span>];<br>    <span class=\"hljs-comment\">//将c数组里的每一个数替换成前缀和</span><br>    <br>    <span class=\"hljs-comment\">//定义输出数组</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(leng)</span></span>;<br>    <span class=\"hljs-comment\">//利用前缀和（从后往前）放置元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = leng<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;--i)<br>    {<br>        <span class=\"hljs-type\">int</span> num = s1[i];<span class=\"hljs-comment\">//查找第i元素</span><br>        <span class=\"hljs-type\">int</span> postion=c[num]<span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//查找这个元素应该放在第几个位置</span><br>        <span class=\"hljs-comment\">/*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个</span><br><span class=\"hljs-comment\">        那么这个数减一就是应该放在结果数组的位置</span><br><span class=\"hljs-comment\">        */</span><br>        result[postion]=num;<br>        c[num]--;<span class=\"hljs-comment\">//用掉了一个数，应该减一</span><br><br>    }<br>    <span class=\"hljs-keyword\">return</span> result;<br><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n<h3><span id=\"%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">选择排序</span></h3><p><a href=\"https://oi-wiki.org/basic/selection-sort/\">oi wiki的选择排序</a>解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  </p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selection_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* a, <span class=\"hljs-type\">int</span> n)</span> </span>{<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) {<br>    <span class=\"hljs-type\">int</span> ith = i;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt;= n; ++j) {<br>      <span class=\"hljs-keyword\">if</span> (a[j] &lt; a[ith]) {<br>        ith = j;<br>      }<br>    }<br>    std::<span class=\"hljs-built_in\">swap</span>(a[i], a[ith]);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。<br>本质上是打擂台，找到最小的数字，排在最前面。</p>\n<h3><span id=\"%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">冒泡排序</span></h3><p>这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。<br>当不再发生交换的时候，排序完成。 </p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubble_sort</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *a,<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>{<br>    <span class=\"hljs-type\">bool</span> switched = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//switched表示上一轮是否交换</span><br>    <span class=\"hljs-comment\">/*这是个断终止的方法，只要上一轮没有交换说明排序结束*/</span><br>    <span class=\"hljs-keyword\">while</span> (switched)<br>    {<br>        switched = <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;++i)<span class=\"hljs-comment\">//注意数组越界问题，应当要再减一</span><br>        {<br>            <span class=\"hljs-keyword\">if</span> (a[i] &gt; a[i + <span class=\"hljs-number\">1</span>]) <br>            {<br>                switched = <span class=\"hljs-literal\">true</span>;<br>                <span class=\"hljs-built_in\">swap</span>(a[i],a[i<span class=\"hljs-number\">+1</span>]);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2><span id=\"%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序</span></h2><p>把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。</p>\n<blockquote>\n<p>可数组的插入不是很复杂的吗？？</p>\n</blockquote>\n<p>代码实现如下</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertion_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> len)</span> </span>{<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; ++i) {<br>    <span class=\"hljs-type\">int</span> key = arr[i];<br>    <span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; key) {<br>      arr[j + <span class=\"hljs-number\">1</span>] = arr[j];<br>      j--;<br>    }<br>    arr[j + <span class=\"hljs-number\">1</span>] = key;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>这是gemini的解释，我觉得很形象</p>\n<hr>\n<blockquote>\n<p>它的核心思想是模拟我们<strong>玩扑克牌时整理手牌</strong>的动作。</p>\n<h3><span id=\"%F0%9F%83%8F-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%AF%94%E5%96%BB-%E6%95%B4%E7%90%86%E6%89%8B%E7%89%8C\">🃏 插入排序的核心比喻 (整理手牌)</span></h3><p>想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（<code>key</code>）。</p>\n<p>你会怎么做？</p>\n<ol>\n<li>&nbsp;你从左手中<strong>最右边</strong>的牌（<code>j</code>）开始，和你的新牌（<code>key</code>）比较。</li>\n<li>&nbsp;如果左手的牌（<code>arr[j]</code>）比你的新牌（<code>key</code>）大，你就把这张牌<strong>往右移一个位置</strong>（<code>arr[j + 1] = arr[j]</code>），腾出它原来的空位。</li>\n<li>&nbsp;你继续看左手边下一张牌（<code>j--</code>），重复这个比较。</li>\n<li>&nbsp;直到你找到一张比新牌（<code>key</code>）小的牌，或者你已经比较完了所有手里的牌 ( <code>j &lt; 0</code> )。</li>\n<li>&nbsp;这时，你找到了正确的位置，把你手里的新牌（<code>key</code>）<strong>插入</strong>到刚刚腾出来的那个空位上（<code>arr[j + 1] = key</code>）。</li>\n</ol>\n</blockquote>\n<hr>\n<p>如果基本有序，就可以使用这个插入算法。  </p>\n<blockquote>\n<p>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。</p>\n</blockquote>\n<p><em><strong>至少下一个排序很有用</strong></em></p>\n<h2><span id=\"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">快速排序</span></h2><p><a href=\"https://www.luogu.com.cn/problem/P1177\">洛谷P1177</a>就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  </p>\n<p>不行了这个gemini讲的太好了,我直接复制就行</p>\n<hr>\n<p>您可以把快速排序想象成一个“<strong>不断找人站队</strong>”的过程。</p>\n<h3><span id=\"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\">快速排序的核心思想</span></h3><p>正如您资料中提到的，它的核心是 <strong>“分治”（Divide and Conquer）</strong>。</p>\n<p>简单来说，就是：</p>\n<ol>\n<li><strong>找一个“基准” (Pivot)：</strong> 在队伍里（数组中）随便挑一个人（一个数）当“基准”。</li>\n<li><strong>站队 (Partition)：</strong> 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。</li>\n<li><strong>分而治之 (Recurse)：</strong> 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别<strong>重复</strong>第1步和第2步。</li>\n<li><strong>完成：</strong> 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。</li>\n</ol>\n<hr>\n<h3><span id=\"%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E6%82%A8%E6%8F%90%E4%BE%9B%E7%9A%84-c-%E4%BB%A3%E7%A0%81\">详细解释您提供的 C++ 代码</span></h3><p>您提供的代码是实现这个过程的经典方法。我们一步一步来看：</p>\n<h4><span id=\"1-partition-%E5%87%BD%E6%95%B0%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E7%AB%99%E9%98%9F%E8%BF%87%E7%A8%8B\">1. <code>Partition</code> 函数（最关键的“站队”过程）</span></h4><p>这个函数的目标是：<strong>选定一个基准，并完成“站队”</strong>。</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Partition</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>{<span class=\"hljs-comment\">//这里low是排序的第一个指针， high是最后一个指针</span><br>  <span class=\"hljs-type\">int</span> pivot = A[low]; <span class=\"hljs-comment\">// 1. 选择基准：就选第一个元素当基准 (pivot)</span><br>                      <span class=\"hljs-comment\">//    此时 A[low] 这个位置可以看成一个“坑”</span><br><br>  <span class=\"hljs-keyword\">while</span> (low &lt; high) { <span class=\"hljs-comment\">// 2. 只要左右指针没相遇，就继续</span><br>    <br>    <span class=\"hljs-comment\">// 3. 从右往左找“小”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; pivot &lt;= A[high]) --high; <br>    A[low] = A[high]; <span class=\"hljs-comment\">// 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”</span><br><br>    <span class=\"hljs-comment\">// 5. 从左往右找“大”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; <br>    A[high] = A[low]; <span class=\"hljs-comment\">// 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”</span><br>  }<br>  <br>  <span class=\"hljs-comment\">// 7. 循环结束，low 和 high 相遇了</span><br>  A[low] = pivot; <span class=\"hljs-comment\">// 8. 把一开始存的基准值，放回这个最后的“坑”</span><br>  <span class=\"hljs-keyword\">return</span> low;     <span class=\"hljs-comment\">// 9. 返回基准最后站的位置</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>用一个例子来模拟 <code>Partition</code>：</strong><br>假设数组是 <code>[5, 2, 8, 1, 9, 4]</code>，<code>low = 0</code>, <code>high = 5</code>。</p>\n<ol>\n<li><code>pivot = A[low]</code>，<code>pivot</code> 存了 <strong>5</strong>。 <code>A[0]</code> 现在是“坑”。<br>数组：<code>[坑, 2, 8, 1, 9, 4]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）找比 5 小的。<ul>\n<li><code>A[5]</code> 是 4。比 5 小。</li>\n</ul>\n</li>\n<li>把 4 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[0]</code>)。<code>A[5]</code> 变成新“坑”。<br>数组：<code>[4, 2, 8, 1, 9, 坑]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 0 开始）找比 5 大的。<ul>\n<li><code>A[0]</code> 是 4。</li>\n<li><code>A[1]</code> 是 2。</li>\n<li><code>A[2]</code> 是 8。比 5 大。</li>\n</ul>\n</li>\n<li>把 8 扔到右边的“坑” (<code>A[high]</code> 即 <code>A[5]</code>)。<code>A[2]</code> 变成新“坑”。<br>数组：<code>[4, 2, 坑, 1, 9, 8]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）…<ul>\n<li>… <code>A[4]</code> 是 9。</li>\n<li><code>A[3]</code> 是 1。比 5 小。</li>\n</ul>\n</li>\n<li>把 1 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[2]</code>)。<code>A[3]</code> 变成新“坑”。<br>数组：<code>[4, 2, 1, 坑, 9, 8]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 2 开始）…<ul>\n<li><code>A[2]</code> 是 1。</li>\n<li><code>A[3]</code>… <code>low</code> 和 <code>high</code> 在 3 这个位置相遇了。循环 <code>while (low &lt; high)</code> 结束。</li>\n</ul>\n</li>\n<li>把 <code>pivot</code> (存的 <strong>5</strong>) 放到 <code>A[low]</code> (即 <code>A[3]</code>)。<br>数组：<code>[4, 2, 1, 5, 9, 8]</code></li>\n<li>返回 <code>low</code> (即 3)。</li>\n</ol>\n<p><strong>看，现在数组变成了 <code>[4, 2, 1]</code> （都比5小） | <code>5</code> | <code>[9, 8]</code> （都比5大）。</strong> 这就是“站队”！</p>\n<hr>\n<h4><span id=\"2-quicksort-%E5%87%BD%E6%95%B0%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%9A%84%E9%80%92%E5%BD%92\">2. <code>QuickSort</code> 函数（“分而治之”的递归）</span></h4><p>这个函数是“分治”思想的体现，它来“指挥”<code>Partition</code>。</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">QuickSort</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>{<br>  <span class=\"hljs-keyword\">if</span> (low &lt; high) { <span class=\"hljs-comment\">// 如果队伍里至少有2个人</span><br>    <span class=\"hljs-comment\">// 1. 先站队，并拿到基准最后的位置</span><br>    <span class=\"hljs-type\">int</span> pivot_pos = <span class=\"hljs-built_in\">Partition</span>(A, low, high); <br>    <br>    <span class=\"hljs-comment\">// 2. 指挥“左队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, low, pivot_pos - <span class=\"hljs-number\">1</span>); <br>    <br>    <span class=\"hljs-comment\">// 3. 指挥“右队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, pivot + <span class=\"hljs-number\">1</span>, high); <br>  }<br>  <span class=\"hljs-comment\">// 如果 low &gt;= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h3><span id=\"%E6%80%BB%E7%BB%93\">总结</span></h3><ol>\n<li><code>QuickSort</code> 函数是<strong>宏观管理者</strong>：它负责“分”，决定对哪一段（从 <code>low</code> 到 <code>high</code>）进行排序。</li>\n<li><code>Partition</code> 函数是<strong>具体执行者</strong>：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。</li>\n<li>通过<strong>递归</strong>，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。</li>\n</ol>\n<p>您提供的资料中提到“不用合并”，就是因为 <code>Partition</code> 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。</p>\n<hr>\n<p>后面还有<a href=\"https://oi-wiki.org/basic/quick-sort/\">优化算法</a>，我真不想看了，之后有空再看。</p>\n<h2><span id=\"%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序</span></h2><p>我草怎么还有。。。<br>直接放<a href=\"https://oi-wiki.org/basic/merge-sort/\">归并</a>的链接吧</p>\n<h2><span id=\"%E6%80%BB%E7%BB%93\">总结</span></h2><p>其实还有sort函数，要写一个函数作为排序的算法。<br>我感觉我这样学习效率很低，应该做题，不会的再去查概念。<br>先去吃个饭，等下学递归的时候改一下学习方法。</p>\n</body></html>","excerpt":"","more":"<h2 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h2><p>在此之前，我需要复习一下高精度，昨晚高精度算法写错了好多次。</p>\n<p>高精度加法比较简单，将数组反转处理，将进位临时储存，<em>需注意算法结束后还要验证最后进位是否为0</em>。</p>\n<hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> int long long</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(a.<span class=\"hljs-built_in\">size</span>(), b.<span class=\"hljs-built_in\">size</span>()), jw = <span class=\"hljs-number\">0</span>;<br>    string c = <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-built_in\">size</span>() &lt; len) a = <span class=\"hljs-string\">&#x27;0&#x27;</span> + a;<br>    <span class=\"hljs-keyword\">while</span> (b.<span class=\"hljs-built_in\">size</span>() &lt; len) b = <span class=\"hljs-string\">&#x27;0&#x27;</span> + b;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = len - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> t1 = a[i] - <span class=\"hljs-string\">&#x27;0&#x27;</span>, t2 = b[i] - <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        <span class=\"hljs-type\">int</span> t = t1 + t2 + jw;<br>        jw = t / <span class=\"hljs-number\">10</span>;<br>        t %= <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-type\">char</span> ch = t + <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        c = ch + c;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (jw != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;1&#x27;</span> + c;<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">signed</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tios::<span class=\"hljs-built_in\">sync_with_stdio</span>(<span class=\"hljs-number\">0</span>);<br>\tcin.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tcout.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-number\">0</span>);<br>\tstring s1, s2;<br>\tcin &gt;&gt; s1 &gt;&gt; s2;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">add</span>(s1, s2);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p>发现自己高精度乘法解释不清楚，这个<a href=\"https://www.luogu.com.cn/article/pxfpoeoi\">高精度乘法</a>题解写的很好，可以参考下。</p>\n<hr>\n<p>然后我发现<a href=\"https://www.luogu.com.cn/problem/P1009\">p1009</a>不会做。<br>不是这高精算法怎么这么智障。<br><del>于是我决定跳过，之后再看。</del><br>还是看完了，其实并不难，题解写的很傻逼。<br>需要定义一个高精度加法，高精度乘以低精度乘法，再调用就好了。  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//高精度加法s1 s2 result均为倒叙储存</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s2)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> len = <span class=\"hljs-built_in\">max</span>(s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>(),s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>());<br>    <span class=\"hljs-type\">int</span> temp=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;len;i++)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> a,b;<br>        a=(i&lt;s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>())?s1[i] : <span class=\"hljs-number\">0</span>;<br>        b=(i&lt;s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>())?s2[i] : <span class=\"hljs-number\">0</span>;<br>        c.<span class=\"hljs-built_in\">push_back</span>((a+b+temp)%<span class=\"hljs-number\">10</span>);<br>        temp=(a+b+temp)/<span class=\"hljs-number\">10</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (temp&gt;<span class=\"hljs-number\">0</span>) c.<span class=\"hljs-built_in\">push_back</span>(temp);<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><span class=\"hljs-comment\">//高精度乘以低精度乘法</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">mul</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; c;<br>    <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>        temp += a[i] * b;      <br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>); <br>        temp /= <span class=\"hljs-number\">10</span>;            <br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (temp) &#123;<br>        c.<span class=\"hljs-built_in\">push_back</span>(temp % <span class=\"hljs-number\">10</span>);<br>        temp /= <span class=\"hljs-number\">10</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (c.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        c.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> c;<br>&#125;<br><br><span class=\"hljs-comment\">//主函数调用</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; sum = &#123;<span class=\"hljs-number\">0</span>&#125;; <br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; term = &#123;<span class=\"hljs-number\">1</span>&#125;;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<br>    &#123;<br>        term = <span class=\"hljs-built_in\">mul</span>(term,i);<br>        sum = <span class=\"hljs-built_in\">add</span>(sum,term);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = sum.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>        cout &lt;&lt; sum[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第一版代码编译错误。<br><em><strong>我是不是有病</strong></em><br>错误在s1.[i]，和结构体搞混了。<br>改好了就过了</p>\n<p>好我们开始学习排序；</p>\n<hr>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><p><a href=\"https://www.luogu.com.cn/problem/P1271\">P1271 【深基9.例1】选举学生会</a>，这道题理论来说是计数排序，我当时直接sort函数逃课了，现在再看一遍。  </p>\n<p>计数排序事实上是循环读取输入，然后在一个数组中记录每个数读取到的次数，再根据次数输出。  </p>\n<p><del>比较简单，且时间复杂度很高，感觉没什么用，下一个。</del>  </p>\n<p><a href=\"https://oi-wiki.org/basic/counting-sort/\">oiwiki</a>上写了要计算前缀和，我并不太理解，接下来是gemini的解释：</p>\n<hr>\n<blockquote>\n<p>这是一个非常好的问题！“前缀和”这一步是计数排序<strong>从一个简单的“计数”算法变成一个强大的“排序”算法</strong>的关键。</p>\n<p>简单来说，前缀和的核心作用是：<strong>把“计数”转变为“最终位置”</strong>。</p>\n<p>它解决了两个问题：</p>\n<ol>\n<li><strong>定位问题</strong>：知道有3个“5”，但我该把它们放在输出数组的哪个<strong>具体索引</strong>上？</li>\n<li><strong>稳定性问题</strong>：如果原始数组中有两个“5”（比如一个是 <code>(5, &#39;a&#39;)</code>，一个是 <code>(5, &#39;b&#39;)</code>），如何保证排序后它们的相对顺序不变？</li>\n</ol>\n<h3 id=\"1-如果没有前缀和（朴素想法）\"><a href=\"#1-如果没有前缀和（朴素想法）\" class=\"headerlink\" title=\"1. 如果没有前缀和（朴素想法）\"></a>1. 如果没有前缀和（朴素想法）</h3><p>我们先看看，如果<strong>只有</strong>第一步“计算每个数出现了几次”，我们会怎么做。</p>\n<p>假设待排序数组 <code>A = {1, 4, 1, 2, 4, 3, 1}</code></p>\n<p><strong>步骤 1：计数</strong><br>我们得到一个“计数数组” <code>C</code>：</p>\n<ul>\n<li><code>C[1] = 3</code> (有 3 个 ‘1’)</li>\n<li><code>C[2] = 1</code> (有 1 个 ‘2’)</li>\n<li><code>C[3] = 1</code> (有 1 个 ‘3’)</li>\n<li><code>C[4] = 2</code> (有 2 个 ‘4’)</li>\n</ul>\n<p><strong>朴素的“排序”：</strong><br>我们可以遍历 <code>C</code> 数组，然后直接重写 <code>A</code>：</p>\n<ul>\n<li>看到 <code>C[1] = 3</code>，就在 <code>A</code> 里写 3 个 ‘1’：<code>A = {1, 1, 1, ...}</code></li>\n<li>看到 <code>C[2] = 1</code>，接着写 1 个 ‘2’：<code>A = {1, 1, 1, 2, ...}</code></li>\n<li>…</li>\n<li>最终得到 <code>A = {1, 1, 1, 2, 3, 4, 4}</code></li>\n</ul>\n<p><strong>问题所在：</strong><br>这确实排序了。但是，如果我们的 <code>A</code> 数组存的不是简单的数字，而是<strong>对象</strong>呢？<br>比如 <code>A = {(1, &#39;a&#39;), (4, &#39;b&#39;), (1, &#39;c&#39;), (4, &#39;d&#39;), (1, &#39;e&#39;)}</code><br>我们的 <code>C</code> 数组还是一样：<code>C[1]=3</code>，<code>C[4]=2</code>。<br>如果用朴素方法，我们只会得到 <code>{1, 1, 1, 4, 4}</code>。我们完全<strong>丢失了 ‘a’, ‘b’, ‘c’, ‘d’, ‘e’ 这些附加信息</strong>。</p>\n<p>我们需要的不是“覆盖”原数组，而是把原数组中的<strong>每一个元素</strong>，<strong>“搬运”</strong> 到一个新数组（或最终位置）的正确索引上。</p>\n<h3 id=\"2-前缀和的作用：计算“位置边界”\"><a href=\"#2-前缀和的作用：计算“位置边界”\" class=\"headerlink\" title=\"2. 前缀和的作用：计算“位置边界”\"></a>2. 前缀和的作用：计算“位置边界”</h3><p>前缀和就是用来计算这个“搬运”目标的。</p>\n<p>我们换一个例子：<code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code></p>\n<p><strong>步骤 1：计数</strong><br><code>C</code> 数组 (索引 0 到 5):</p>\n<ul>\n<li><code>C[0] = 2</code> (2 个 ‘0’)</li>\n<li><code>C[1] = 0</code> (0 个 ‘1’)</li>\n<li><code>C[2] = 2</code> (2 个 ‘2’)</li>\n<li><code>C[3] = 3</code> (3 个 ‘3’)</li>\n<li><code>C[4] = 0</code> (0 个 ‘4’)</li>\n<li><code>C[5] = 1</code> (1 个 ‘5’)</li>\n<li>数组 <code>C</code>：<code>{2, 0, 2, 3, 0, 1}</code></li>\n</ul>\n<p><strong>步骤 2：计算前缀和</strong><br>我们对 <code>C</code> 数组进行累加：</p>\n<ul>\n<li><code>C[0] = 2</code></li>\n<li><code>C[1] = C[1] + C[0] = 0 + 2 = 2</code></li>\n<li><code>C[2] = C[2] + C[1] = 2 + 2 = 4</code></li>\n<li><code>C[3] = C[3] + C[2] = 3 + 4 = 7</code></li>\n<li><code>C[4] = C[4] + C[3] = 0 + 7 = 7</code></li>\n<li><code>C[5] = C[5] + C[4] = 1 + 7 = 8</code></li>\n<li>数组 <code>C</code>（前缀和）：<code>{2, 2, 4, 7, 7, 8}</code></li>\n</ul>\n<p><strong>现在，这个前缀和数组 <code>C</code> 的含义</strong>变得非常重要：<br><code>C[i]</code> 的值 &#x3D; 原始数组中 <strong>小于或等于 <code>i</code></strong> 的元素总个数。</p>\n<ul>\n<li><code>C[0] = 2</code>：有 2 个元素 $\\le 0$。</li>\n<li><code>C[2] = 4</code>：有 4 个元素 $\\le 2$ (即 ‘0’ 和 ‘2’)。</li>\n<li><code>C[3] = 7</code>：有 7 个元素 $\\le 3$ (即 ‘0’, ‘2’ 和 ‘3’)。</li>\n<li><code>C[5] = 8</code>：有 8 个元素 $\\le 5$ (即所有元素)。</li>\n</ul>\n<p><strong>这就是关键点！</strong></p>\n<blockquote>\n<p>如果有 4 个元素小于或等于 2，那么在排好序的数组（假设 1-based 索引）中，最后一个 ‘2’ 应该放在<strong>第 4 位</strong>。</p>\n<p>如果有 7 个元素小于或等于 3，那么最后一个 ‘3’ 应该放在<strong>第 7 位</strong>。</p>\n</blockquote>\n<p><strong><code>C[i]</code> 现在直接告诉了我们：值 <code>i</code> 的元素在排序后，最后一个应该放的“坑位”是第 <code>C[i]</code> 个。</strong></p>\n<h3 id=\"3-步骤-3：利用前缀和（从后往前）放置元素\"><a href=\"#3-步骤-3：利用前缀和（从后往前）放置元素\" class=\"headerlink\" title=\"3. 步骤 3：利用前缀和（从后往前）放置元素\"></a>3. 步骤 3：利用前缀和（从后往前）放置元素</h3><p>我们准备一个和 <code>A</code> 一样大的空数组 <code>B</code> (大小为 8)。<br>我们<strong>从右至左</strong>（从后往前）遍历原始数组 <code>A</code>。</p>\n<p><code>A = {2, 5, 3, 0, 2, 3, 0, 3}</code><br><code>C = {2, 2, 4, 7, 7, 8}</code> (前缀和)<br><code>B = {_, _, _, _, _, _, _, _}</code></p>\n<ol>\n<li><p><strong>遍历 <code>A[7] = 3</code></strong></p>\n<ul>\n<li>查找 <code>C[3]</code>，值为 <code>7</code>。</li>\n<li>这告诉我们：’3’ 应该放在第 7 个位置（即 0-based 索引的 <code>7-1 = 6</code>）。</li>\n<li><code>B[6] = 3</code>。</li>\n<li><strong>重要</strong>：我们用掉了一个 ‘3’ 的位置，所以 <code>C[3]</code> 减 1。<code>C[3]</code> 变为 <code>6</code>。</li>\n<li><code>B</code>：<code>{_, _, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[6] = 0</code></strong></p>\n<ul>\n<li>查找 <code>C[0]</code>，值为 <code>2</code>。</li>\n<li>位置：<code>2-1 = 1</code>。</li>\n<li><code>B[1] = 0</code>。</li>\n<li><code>C[0]</code> 减 1，变为 <code>1</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, _, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[5] = 3</code></strong> (这是第二个 ‘3’)</p>\n<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>6</code> (上次用过 ‘3’ 后减 1 了)。</li>\n<li>位置：<code>6-1 = 5</code>。</li>\n<li><code>B[5] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>5</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, _, _, 3, 3, _}</code></li>\n</ul>\n</li>\n<li><p><strong>遍历 <code>A[4] = 2</code></strong></p>\n<ul>\n<li>查找 <code>C[2]</code>，值为 <code>4</code>。</li>\n<li>位置：<code>4-1 = 3</code>。</li>\n<li><code>B[3] = 2</code>。</li>\n<li><code>C[2]</code> 减 1，变为 <code>3</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, _, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>… 以此类推，直到 <code>A[0]</code>。</p>\n<ol start=\"5\">\n<li><strong>遍历 <code>A[2] = 3</code></strong> (这是第一个 ‘3’)<ul>\n<li>查找 <code>C[3]</code>，值现在是 <code>5</code>。</li>\n<li>位置：<code>5-1 = 4</code>。</li>\n<li><code>B[4] = 3</code>。</li>\n<li><code>C[3]</code> 减 1，变为 <code>4</code>。</li>\n<li><code>B</code>：<code>{_, 0, _, 2, 3, 3, 3, _}</code></li>\n</ul>\n</li>\n</ol>\n<p>最后我们会得到 <code>B = {0, 0, 2, 2, 3, 3, 3, 5}</code>，排序完成。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前缀和是计数排序的灵魂，它完成了两个核心任务：</p>\n<ol>\n<li><strong>精确</strong><br><strong>定位</strong>：<code>C[i]</code> 从“<code>i</code> 的个数”转变成了“小于等于 <code>i</code> 的总数”，这个总数<strong>直接映射</strong>到了排序后数组的<strong>索引（位置）</strong>。</li>\n<li><strong>保证稳定性</strong>：通过<strong>从后往前</strong>遍历原数组 <code>A</code>，并结合 <code>C[i]--</code> 操作，我们确保了：<ul>\n<li>原数组中<strong>靠后</strong>的重复元素，会先被放入新数组中<strong>靠后</strong>的“坑位”。</li>\n<li>原数组中<strong>靠前</strong>的重复元素，会后被放入新数组中<strong>靠前</strong>的“坑位”。</li>\n<li>从而保持了它们的相对顺序不变（即“稳定性”）。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<hr>\n<p>我理解了什么意思了，但是怎么这么繁琐。。。<br>我可能之后还是不记得这个<strong>前缀和</strong>怎么用，不过至少了解了，先写个代码熟悉一下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">count_sort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;s1,<span class=\"hljs-type\">int</span> n)</span><span class=\"hljs-comment\">//需要输入的数组，里面的最大数（默认从0开始排序）</span></span><br><span class=\"hljs-function\"></span>&#123;   <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">c</span> <span class=\"hljs-params\">(n<span class=\"hljs-number\">+1</span>,<span class=\"hljs-number\">0</span>)</span></span>;<span class=\"hljs-comment\">//初始化计数数组；</span><br>    <span class=\"hljs-comment\">//遍历计数</span><br>    <span class=\"hljs-type\">int</span> leng=s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;leng;i++) c[s1[i]]++;<br>    <span class=\"hljs-comment\">//计算前缀和；</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">+1</span>;i++) c[i]+=c[i<span class=\"hljs-number\">-1</span>];<br>    <span class=\"hljs-comment\">//将c数组里的每一个数替换成前缀和</span><br>    <br>    <span class=\"hljs-comment\">//定义输出数组</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(leng)</span></span>;<br>    <span class=\"hljs-comment\">//利用前缀和（从后往前）放置元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = leng<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;--i)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> num = s1[i];<span class=\"hljs-comment\">//查找第i元素</span><br>        <span class=\"hljs-type\">int</span> postion=c[num]<span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//查找这个元素应该放在第几个位置</span><br>        <span class=\"hljs-comment\">/*这就是前缀和的作用，即这个元素和小于这个元素的一共有几个</span><br><span class=\"hljs-comment\">        那么这个数减一就是应该放在结果数组的位置</span><br><span class=\"hljs-comment\">        */</span><br>        result[postion]=num;<br>        c[num]--;<span class=\"hljs-comment\">//用掉了一个数，应该减一</span><br><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p><a href=\"https://oi-wiki.org/basic/selection-sort/\">oi wiki的选择排序</a>解释的特别清楚，即找到第i小的数字，并将其与第i位数交换  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selection_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* a, <span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-type\">int</span> ith = i;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt;= n; ++j) &#123;<br>      <span class=\"hljs-keyword\">if</span> (a[j] &lt; a[ith]) &#123;<br>        ith = j;<br>      &#125;<br>    &#125;<br>    std::<span class=\"hljs-built_in\">swap</span>(a[i], a[ith]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果再解释地清楚一点，就是从第i位开始遍历后面的数组，找到其中最小的数字并且与第i位数字交换。<br>本质上是打擂台，找到最小的数字，排在最前面。</p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>这个其实更加简单，即循环遍历相邻的两个数，使他们正向排序。<br>当不再发生交换的时候，排序完成。 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubble_sort</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *a,<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">bool</span> switched = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//switched表示上一轮是否交换</span><br>    <span class=\"hljs-comment\">/*这是个断终止的方法，只要上一轮没有交换说明排序结束*/</span><br>    <span class=\"hljs-keyword\">while</span> (switched)<br>    &#123;<br>        switched = <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;++i)<span class=\"hljs-comment\">//注意数组越界问题，应当要再减一</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (a[i] &gt; a[i + <span class=\"hljs-number\">1</span>]) <br>            &#123;<br>                switched = <span class=\"hljs-literal\">true</span>;<br>                <span class=\"hljs-built_in\">swap</span>(a[i],a[i<span class=\"hljs-number\">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>把数组分为排序区和非排序区，然后一个个把非排序区的第一个元素插入进排序区。</p>\n<blockquote>\n<p>可数组的插入不是很复杂的吗？？</p>\n</blockquote>\n<p>代码实现如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertion_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> len)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; len; ++i) &#123;<br>    <span class=\"hljs-type\">int</span> key = arr[i];<br>    <span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>      arr[j + <span class=\"hljs-number\">1</span>] = arr[j];<br>      j--;<br>    &#125;<br>    arr[j + <span class=\"hljs-number\">1</span>] = key;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这是gemini的解释，我觉得很形象</p>\n<hr>\n<blockquote>\n<p>它的核心思想是模拟我们<strong>玩扑克牌时整理手牌</strong>的动作。</p>\n<h3 id=\"🃏-插入排序的核心比喻-整理手牌\"><a href=\"#🃏-插入排序的核心比喻-整理手牌\" class=\"headerlink\" title=\"🃏 插入排序的核心比喻 (整理手牌)\"></a>🃏 插入排序的核心比喻 (整理手牌)</h3><p>想象一下，你左手拿着一副已经（部分）排好序的牌，右手刚抽到一张新牌（<code>key</code>）。</p>\n<p>你会怎么做？</p>\n<ol>\n<li> 你从左手中<strong>最右边</strong>的牌（<code>j</code>）开始，和你的新牌（<code>key</code>）比较。</li>\n<li> 如果左手的牌（<code>arr[j]</code>）比你的新牌（<code>key</code>）大，你就把这张牌<strong>往右移一个位置</strong>（<code>arr[j + 1] = arr[j]</code>），腾出它原来的空位。</li>\n<li> 你继续看左手边下一张牌（<code>j--</code>），重复这个比较。</li>\n<li> 直到你找到一张比新牌（<code>key</code>）小的牌，或者你已经比较完了所有手里的牌 ( <code>j &lt; 0</code> )。</li>\n<li> 这时，你找到了正确的位置，把你手里的新牌（<code>key</code>）<strong>插入</strong>到刚刚腾出来的那个空位上（<code>arr[j + 1] = key</code>）。</li>\n</ol>\n</blockquote>\n<hr>\n<p>如果基本有序，就可以使用这个插入算法。  </p>\n<blockquote>\n<p>不是我看到这里和我说这些算法时间复杂度太差了，不怎么用。</p>\n</blockquote>\n<p><em><strong>至少下一个排序很有用</strong></em></p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p><a href=\"https://www.luogu.com.cn/problem/P1177\">洛谷P1177</a>就是一道快速排序题，上次我没有做对也没有理解，今天再做一次。  </p>\n<p>不行了这个gemini讲的太好了,我直接复制就行</p>\n<hr>\n<p>您可以把快速排序想象成一个“<strong>不断找人站队</strong>”的过程。</p>\n<h3 id=\"快速排序的核心思想\"><a href=\"#快速排序的核心思想\" class=\"headerlink\" title=\"快速排序的核心思想\"></a>快速排序的核心思想</h3><p>正如您资料中提到的，它的核心是 <strong>“分治”（Divide and Conquer）</strong>。</p>\n<p>简单来说，就是：</p>\n<ol>\n<li><strong>找一个“基准” (Pivot)：</strong> 在队伍里（数组中）随便挑一个人（一个数）当“基准”。</li>\n<li><strong>站队 (Partition)：</strong> 以这个基准为标准，让所有比他“小”的站到他左边，所有比他“大”的站到他右边。这个基准自己会站在中间的某个位置。</li>\n<li><strong>分而治之 (Recurse)：</strong> 现在队伍被分成了“左队”和“右队”。我们对“左队”和“右队”分别<strong>重复</strong>第1步和第2步。</li>\n<li><strong>完成：</strong> 当所有人都“分无可分”（即每个小队都只剩一个人或0个人）时，整个队伍（数组）就自然排好序了。</li>\n</ol>\n<hr>\n<h3 id=\"详细解释您提供的-C-代码\"><a href=\"#详细解释您提供的-C-代码\" class=\"headerlink\" title=\"详细解释您提供的 C++ 代码\"></a>详细解释您提供的 C++ 代码</h3><p>您提供的代码是实现这个过程的经典方法。我们一步一步来看：</p>\n<h4 id=\"1-Partition-函数（最关键的“站队”过程）\"><a href=\"#1-Partition-函数（最关键的“站队”过程）\" class=\"headerlink\" title=\"1. Partition 函数（最关键的“站队”过程）\"></a>1. <code>Partition</code> 函数（最关键的“站队”过程）</h4><p>这个函数的目标是：<strong>选定一个基准，并完成“站队”</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Partition</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>&#123;<span class=\"hljs-comment\">//这里low是排序的第一个指针， high是最后一个指针</span><br>  <span class=\"hljs-type\">int</span> pivot = A[low]; <span class=\"hljs-comment\">// 1. 选择基准：就选第一个元素当基准 (pivot)</span><br>                      <span class=\"hljs-comment\">//    此时 A[low] 这个位置可以看成一个“坑”</span><br><br>  <span class=\"hljs-keyword\">while</span> (low &lt; high) &#123; <span class=\"hljs-comment\">// 2. 只要左右指针没相遇，就继续</span><br>    <br>    <span class=\"hljs-comment\">// 3. 从右往左找“小”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; pivot &lt;= A[high]) --high; <br>    A[low] = A[high]; <span class=\"hljs-comment\">// 4. 找到一个比基准小的，扔到左边的“坑”里。A[high] 成了新“坑”</span><br><br>    <span class=\"hljs-comment\">// 5. 从左往右找“大”的</span><br>    <span class=\"hljs-keyword\">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; <br>    A[high] = A[low]; <span class=\"hljs-comment\">// 6. 找到一个比基准大的，扔到右边的“坑”里。A[low] 成了新“坑”</span><br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 7. 循环结束，low 和 high 相遇了</span><br>  A[low] = pivot; <span class=\"hljs-comment\">// 8. 把一开始存的基准值，放回这个最后的“坑”</span><br>  <span class=\"hljs-keyword\">return</span> low;     <span class=\"hljs-comment\">// 9. 返回基准最后站的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>用一个例子来模拟 <code>Partition</code>：</strong><br>假设数组是 <code>[5, 2, 8, 1, 9, 4]</code>，<code>low = 0</code>, <code>high = 5</code>。</p>\n<ol>\n<li><code>pivot = A[low]</code>，<code>pivot</code> 存了 <strong>5</strong>。 <code>A[0]</code> 现在是“坑”。<br>数组：<code>[坑, 2, 8, 1, 9, 4]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）找比 5 小的。<ul>\n<li><code>A[5]</code> 是 4。比 5 小。</li>\n</ul>\n</li>\n<li>把 4 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[0]</code>)。<code>A[5]</code> 变成新“坑”。<br>数组：<code>[4, 2, 8, 1, 9, 坑]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 0 开始）找比 5 大的。<ul>\n<li><code>A[0]</code> 是 4。</li>\n<li><code>A[1]</code> 是 2。</li>\n<li><code>A[2]</code> 是 8。比 5 大。</li>\n</ul>\n</li>\n<li>把 8 扔到右边的“坑” (<code>A[high]</code> 即 <code>A[5]</code>)。<code>A[2]</code> 变成新“坑”。<br>数组：<code>[4, 2, 坑, 1, 9, 8]</code></li>\n<li><strong>从右往左</strong>（<code>high</code> 从 5 开始）…<ul>\n<li>… <code>A[4]</code> 是 9。</li>\n<li><code>A[3]</code> 是 1。比 5 小。</li>\n</ul>\n</li>\n<li>把 1 扔到左边的“坑” (<code>A[low]</code> 即 <code>A[2]</code>)。<code>A[3]</code> 变成新“坑”。<br>数组：<code>[4, 2, 1, 坑, 9, 8]</code></li>\n<li><strong>从左往右</strong>（<code>low</code> 从 2 开始）…<ul>\n<li><code>A[2]</code> 是 1。</li>\n<li><code>A[3]</code>… <code>low</code> 和 <code>high</code> 在 3 这个位置相遇了。循环 <code>while (low &lt; high)</code> 结束。</li>\n</ul>\n</li>\n<li>把 <code>pivot</code> (存的 <strong>5</strong>) 放到 <code>A[low]</code> (即 <code>A[3]</code>)。<br>数组：<code>[4, 2, 1, 5, 9, 8]</code></li>\n<li>返回 <code>low</code> (即 3)。</li>\n</ol>\n<p><strong>看，现在数组变成了 <code>[4, 2, 1]</code> （都比5小） | <code>5</code> | <code>[9, 8]</code> （都比5大）。</strong> 这就是“站队”！</p>\n<hr>\n<h4 id=\"2-QuickSort-函数（“分而治之”的递归）\"><a href=\"#2-QuickSort-函数（“分而治之”的递归）\" class=\"headerlink\" title=\"2. QuickSort 函数（“分而治之”的递归）\"></a>2. <code>QuickSort</code> 函数（“分而治之”的递归）</h4><p>这个函数是“分治”思想的体现，它来“指挥”<code>Partition</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">QuickSort</span><span class=\"hljs-params\">(T A[], <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (low &lt; high) &#123; <span class=\"hljs-comment\">// 如果队伍里至少有2个人</span><br>    <span class=\"hljs-comment\">// 1. 先站队，并拿到基准最后的位置</span><br>    <span class=\"hljs-type\">int</span> pivot_pos = <span class=\"hljs-built_in\">Partition</span>(A, low, high); <br>    <br>    <span class=\"hljs-comment\">// 2. 指挥“左队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, low, pivot_pos - <span class=\"hljs-number\">1</span>); <br>    <br>    <span class=\"hljs-comment\">// 3. 指挥“右队”去递归排序</span><br>    <span class=\"hljs-built_in\">QuickSort</span>(A, pivot + <span class=\"hljs-number\">1</span>, high); <br>  &#125;<br>  <span class=\"hljs-comment\">// 如果 low &gt;= high (队伍里只有1个人或0个人)，自然就是有序的，不用管了。</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><code>QuickSort</code> 函数是<strong>宏观管理者</strong>：它负责“分”，决定对哪一段（从 <code>low</code> 到 <code>high</code>）进行排序。</li>\n<li><code>Partition</code> 函数是<strong>具体执行者</strong>：它负责“治”，在一段里选个基准，把队伍分成“左队”和“右队”。</li>\n<li>通过<strong>递归</strong>，宏观管理者不断地把任务（大队伍）拆分成更小的任务（小队伍），直到任务小到不需要再拆分（队伍里只有一个人），整个排序就完成了。</li>\n</ol>\n<p>您提供的资料中提到“不用合并”，就是因为 <code>Partition</code> 这一步已经保证了“左队”所有的数都小于“右队”，所以当两队各自排好序后，合起来自然就是有序的。</p>\n<hr>\n<p>后面还有<a href=\"https://oi-wiki.org/basic/quick-sort/\">优化算法</a>，我真不想看了，之后有空再看。</p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>我草怎么还有。。。<br>直接放<a href=\"https://oi-wiki.org/basic/merge-sort/\">归并</a>的链接吧</p>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实还有sort函数，要写一个函数作为排序的算法。<br>我感觉我这样学习效率很低，应该做题，不会的再去查概念。<br>先去吃个饭，等下学递归的时候改一下学习方法。</p>\n"},{"title":"note example","date":"2025-11-05T11:39:16.000Z","cover":"/images/oi_cover.jpg","_content":"整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。  \n我决定给自己提供一个笔记模板。\n\n---\n## 算法\n\n[介绍]\n\n## 题目\n### [题目名称](www.example.com)\n(遇到的问题)\n\n\n---\n这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。","source":"_posts/note-example.md","raw":"---\ntitle: note example\ndate: 2025-11-05 19:39:16\ntags: \ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。  \n我决定给自己提供一个笔记模板。\n\n---\n## 算法\n\n[介绍]\n\n## 题目\n### [题目名称](www.example.com)\n(遇到的问题)\n\n\n---\n这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。","slug":"note-example","published":1,"updated":"2025-11-08T09:45:22.482Z","comments":1,"layout":"post","photos":[],"_id":"cuid03tFwGshlUU2ChQDKNprA","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><p>整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。<br>我决定给自己提供一个笔记模板。</p>\n<hr>\n<h2><span id=\"%E7%AE%97%E6%B3%95\">算法</span></h2><p>[介绍]</p>\n<h2><span id=\"%E9%A2%98%E7%9B%AE\">题目</span></h2><h3><span id=\"%E9%A2%98%E7%9B%AE%E5%90%8D%E7%A7%B0\"></span></h3><p>(遇到的问题)</p>\n<hr>\n<p>这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。</p>\n</body></html>","excerpt":"","more":"<p>整理下自己的思路，我发现这么学习效率太低，被笔记所裹挟了，也违背了学习以题目为主的初衷。<br>我决定给自己提供一个笔记模板。</p>\n<hr>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>[介绍]</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h3 id=\"题目名称\"><a href=\"#题目名称\" class=\"headerlink\" title=\"题目名称\"></a><a href=\"www.example.com\">题目名称</a></h3><p>(遇到的问题)</p>\n<hr>\n<p>这个模板非常简略，主要是先学习算法，然后再做题时发现什么问题，再进行记录。</p>\n"},{"title":"笔记简介","date":"2025-11-05T07:12:57.000Z","cover":"/images/oi_cover.jpg","_content":"## 为什么要写这个笔记\n在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。\n\n## 我会在笔记中记录什么\n* 我做的题目，解题思路，每次错误的版本，错误的原因。\n\n* 算法的解析，ai的解释，我的思考。\n\n* 我的心路历程\n\n* 一些碎碎念\n\n> 准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。  \n希望能和在记录过程中不断进步。\n---\n目前的想法是利用[洛谷题单](https://www.luogu.com.cn/training/list)，洛谷编的书逐步学习。\n\n那么就开始吧。","source":"_posts/oi-note-description.md","raw":"---\ntitle: 笔记简介\ndate: 2025-11-05 15:12:57\ntags: \ncategories : 算法学习笔记\ncover: /images/oi_cover.jpg\n---\n## 为什么要写这个笔记\n在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。\n\n## 我会在笔记中记录什么\n* 我做的题目，解题思路，每次错误的版本，错误的原因。\n\n* 算法的解析，ai的解释，我的思考。\n\n* 我的心路历程\n\n* 一些碎碎念\n\n> 准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。  \n希望能和在记录过程中不断进步。\n---\n目前的想法是利用[洛谷题单](https://www.luogu.com.cn/training/list)，洛谷编的书逐步学习。\n\n那么就开始吧。","slug":"oi-note-description","published":1,"updated":"2025-11-08T09:45:22.482Z","comments":1,"layout":"post","photos":[],"_id":"cuidYA9V2ZadcxVZIvnyNevKl","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><html><head></head><body><h2><span id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E8%BF%99%E4%B8%AA%E7%AC%94%E8%AE%B0\">为什么要写这个笔记</span></h2><p>在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。</p>\n<h2><span id=\"%E6%88%91%E4%BC%9A%E5%9C%A8%E7%AC%94%E8%AE%B0%E4%B8%AD%E8%AE%B0%E5%BD%95%E4%BB%80%E4%B9%88\">我会在笔记中记录什么</span></h2><ul>\n<li><p>我做的题目，解题思路，每次错误的版本，错误的原因。</p>\n</li>\n<li><p>算法的解析，ai的解释，我的思考。</p>\n</li>\n<li><p>我的心路历程</p>\n</li>\n<li><p>一些碎碎念</p>\n</li>\n</ul>\n<blockquote>\n<p>准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。<br>希望能和在记录过程中不断进步。</p>\n</blockquote>\n<hr>\n<p>目前的想法是利用<a href=\"https://www.luogu.com.cn/training/list\">洛谷题单</a>，洛谷编的书逐步学习。</p>\n<p>那么就开始吧。</p>\n</body></html>","excerpt":"","more":"<h2 id=\"为什么要写这个笔记\"><a href=\"#为什么要写这个笔记\" class=\"headerlink\" title=\"为什么要写这个笔记\"></a>为什么要写这个笔记</h2><p>在我学习编程的过程中，并没有养成记录的习惯，导致之前的学习中查找的资料与想法完全忘记了。于是乎我动了写md记录的想法。</p>\n<h2 id=\"我会在笔记中记录什么\"><a href=\"#我会在笔记中记录什么\" class=\"headerlink\" title=\"我会在笔记中记录什么\"></a>我会在笔记中记录什么</h2><ul>\n<li><p>我做的题目，解题思路，每次错误的版本，错误的原因。</p>\n</li>\n<li><p>算法的解析，ai的解释，我的思考。</p>\n</li>\n<li><p>我的心路历程</p>\n</li>\n<li><p>一些碎碎念</p>\n</li>\n</ul>\n<blockquote>\n<p>准确而言，本人没有经过系统性学习算法，编程也只学习了两个月，目前只会使用cpp的一些基础的语法。<br>希望能和在记录过程中不断进步。</p>\n</blockquote>\n<hr>\n<p>目前的想法是利用<a href=\"https://www.luogu.com.cn/training/list\">洛谷题单</a>，洛谷编的书逐步学习。</p>\n<p>那么就开始吧。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Another_Page/cover_Another_Page.jpg","slug":"cover_Another_Page.jpg","post":"cuidaTRWefn990XXtlzXuzEZE","modified":0,"renderable":0},{"_id":"source/_posts/Another_Page/image1.jpg","slug":"image1.jpg","post":"cuidaTRWefn990XXtlzXuzEZE","modified":0,"renderable":0},{"_id":"source/_posts/Another_Page/image2.jpg","slug":"image2.jpg","post":"cuidaTRWefn990XXtlzXuzEZE","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cuidaTRWefn990XXtlzXuzEZE","category_id":"cuideuhaFnnhgmsle-TofSvUZ","_id":"cuid8LDCOzB_XG5vqEtYMd4ds"},{"post_id":"cuidtLQBUm2Ide4aYhyUsOfQa","category_id":"cuidsHeMOEo3SoxtOhuvorDAX","_id":"cuidd1lE3wgLi9Y0d-FGm53LI"},{"post_id":"cuidfgvHOb3Na05UtcubsSuW_","category_id":"cuidOPV_bdCTy7OmpVySwcRij","_id":"cuidgLlG2Hz7r2extLzJI3fZg"},{"post_id":"cuidoc7fHOuUUflH1gUXX7YW8","category_id":"cuidvYjl1UMtfcUK5Fvz-vxZV","_id":"cuidoMW31bX7VjCw7Qoh4Z7Lc"},{"post_id":"cuid03tFwGshlUU2ChQDKNprA","category_id":"cuidvYjl1UMtfcUK5Fvz-vxZV","_id":"cuidiKUWOG50CQn8D8q71gMkq"},{"post_id":"cuidYA9V2ZadcxVZIvnyNevKl","category_id":"cuidvYjl1UMtfcUK5Fvz-vxZV","_id":"cuidos3atW9Y4k1X8HGVRt277"}],"PostTag":[{"post_id":"cuidaTRWefn990XXtlzXuzEZE","tag_id":"cuidb2Xr_jVy_2OOxrliq8YcU","_id":"cuidL8VGxTx_cWewlle1Dklet"},{"post_id":"cuidtLQBUm2Ide4aYhyUsOfQa","tag_id":"cuidW7wdK3MUSi2FcBp9vic-l","_id":"cuidqlJ1f0DsvClRanvDNHXaa"}],"Tag":[{"name":"胡思乱想","_id":"cuidb2Xr_jVy_2OOxrliq8YcU"},{"name":"吐槽","_id":"cuidW7wdK3MUSi2FcBp9vic-l"}]}}
>>>>>>> 3a6428c5f6220ac174450f7212567f26417bc37c
